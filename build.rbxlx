<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0.27450982</R>
        <G>0.27450982</G>
        <B>0.27450982</B>
      </Color3>
      <float name="Brightness">2</float>
      <float name="ClockTime">14</float>
      <float name="ExposureCompensation">0.2</float>
      <float name="GeographicLatitude">0</float>
      <bool name="GlobalShadows">true</bool>
      <bool name="Outlines">false</bool>
      <token name="Technology">3</token>
      <string name="TimeOfDay">14:00:00</string>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Assets</string>
      </Properties>
      <Item class="Folder" referent="3">
        <Properties>
          <string name="Name">Models</string>
        </Properties>
        <Item class="Folder" referent="4">
          <Properties>
            <string name="Name">Buildings</string>
          </Properties>
          <Item class="Folder" referent="5">
            <Properties>
              <string name="Name">Furniture</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="6">
            <Properties>
              <string name="Name">Structures</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="7">
          <Properties>
            <string name="Name">Characters</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="8">
          <Properties>
            <string name="Name">Resources</string>
          </Properties>
          <Item class="Folder" referent="9">
            <Properties>
              <string name="Name">Ores</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="10">
            <Properties>
              <string name="Name">Plants</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="11">
            <Properties>
              <string name="Name">Rocks</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="12">
            <Properties>
              <string name="Name">Trees</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="13">
          <Properties>
            <string name="Name">Tools</string>
          </Properties>
          <Item class="Folder" referent="14">
            <Properties>
              <string name="Name">BronzeTools</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="15">
            <Properties>
              <string name="Name">IronTools</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="16">
            <Properties>
              <string name="Name">StoneTools</string>
            </Properties>
            <Item class="ModuleScript" referent="17">
              <Properties>
                <string name="Name">StonePickaxe</string>
                <string name="Source"><![CDATA[-- assets/models/tools/stone/StonePickaxe.lua
-- Pioche en pierre fonctionnelle avec assets vérifiés

local function CreateStonePickaxe()
    local tool = Instance.new("Tool")
    tool.Name = "StonePickaxe"
    tool.CanBeDropped = true
    tool.RequiresHandle = true
    tool.ToolTip = "Pioche en pierre - Mine la pierre et les minerais"
    tool.Grip = CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(90), 0, 0)
    
    -- ========================================
    -- PARTIE 1 : MANCHE (Handle obligatoire)
    -- ========================================
    local handle = Instance.new("Part")
    handle.Name = "Handle"
    handle.Size = Vector3.new(0.25, 3.5, 0.25)
    handle.Material = Enum.Material.Wood
    handle.Color = Color3.fromRGB(120, 81, 45) -- Bois foncé
    handle.CanCollide = false
    handle.Anchored = false
    handle.Parent = tool
    
    -- ========================================
    -- PARTIE 2 : TÊTE DE LA PIOCHE
    -- ========================================
    local head = Instance.new("Part")
    head.Name = "PickaxeHead"
    head.Size = Vector3.new(1.8, 0.6, 0.4)
    head.Material = Enum.Material.Slate
    head.Color = Color3.fromRGB(100, 100, 105) -- Gris pierre
    head.CanCollide = false
    head.Anchored = false
    head.Parent = handle -- Parent au Handle !
    
    -- Positionner la tête au sommet du manche
    local headWeld = Instance.new("Weld")
    headWeld.Name = "HeadToHandle"
    headWeld.Part0 = handle
    headWeld.Part1 = head
    -- Position : au sommet du manche (1.75 unités) + moitié de la tête (0.3)
    headWeld.C0 = CFrame.new(0, 1.75, 0) * CFrame.Angles(0, 0, 0)
    headWeld.C1 = CFrame.new(0, 0, 0)
    headWeld.Parent = head
    
    -- ========================================
    -- PARTIE 3 : DÉTAILS VISUELS (Optionnel)
    -- ========================================
    -- Pointe gauche de la pioche
    local leftPoint = Instance.new("WedgePart")
    leftPoint.Name = "LeftPoint"
    leftPoint.Size = Vector3.new(0.4, 0.6, 0.8)
    leftPoint.Material = Enum.Material.Slate
    leftPoint.Color = Color3.fromRGB(90, 90, 95)
    leftPoint.CanCollide = false
    leftPoint.Anchored = false
    leftPoint.Parent = handle
    
    local leftWeld = Instance.new("Weld")
    leftWeld.Part0 = head
    leftWeld.Part1 = leftPoint
    leftWeld.C0 = CFrame.new(-0.9, 0, 0.2) * CFrame.Angles(0, math.rad(90), math.rad(90))
    leftWeld.Parent = leftPoint
    
    -- Pointe droite de la pioche
    local rightPoint = Instance.new("WedgePart")
    rightPoint.Name = "RightPoint"
    rightPoint.Size = Vector3.new(0.4, 0.6, 0.8)
    rightPoint.Material = Enum.Material.Slate
    rightPoint.Color = Color3.fromRGB(90, 90, 95)
    rightPoint.CanCollide = false
    rightPoint.Anchored = false
    rightPoint.Parent = handle
    
    local rightWeld = Instance.new("Weld")
    rightWeld.Part0 = head
    rightWeld.Part1 = rightPoint
    rightWeld.C0 = CFrame.new(0.9, 0, 0.2) * CFrame.Angles(0, math.rad(-90), math.rad(-90))
    rightWeld.Parent = rightPoint
    
    -- Renfort au centre du manche
    local grip = Instance.new("Part")
    grip.Name = "Grip"
    grip.Size = Vector3.new(0.35, 0.8, 0.35)
    grip.Material = Enum.Material.Fabric
    grip.Color = Color3.fromRGB(80, 50, 30) -- Cuir/tissu brun
    grip.CanCollide = false
    grip.Anchored = false
    grip.Parent = handle
    
    local gripWeld = Instance.new("Weld")
    gripWeld.Part0 = handle
    gripWeld.Part1 = grip
    gripWeld.C0 = CFrame.new(0, 0, 0)
    gripWeld.Parent = grip
    
    -- ========================================
    -- PARTIE 4 : ATTRIBUTS ET STATISTIQUES
    -- ========================================
    tool:SetAttribute("ToolType", "pickaxe")
    tool:SetAttribute("Durability", 100)
    tool:SetAttribute("MaxDurability", 100)
    tool:SetAttribute("Damage", 4)
    tool:SetAttribute("MiningSpeed", 2.0) -- Multiplicateur de vitesse
    tool:SetAttribute("TechLevel", "stone")
    
    -- Ressources que cet outil peut miner
    local minableValue = Instance.new("StringValue")
    minableValue.Name = "Minable"
    minableValue.Value = "stone,copper_ore,tin_ore,coal"
    minableValue.Parent = tool
    
    -- Multiplicateur de récolte
    local multiplierValue = Instance.new("NumberValue")
    multiplierValue.Name = "GatherMultiplier"
    multiplierValue.Value = 2
    multiplierValue.Parent = tool
    
    -- ========================================
    -- PARTIE 5 : SONS RÉUTILISABLES (IDs vérifiés ✅)
    -- ========================================
    local miningSound = Instance.new("Sound")
    miningSound.Name = "MiningSound"
    miningSound.SoundId = "rbxassetid://1682469441" -- ✅ Pickaxe Hit [SOUND EFFECT]
    miningSound.Volume = 0.6
    miningSound.PlaybackSpeed = 1.1
    miningSound.Parent = handle
    
    local breakSound = Instance.new("Sound")
    breakSound.Name = "BreakSound"
    breakSound.SoundId = "rbxassetid://7108607217" -- ✅ Lego Break Sound Effect
    breakSound.Volume = 0.8
    breakSound.PlaybackSpeed = 0.9
    breakSound.Parent = handle
    
    -- ========================================
    -- PARTIE 6 : SCRIPT CLIENT (Animations)
    -- ========================================
    local clientScript = Instance.new("LocalScript")
    clientScript.Name = "ToolController"
    clientScript.Source = [[
        local tool = script.Parent
        local handle = tool:WaitForChild("Handle")
        local miningSound = handle:WaitForChild("MiningSound")
        
        local player = nil
        local character = nil
        local humanoid = nil
        local animator = nil
        local swingAnimation = nil
        
        local isSwinging = false
        local COOLDOWN = 0.8 -- Temps entre chaque coup
        
        -- Charger l'animation
        local function loadAnimation()
            if humanoid then
                animator = humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    local animInstance = Instance.new("Animation")
                    animInstance.AnimationId = "rbxassetid://522635514" -- ✅ R15Slash (vérifié)
                    
                    swingAnimation = animator:LoadAnimation(animInstance)
                    swingAnimation.Priority = Enum.AnimationPriority.Action
                    swingAnimation.Looped = false
                end
            end
        end
        
        -- Équipement de l'outil
        tool.Equipped:Connect(function()
            player = game.Players.LocalPlayer
            character = player.Character or player.CharacterAdded:Wait()
            humanoid = character:WaitForChild("Humanoid")
            
            loadAnimation()
        end)
        
        -- Déséquipement
        tool.Unequipped:Connect(function()
            if swingAnimation then
                swingAnimation:Stop()
            end
            isSwinging = false
        end)
        
        -- Activation (clic gauche)
        tool.Activated:Connect(function()
            if isSwinging then return end
            
            isSwinging = true
            
            -- Jouer l'animation
            if swingAnimation then
                swingAnimation:Play()
            end
            
            -- Jouer le son
            if miningSound and not miningSound.IsPlaying then
                miningSound:Play()
            end
            
            -- Effet visuel de particules
            local particles = Instance.new("ParticleEmitter")
            particles.Texture = "rbxasset://textures/particles/smoke_main.dds"
            particles.Color = ColorSequence.new(Color3.fromRGB(150, 150, 150))
            particles.Size = NumberSequence.new(0.2, 0.5)
            particles.Lifetime = NumberRange.new(0.3, 0.6)
            particles.Rate = 20
            particles.Speed = NumberRange.new(3, 6)
            particles.SpreadAngle = Vector2.new(30, 30)
            particles.Parent = handle
            particles.Enabled = true
            
            -- Désactiver après un court instant
            task.wait(0.1)
            particles.Enabled = false
            game:GetService("Debris"):AddItem(particles, 1)
            
            -- Cooldown
            task.wait(COOLDOWN)
            isSwinging = false
        end)
    ]]
    clientScript.Parent = tool
    
    -- ========================================
    -- PARTIE 7 : SCRIPT SERVEUR (Logique)
    -- ========================================
    local serverScript = Instance.new("Script")
    serverScript.Name = "ToolServerScript"
    serverScript.Source = [[
        local tool = script.Parent
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        local durability = tool:GetAttribute("Durability")
        local maxDurability = tool:GetAttribute("MaxDurability")
        local damage = tool:GetAttribute("Damage")
        
        local lastUseTime = 0
        local USE_COOLDOWN = 0.8
        
        -- Fonction pour notifier le joueur (utilise ReplicatedStorage.Events.Notification)
        local function notifyPlayer(player, message, messageType, duration)
            local success, err = pcall(function()
                ReplicatedStorage.Events.Notification:FireClient(
                    player, 
                    message, 
                    messageType or "info", 
                    duration or 3
                )
            end)
            
            if not success then
                warn("[StonePickaxe] Erreur notification:", err)
            end
        end
        
        -- Fonction pour réduire la durabilité
        local function reduceDurability(player)
            if durability <= 0 then return false end
            
            durability = durability - 1
            tool:SetAttribute("Durability", durability)
            
            -- Avertissement à 20%
            if durability <= maxDurability * 0.2 and durability > 0 then
                notifyPlayer(
                    player, 
                    "Votre pioche est presque cassée ! (" .. durability .. "/" .. maxDurability .. ")", 
                    "warning", 
                    3
                )
            end
            
            -- Outil cassé
            if durability <= 0 then
                local breakSound = tool.Handle:FindFirstChild("BreakSound")
                if breakSound then
                    breakSound:Play()
                end
                
                notifyPlayer(
                    player, 
                    "Votre pioche en pierre s'est cassée !", 
                    "error", 
                    5
                )
                
                -- Détruire après le son
                task.wait(0.5)
                tool:Destroy()
                return false
            end
            
            return true
        end
        
        -- Activation de l'outil
        tool.Activated:Connect(function()
            local currentTime = tick()
            if currentTime - lastUseTime < USE_COOLDOWN then
                return
            end
            lastUseTime = currentTime
            
            local character = tool.Parent
            if not character or not character:IsA("Model") then return end
            
            local player = game.Players:GetPlayerFromCharacter(character)
            if not player then return end
            
            local humanoid = character:FindFirstChild("Humanoid")
            if not humanoid or humanoid.Health <= 0 then return end
            
            -- Réduire la durabilité
            reduceDurability(player)
            
            -- Raycast pour détecter ce qui est frappé
            local handle = tool:FindFirstChild("Handle")
            if not handle then return end
            
            local rayOrigin = handle.Position
            local rayDirection = (handle.CFrame.LookVector * 6) -- 6 studs de portée
            
            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Exclude
            raycastParams.FilterDescendantsInstances = {character, tool}
            
            local rayResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
            
            if rayResult and rayResult.Instance then
                local hitPart = rayResult.Instance
                
                -- Logique de minage (à adapter selon votre jeu)
                if hitPart:FindFirstChild("Resource") or hitPart:GetAttribute("Mineable") then
                    -- Votre logique de récolte de ressources ici
                    print("[StonePickaxe] Minage de:", hitPart.Name)
                    
                    -- Exemple : infliger des dégâts à la ressource
                    local resourceHealth = hitPart:GetAttribute("Health")
                    if resourceHealth then
                        local newHealth = resourceHealth - damage
                        hitPart:SetAttribute("Health", newHealth)
                        
                        if newHealth <= 0 then
                            print("[StonePickaxe] Ressource détruite:", hitPart.Name)
                            -- Logique de drop de ressources
                        end
                    end
                end
            end
        end)
    ]]
    serverScript.Parent = tool
    
    return tool
end

return CreateStonePickaxe
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="18">
        <Properties>
          <string name="Name">Sounds</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="19">
        <Properties>
          <string name="Name">Textures</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="20">
        <Properties>
          <string name="Name">UI</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="21">
      <Properties>
        <string name="Name">Events</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="22">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="Folder" referent="23">
        <Properties>
          <string name="Name">animations</string>
        </Properties>
        <Item class="ModuleScript" referent="24">
          <Properties>
            <string name="Name">MiningAnimation</string>
            <string name="Source"><![CDATA[-- src/shared/animations/MiningAnimation.lua
-- Animation de minage créée programmatiquement

local MiningAnimation = {}

-- Crée une animation de minage basique
function MiningAnimation.Create()
    -- Créer une animation
    local animation = Instance.new("Animation")
    
    -- Créer la séquence d'animation
    local keyframeSequence = Instance.new("KeyframeSequence")
    keyframeSequence.Name = "MiningSequence"
    keyframeSequence.Priority = Enum.AnimationPriority.Action
    
    -- Keyframe 1: Position initiale
    local keyframe1 = Instance.new("Keyframe")
    keyframe1.Time = 0
    
    -- Position des bras pour la position initiale (légèrement en arrière)
    local rightShoulder1 = Instance.new("Pose")
    rightShoulder1.Name = "Right Shoulder"
    rightShoulder1.CFrame = CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(-30), math.rad(20), math.rad(0))
    rightShoulder1.Parent = keyframe1
    
    local leftShoulder1 = Instance.new("Pose")
    leftShoulder1.Name = "Left Shoulder"
    leftShoulder1.CFrame = CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(-30), math.rad(-20), math.rad(0))
    leftShoulder1.Parent = keyframe1
    
    local rightElbow1 = Instance.new("Pose")
    rightElbow1.Name = "Right Elbow"
    rightElbow1.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(0))
    rightElbow1.Parent = keyframe1
    
    local leftElbow1 = Instance.new("Pose")
    leftElbow1.Name = "Left Elbow"
    leftElbow1.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(0))
    leftElbow1.Parent = keyframe1
    
    keyframe1.Parent = keyframeSequence
    
    -- Keyframe 2: Balancement vers l'avant (impact)
    local keyframe2 = Instance.new("Keyframe")
    keyframe2.Time = 0.3
    
    local rightShoulder2 = Instance.new("Pose")
    rightShoulder2.Name = "Right Shoulder"
    rightShoulder2.CFrame = CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(20), math.rad(0))
    rightShoulder2.Parent = keyframe2
    
    local leftShoulder2 = Instance.new("Pose")
    leftShoulder2.Name = "Left Shoulder"
    leftShoulder2.CFrame = CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(-20), math.rad(0))
    leftShoulder2.Parent = keyframe2
    
    local rightElbow2 = Instance.new("Pose")
    rightElbow2.Name = "Right Elbow"
    rightElbow2.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-40), math.rad(0), math.rad(0))
    rightElbow2.Parent = keyframe2
    
    local leftElbow2 = Instance.new("Pose")
    leftElbow2.Name = "Left Elbow"
    leftElbow2.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-40), math.rad(0), math.rad(0))
    leftElbow2.Parent = keyframe2
    
    -- Ajouter un léger mouvement de torse pour plus de réalisme
    local waist2 = Instance.new("Pose")
    waist2.Name = "Waist"
    waist2.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0))
    waist2.Parent = keyframe2
    
    keyframe2.Parent = keyframeSequence
    
    -- Keyframe 3: Retour à la position de départ
    local keyframe3 = Instance.new("Keyframe")
    keyframe3.Time = 0.6
    
    -- Copier les poses de la keyframe 1
    local rightShoulder3 = rightShoulder1:Clone()
    rightShoulder3.Parent = keyframe3
    
    local leftShoulder3 = leftShoulder1:Clone()
    leftShoulder3.Parent = keyframe3
    
    local rightElbow3 = rightElbow1:Clone()
    rightElbow3.Parent = keyframe3
    
    local leftElbow3 = leftElbow1:Clone()
    leftElbow3.Parent = keyframe3
    
    -- Retour du torse à la position normale
    local waist3 = Instance.new("Pose")
    waist3.Name = "Waist"
    waist3.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
    waist3.Parent = keyframe3
    
    keyframe3.Parent = keyframeSequence
    
    -- Ajouter la séquence à l'animation
    keyframeSequence.Parent = animation
    
    -- Dans une implémentation réelle, vous devrez télécharger l'animation
    -- dans Roblox Studio et utiliser l'ID obtenu
    animation.AnimationId = "" -- Sera rempli après avoir téléchargé l'animation dans Studio
    
    return animation
end

-- Charge et joue l'animation de minage sur un Humanoid
function MiningAnimation.Play(humanoid)
    if not humanoid then
        warn("MiningAnimation.Play: Humanoid requis")
        return nil
    end
    
    -- Vérifier si l'animateur existe déjà
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end
    
    -- Créer l'animation
    local animationInstance = MiningAnimation.Create()
    
    -- Charger et jouer l'animation
    local animTrack = animator:LoadAnimation(animationInstance)
    animTrack:Play()
    
    return animTrack
end

-- Fonction auxiliaire pour jouer l'animation de minage depuis un outil
function MiningAnimation.SetupToolAnimation(tool)
    if not tool then
        warn("MiningAnimation.SetupToolAnimation: Tool requis")
        return nil
    end
    
    local animationScript = Instance.new("LocalScript")
    animationScript.Name = "MiningAnimationController"
    
    animationScript.Source = [[
    local tool = script.Parent
    local player = nil
    local character = nil
    local humanoid = nil
    local animTrack = nil
    
    -- Fonction pour préparer l'animation
    local function setupAnimation()
        if not character or not humanoid then return end
        
        -- Créer l'animation
        local animation = Instance.new("Animation")
        
        -- À remplacer par votre ID d'animation quand disponible
        animation.AnimationId = ""
        
        -- Charger l'animation
        animTrack = humanoid:LoadAnimation(animation)
        
        -- Configurer les propriétés de l'animation
        animTrack.Priority = Enum.AnimationPriority.Action
        animTrack.Looped = false
    end
    
    -- Quand l'outil est équipé
    tool.Equipped:Connect(function()
        player = game.Players.LocalPlayer
        character = player.Character
        if character then
            humanoid = character:FindFirstChild("Humanoid")
            setupAnimation()
        end
    end)
    
    -- Quand l'outil est activé (utilisé)
    tool.Activated:Connect(function()
        if animTrack then
            animTrack:Play()
            
            -- Jouer un son de minage
            local miningSound = Instance.new("Sound")
            miningSound.SoundId = "" -- À remplacer par votre ID de son quand disponible
            miningSound.Volume = a0.8
            miningSound.Parent = tool.Handle
            miningSound:Play()
            
            -- Détruire le son après lecture
            miningSound.Ended:Connect(function()
                miningSound:Destroy()
            end)
        end
    end)
    
    -- Quand l'outil est déséquipé
    tool.Unequipped:Connect(function()
        if animTrack and animTrack.IsPlaying then
            animTrack:Stop()
        end
        
        player = nil
        character = nil
        humanoid = nil
        animTrack = nil
    end)
    ]]
    
    animationScript.Parent = tool
    
    return animationScript
end

-- Fonction pour créer un KeyframeSequence
function MiningAnimation.CreateKeyframeSequence()
    local keyframeSequence = Instance.new("KeyframeSequence")
    keyframeSequence.Name = "MiningSequence"
    
    -- Keyframe 1: Position initiale
    local keyframe1 = Instance.new("Keyframe")
    keyframe1.Time = 0
    
    local rightShoulder1 = Instance.new("Pose")
    rightShoulder1.Name = "Right Shoulder"
    rightShoulder1.CFrame = CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(-30), math.rad(20), math.rad(0))
    rightShoulder1.Parent = keyframe1
    
    local leftShoulder1 = Instance.new("Pose")
    leftShoulder1.Name = "Left Shoulder"
    leftShoulder1.CFrame = CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(-30), math.rad(-20), math.rad(0))
    leftShoulder1.Parent = keyframe1
    
    local rightElbow1 = Instance.new("Pose")
    rightElbow1.Name = "Right Elbow"
    rightElbow1.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(0))
    rightElbow1.Parent = keyframe1
    
    local leftElbow1 = Instance.new("Pose")
    leftElbow1.Name = "Left Elbow"
    leftElbow1.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(0))
    leftElbow1.Parent = keyframe1
    
    keyframe1.Parent = keyframeSequence
    
    -- Keyframe 2: Balancement vers l'avant (impact)
    local keyframe2 = Instance.new("Keyframe")
    keyframe2.Time = 0.3
    
    local rightShoulder2 = Instance.new("Pose")
    rightShoulder2.Name = "Right Shoulder"
    rightShoulder2.CFrame = CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(20), math.rad(0))
    rightShoulder2.Parent = keyframe2
    
    local leftShoulder2 = Instance.new("Pose")
    leftShoulder2.Name = "Left Shoulder"
    leftShoulder2.CFrame = CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(40), math.rad(-20), math.rad(0))
    leftShoulder2.Parent = keyframe2
    
    local rightElbow2 = Instance.new("Pose")
    rightElbow2.Name = "Right Elbow"
    rightElbow2.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-40), math.rad(0), math.rad(0))
    rightElbow2.Parent = keyframe2
    
    local leftElbow2 = Instance.new("Pose")
    leftElbow2.Name = "Left Elbow"
    leftElbow2.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-40), math.rad(0), math.rad(0))
    leftElbow2.Parent = keyframe2
    
    local waist2 = Instance.new("Pose")
    waist2.Name = "Waist"
    waist2.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0))
    waist2.Parent = keyframe2
    
    keyframe2.Parent = keyframeSequence
    
    -- Keyframe 3: Retour à la position de départ
    local keyframe3 = Instance.new("Keyframe")
    keyframe3.Time = 0.6
    
    local rightShoulder3 = rightShoulder1:Clone()
    rightShoulder3.Parent = keyframe3
    
    local leftShoulder3 = leftShoulder1:Clone()
    leftShoulder3.Parent = keyframe3
    
    local rightElbow3 = rightElbow1:Clone()
    rightElbow3.Parent = keyframe3
    
    local leftElbow3 = leftElbow1:Clone()
    leftElbow3.Parent = keyframe3
    
    local waist3 = Instance.new("Pose")
    waist3.Name = "Waist"
    waist3.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
    waist3.Parent = keyframe3
    
    keyframe3.Parent = keyframeSequence
    
    return keyframeSequence
end

-- Fonction pour enregistrer l'animation (à utiliser uniquement dans Studio avec les permissions)
function MiningAnimation.SaveToRoblox()
    local keyframeSequence = MiningAnimation.CreateKeyframeSequence()
    
    -- Cette fonction ne fonctionnera que dans Roblox Studio avec les permissions appropriées
    local success, result = pcall(function()
        return game:GetService("AnimationService"):SaveAnimation(keyframeSequence)
    end)
    
    if success then
        print("Animation enregistrée avec succès. ID:", result)
        return result
    else
        warn("Échec de l'enregistrement de l'animation:", result)
        return nil
    end
end

-- Créer les animations de récolte pour différents types d'outils
function MiningAnimation.GetAnimationForTool(toolType)
    local animations = {
        ["axe"] = "", -- ID d'animation pour hache
        ["pickaxe"] = "", -- ID d'animation pour pioche
        ["shovel"] = "", -- ID d'animation pour pelle
        ["hammer"] = ""  -- ID d'animation pour marteau
    }
    
    -- Retourner l'ID d'animation approprié ou une animation générique
    return animations[toolType] or ""
end

return MiningAnimation
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="25">
        <Properties>
          <string name="Name">constants</string>
        </Properties>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">CraftingRecipes</string>
            <string name="Source"><![CDATA[-- src/shared/constants/CraftingRecipes.lua

local CraftingRecipes = {
    -- ============================================
    -- ÂGE DE PIERRE - SURVIE PRIMITIVE
    -- ============================================
    
    -- Outils de base en pierre
    ["stone_axe"] = {
        name = "Hache en pierre",
        description = "Un outil primitif pour couper du bois.",
        ingredients = {
            ["stone"] = 3,
            ["wood"] = 2,
            ["fiber"] = 1
        },
        result = {
            id = "stone_axe",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["stone_pickaxe"] = {
        name = "Pioche en pierre",
        description = "Pour miner des pierres et minerais.",
        ingredients = {
            ["stone"] = 3,
            ["wood"] = 2,
            ["fiber"] = 1
        },
        result = {
            id = "stone_pickaxe",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["stone_hammer"] = {
        name = "Marteau en pierre",
        description = "Un outil basique pour la construction.",
        ingredients = {
            ["stone"] = 3,
            ["wood"] = 1,
            ["fiber"] = 2
        },
        result = {
            id = "stone_hammer",
            quantity = 1
        },
        craftTime = 6,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["stone_hoe"] = {
        name = "Houe en pierre",
        description = "Outil primitif pour cultiver la terre.",
        ingredients = {
            ["stone"] = 2,
            ["wood"] = 2,
            ["fiber"] = 1
        },
        result = {
            id = "stone_hoe",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["bone_knife"] = {
        name = "Couteau en os",
        description = "Un outil tranchant fait à partir d'os.",
        ingredients = {
            ["bone"] = 2,
            ["fiber"] = 1
        },
        result = {
            id = "bone_knife",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["flint_knife"] = {
        name = "Couteau en silex",
        description = "Un couteau tranchant pour dépecer et couper.",
        ingredients = {
            ["flint"] = 2,
            ["wood"] = 1,
            ["fiber"] = 1
        },
        result = {
            id = "flint_knife",
            quantity = 1
        },
        craftTime = 4,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Armes primitives
    ["stone_spear"] = {
        name = "Lance en pierre",
        description = "Une arme de chasse primitive.",
        ingredients = {
            ["stone"] = 2,
            ["wood"] = 3,
            ["fiber"] = 2
        },
        result = {
            id = "stone_spear",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_club"] = {
        name = "Massue en bois",
        description = "Une arme contondante primitive.",
        ingredients = {
            ["wood"] = 4,
            ["fiber"] = 1
        },
        result = {
            id = "wooden_club",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_shield"] = {
        name = "Bouclier en bois",
        description = "Protection basique contre les attaques.",
        ingredients = {
            ["wooden_plank"] = 6,
            ["fiber"] = 3
        },
        result = {
            id = "wooden_shield",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_bow"] = {
        name = "Arc en bois",
        description = "Une arme à distance pour la chasse.",
        ingredients = {
            ["wood"] = 4,
            ["fiber"] = 3
        },
        result = {
            id = "wooden_bow",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["arrow"] = {
        name = "Flèche",
        description = "Munition pour l'arc.",
        ingredients = {
            ["wood"] = 1,
            ["stone"] = 1,
            ["fiber"] = 1
        },
        result = {
            id = "arrow",
            quantity = 4
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["slingshot"] = {
        name = "Fronde",
        description = "Arme à projectile simple et efficace.",
        ingredients = {
            ["leather"] = 1,
            ["fiber"] = 3
        },
        result = {
            id = "slingshot",
            quantity = 1
        },
        craftTime = 6,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Pêche et chasse
    ["fishing_rod"] = {
        name = "Canne à pêche",
        description = "Pour attraper des poissons.",
        ingredients = {
            ["wood"] = 3,
            ["fiber"] = 5
        },
        result = {
            id = "fishing_rod",
            quantity = 1
        },
        craftTime = 7,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["fish_trap"] = {
        name = "Nasse à poissons",
        description = "Piège passif pour capturer des poissons.",
        ingredients = {
            ["wood"] = 6,
            ["fiber"] = 8
        },
        result = {
            id = "fish_trap",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["hunting_trap"] = {
        name = "Piège de chasse",
        description = "Pour capturer de petits animaux.",
        ingredients = {
            ["wood"] = 5,
            ["rope"] = 2,
            ["stone"] = 3
        },
        result = {
            id = "hunting_trap",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Vêtements primitifs
    ["fiber_clothes"] = {
        name = "Vêtements en fibre",
        description = "Des vêtements basiques faits de fibres.",
        ingredients = {
            ["fiber"] = 10
        },
        result = {
            id = "fiber_clothes",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["leather"] = {
        name = "Cuir",
        description = "Du cuir tanné pour fabriquer des vêtements.",
        ingredients = {
            ["animal_hide"] = 1,
            ["fiber"] = 2
        },
        result = {
            id = "leather",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["leather_clothes"] = {
        name = "Vêtements en cuir",
        description = "Des vêtements plus résistants que ceux en fibre.",
        ingredients = {
            ["leather"] = 5
        },
        result = {
            id = "leather_clothes",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = "loom"
    },
    
    ["fur_hat"] = {
        name = "Chapeau en fourrure",
        description = "Protège du froid.",
        ingredients = {
            ["fur"] = 3,
            ["leather"] = 1
        },
        result = {
            id = "fur_hat",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = "loom"
    },
    
    ["fur_coat"] = {
        name = "Manteau en fourrure",
        description = "Offre une excellente protection contre le froid.",
        ingredients = {
            ["fur"] = 8,
            ["leather"] = 3,
            ["fiber"] = 5
        },
        result = {
            id = "fur_coat",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "stone",
        requiredStation = "loom"
    },
    
    ["leather_boots"] = {
        name = "Bottes en cuir",
        description = "Protège les pieds et améliore le déplacement.",
        ingredients = {
            ["leather"] = 3,
            ["fiber"] = 2
        },
        result = {
            id = "leather_boots",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = "loom"
    },
    
    -- Conteneurs et transport
    ["rope"] = {
        name = "Corde",
        description = "Utile pour diverses constructions et outils.",
        ingredients = {
            ["fiber"] = 5
        },
        result = {
            id = "rope",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["basket"] = {
        name = "Panier en fibres",
        description = "Pour transporter des objets.",
        ingredients = {
            ["fiber"] = 12,
            ["wood"] = 2
        },
        result = {
            id = "basket",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["leather_backpack"] = {
        name = "Sac à dos en cuir",
        description = "Augmente la capacité d'inventaire.",
        ingredients = {
            ["leather"] = 6,
            ["fiber"] = 4
        },
        result = {
            id = "leather_backpack",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "stone",
        requiredStation = "loom"
    },
    
    ["water_skin"] = {
        name = "Outre en peau",
        description = "Conteneur d'eau primitif.",
        ingredients = {
            ["animal_hide"] = 2,
            ["fiber"] = 3
        },
        result = {
            id = "water_container",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["water_pouch"] = {
        name = "Outre d'eau en cuir",
        description = "Pour transporter et boire de l'eau.",
        ingredients = {
            ["leather"] = 3
        },
        result = {
            id = "water_pouch",
            quantity = 1
        },
        craftTime = 6,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Éclairage primitif
    ["torch"] = {
        name = "Torche",
        description = "Fournit de la lumière dans l'obscurité.",
        ingredients = {
            ["wood"] = 1,
            ["fiber"] = 2
        },
        result = {
            id = "torch",
            quantity = 2
        },
        craftTime = 3,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Soins primitifs
    ["bandage"] = {
        name = "Bandage",
        description = "Soigne les blessures légères.",
        ingredients = {
            ["fiber"] = 3,
            ["plant_fiber"] = 2
        },
        result = {
            id = "bandage",
            quantity = 2
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["herbal_remedy"] = {
        name = "Remède aux herbes",
        description = "Soigne les maladies et infections.",
        ingredients = {
            ["medicinal_herb"] = 3,
            ["berries"] = 2,
            ["water_container"] = 1
        },
        result = {
            id = "herbal_remedy",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    -- Matériaux de construction de base
    ["wooden_plank"] = {
        name = "Planche en bois",
        description = "Un matériau de construction de base.",
        ingredients = {
            ["wood"] = 1
        },
        result = {
            id = "wooden_plank",
            quantity = 4
        },
        craftTime = 2,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["thatch"] = {
        name = "Chaume",
        description = "Matériau de toiture primitif.",
        ingredients = {
            ["fiber"] = 8
        },
        result = {
            id = "thatch",
            quantity = 4
        },
        craftTime = 3,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Structures en bois
    ["wooden_wall"] = {
        name = "Mur en bois",
        description = "Un mur simple en bois.",
        ingredients = {
            ["wooden_plank"] = 8,
            ["fiber"] = 2
        },
        result = {
            id = "wooden_wall",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_door"] = {
        name = "Porte en bois",
        description = "Une porte pour votre habitation.",
        ingredients = {
            ["wooden_plank"] = 6,
            ["fiber"] = 1
        },
        result = {
            id = "wooden_door",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_floor"] = {
        name = "Plancher en bois",
        description = "Un sol en bois pour vos constructions.",
        ingredients = {
            ["wooden_plank"] = 6
        },
        result = {
            id = "wooden_floor",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_foundation"] = {
        name = "Fondation en bois",
        description = "Base solide pour une construction.",
        ingredients = {
            ["wood"] = 10,
            ["stone"] = 4
        },
        result = {
            id = "wooden_foundation",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["thatch_roof"] = {
        name = "Toit en chaume",
        description = "Protection primitive contre la pluie.",
        ingredients = {
            ["thatch"] = 6,
            ["wood"] = 4
        },
        result = {
            id = "thatch_roof",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_roof"] = {
        name = "Toit en bois",
        description = "Protège de la pluie.",
        ingredients = {
            ["wooden_plank"] = 8
        },
        result = {
            id = "wooden_roof",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_window"] = {
        name = "Fenêtre en bois",
        description = "Pour laisser entrer la lumière.",
        ingredients = {
            ["wooden_plank"] = 5
        },
        result = {
            id = "wooden_window",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_stairs"] = {
        name = "Escalier en bois",
        description = "Pour accéder aux étages supérieurs.",
        ingredients = {
            ["wooden_plank"] = 6
        },
        result = {
            id = "wooden_stairs",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_ladder"] = {
        name = "Échelle en bois",
        description = "Pour grimper verticalement.",
        ingredients = {
            ["wood"] = 6,
            ["rope"] = 2
        },
        result = {
            id = "wooden_ladder",
            quantity = 1
        },
        craftTime = 7,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Défenses primitives
    ["wooden_fence"] = {
        name = "Clôture en bois",
        description = "Pour délimiter un espace.",
        ingredients = {
            ["wooden_plank"] = 3,
            ["rope"] = 1
        },
        result = {
            id = "wooden_fence",
            quantity = 2
        },
        craftTime = 6,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_gate"] = {
        name = "Portail en bois",
        description = "Entrée sécurisée pour un enclos.",
        ingredients = {
            ["wooden_plank"] = 8,
            ["rope"] = 2
        },
        result = {
            id = "wooden_gate",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_palisade"] = {
        name = "Palissade en bois",
        description = "Défense périmétrique renforcée.",
        ingredients = {
            ["wood"] = 12,
            ["rope"] = 3
        },
        result = {
            id = "wooden_palisade",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["spike_trap"] = {
        name = "Piège à pointes",
        description = "Défense antipersonnel.",
        ingredients = {
            ["wood"] = 8,
            ["stone"] = 4,
            ["rope"] = 2
        },
        result = {
            id = "spike_trap",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Mobilier primitif
    ["campfire"] = {
        name = "Feu de camp",
        description = "Fournit chaleur et lumière, permet de cuire des aliments.",
        ingredients = {
            ["stone"] = 8,
            ["wood"] = 4
        },
        result = {
            id = "campfire",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["primitive_bed"] = {
        name = "Lit primitif",
        description = "Un lit simple fait de fibres et de feuilles.",
        ingredients = {
            ["fiber"] = 15,
            ["wood"] = 4
        },
        result = {
            id = "primitive_bed",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_bed"] = {
        name = "Lit en bois",
        description = "Un lit simple pour dormir et récupérer de l'énergie.",
        ingredients = {
            ["wooden_plank"] = 6,
            ["fiber"] = 8
        },
        result = {
            id = "wooden_bed",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_table"] = {
        name = "Table en bois",
        description = "Une table simple.",
        ingredients = {
            ["wooden_plank"] = 4
        },
        result = {
            id = "wooden_table",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_chair"] = {
        name = "Chaise en bois",
        description = "Une chaise simple.",
        ingredients = {
            ["wooden_plank"] = 3
        },
        result = {
            id = "wooden_chair",
            quantity = 1
        },
        craftTime = 6,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_bench"] = {
        name = "Banc en bois",
        description = "Peut accueillir plusieurs personnes.",
        ingredients = {
            ["wooden_plank"] = 5
        },
        result = {
            id = "wooden_bench",
            quantity = 1
        },
        craftTime = 7,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_chest"] = {
        name = "Coffre en bois",
        description = "Pour stocker des objets.",
        ingredients = {
            ["wooden_plank"] = 8,
            ["rope"] = 2
        },
        result = {
            id = "wooden_chest",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_shelf"] = {
        name = "Étagère en bois",
        description = "Pour afficher et ranger des objets.",
        ingredients = {
            ["wooden_plank"] = 6
        },
        result = {
            id = "wooden_shelf",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["wooden_sign"] = {
        name = "Panneau en bois",
        description = "Pour écrire des messages.",
        ingredients = {
            ["wooden_plank"] = 2,
            ["charcoal"] = 1
        },
        result = {
            id = "wooden_sign",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["stone_fireplace"] = {
        name = "Cheminée en pierre",
        description = "Un foyer plus élaboré, offre plus de chaleur qu'un feu de camp.",
        ingredients = {
            ["stone"] = 15,
            ["clay"] = 5
        },
        result = {
            id = "stone_fireplace",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- Nourriture - Cuisson basique
    ["cooked_meat"] = {
        name = "Viande cuite",
        description = "De la viande cuite, plus nourrissante que crue.",
        ingredients = {
            ["raw_meat"] = 1
        },
        result = {
            id = "cooked_meat",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    ["cooked_fish"] = {
        name = "Poisson cuit",
        description = "Un poisson cuit, prêt à être consommé.",
        ingredients = {
            ["fish"] = 1
        },
        result = {
            id = "cooked_fish",
            quantity = 1
        },
        craftTime = 6,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    ["dried_meat"] = {
        name = "Viande séchée",
        description = "De la viande conservée qui se garde longtemps.",
        ingredients = {
            ["raw_meat"] = 1
        },
        result = {
            id = "dried_meat",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "stone",
        requiredStation = "drying_rack"
    },
    
    ["smoked_fish"] = {
        name = "Poisson fumé",
        description = "Poisson conservé par fumage.",
        ingredients = {
            ["fish"] = 2,
            ["wood"] = 1
        },
        result = {
            id = "smoked_fish",
            quantity = 2
        },
        craftTime = 25,
        techLevel = "stone",
        requiredStation = "smokehouse"
    },
    
    ["berry_juice"] = {
        name = "Jus de baies",
        description = "Désaltérant et énergisant.",
        ingredients = {
            ["berries"] = 5,
            ["water_container"] = 1
        },
        result = {
            id = "berry_juice",
            quantity = 1
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["roasted_berries"] = {
        name = "Baies grillées",
        description = "Plus nourrissantes que les baies crues.",
        ingredients = {
            ["berries"] = 3
        },
        result = {
            id = "roasted_berries",
            quantity = 3
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    -- Stations de craft - Âge de pierre
    ["loom"] = {
        name = "Métier à tisser",
        description = "Permet de créer des vêtements plus élaborés.",
        ingredients = {
            ["wooden_plank"] = 10,
            ["fiber"] = 15
        },
        result = {
            id = "loom",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["tanning_rack"] = {
        name = "Cadre de tannage",
        description = "Pour transformer les peaux en cuir plus efficacement.",
        ingredients = {
            ["wood"] = 8,
            ["rope"] = 3,
            ["stone"] = 2
        },
        result = {
            id = "tanning_rack",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["drying_rack"] = {
        name = "Séchoir",
        description = "Pour sécher et conserver la viande.",
        ingredients = {
            ["wood"] = 6,
            ["rope"] = 4
        },
        result = {
            id = "drying_rack",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["smokehouse"] = {
        name = "Fumoir",
        description = "Pour fumer et conserver les aliments.",
        ingredients = {
            ["wood"] = 15,
            ["stone"] = 8,
            ["clay"] = 4
        },
        result = {
            id = "smokehouse",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["grinding_stone"] = {
        name = "Meule",
        description = "Pour moudre les grains en farine.",
        ingredients = {
            ["stone"] = 10
        },
        result = {
            id = "grinding_stone",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["workbench"] = {
        name = "Établi",
        description = "Pour créer des objets plus complexes.",
        ingredients = {
            ["wooden_plank"] = 10,
            ["stone"] = 5
        },
        result = {
            id = "workbench",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- ============================================
    -- ÂGE DE L'ARGILE - POTERIE ET CÉRAMIQUE
    -- ============================================
    
    ["clay_pot"] = {
        name = "Pot en argile",
        description = "Pour stocker de la nourriture et des liquides.",
        ingredients = {
            ["clay"] = 3
        },
        result = {
            id = "clay_pot",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    ["water_jug"] = {
        name = "Cruche d'eau en argile",
        description = "Conteneur d'eau en argile cuite.",
        ingredients = {
            ["clay"] = 4
        },
        result = {
            id = "water_container",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    ["clay_bowl"] = {
        name = "Bol en argile",
        description = "Pour manger et servir la nourriture.",
        ingredients = {
            ["clay"] = 2
        },
        result = {
            id = "clay_bowl",
            quantity = 2
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    ["clay_plate"] = {
        name = "Assiette en argile",
        description = "Pour servir les repas.",
        ingredients = {
            ["clay"] = 2
        },
        result = {
            id = "clay_plate",
            quantity = 2
        },
        craftTime = 5,
        techLevel = "stone",
        requiredStation = "campfire"
    },
    
    ["pottery_wheel"] = {
        name = "Tour de potier",
        description = "Permet de fabriquer des poteries plus efficacement.",
        ingredients = {
            ["wood"] = 6,
            ["stone"] = 4,
            ["clay"] = 3
        },
        result = {
            id = "pottery_wheel",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- ============================================
    -- ÂGE DU BRONZE - MÉTALLURGIE BASIQUE
    -- ============================================
    
    ["furnace"] = {
        name = "Four",
        description = "Permet de fondre des métaux et cuire des briques.",
        ingredients = {
            ["stone"] = 20,
            ["clay"] = 5
        },
        result = {
            id = "furnace",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["bronze"] = {
        name = "Bronze",
        description = "Un alliage de cuivre et d'étain.",
        ingredients = {
            ["copper_ore"] = 2,
            ["tin_ore"] = 1
        },
        result = {
            id = "bronze",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "bronze",
        requiredStation = "furnace"
    },
    
    ["anvil"] = {
        name = "Enclume",
        description = "Permet de forger des outils en métal.",
        ingredients = {
            ["stone"] = 10,
            ["bronze"] = 5
        },
        result = {
            id = "anvil",
            quantity = 1
        },
        craftTime = 40,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    -- Outils en bronze
    ["bronze_axe"] = {
        name = "Hache en bronze",
        description = "Une hache plus efficace que celle en pierre.",
        ingredients = {
            ["bronze"] = 3,
            ["wood"] = 2
        },
        result = {
            id = "bronze_axe",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    ["bronze_pickaxe"] = {
        name = "Pioche en bronze",
        description = "Une pioche plus durable pour miner.",
        ingredients = {
            ["bronze"] = 3,
            ["wood"] = 2
        },
        result = {
            id = "bronze_pickaxe",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    ["bronze_hoe"] = {
        name = "Houe en bronze",
        description = "Pour cultiver la terre.",
        ingredients = {
            ["bronze"] = 2,
            ["wood"] = 3
        },
        result = {
            id = "bronze_hoe",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    ["bronze_hammer"] = {
        name = "Marteau en bronze",
        description = "Outil de construction plus résistant.",
        ingredients = {
            ["bronze"] = 3,
            ["wood"] = 2
        },
        result = {
            id = "bronze_hammer",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    -- Armes en bronze
    ["bronze_sword"] = {
        name = "Épée en bronze",
        description = "Une arme tranchante efficace.",
        ingredients = {
            ["bronze"] = 5,
            ["wood"] = 1
        },
        result = {
            id = "bronze_sword",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    ["bronze_spear"] = {
        name = "Lance en bronze",
        description = "Une lance plus efficace qu'en pierre.",
        ingredients = {
            ["bronze"] = 3,
            ["wood"] = 3
        },
        result = {
            id = "bronze_spear",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    ["bronze_dagger"] = {
        name = "Dague en bronze",
        description = "Arme légère et rapide.",
        ingredients = {
            ["bronze"] = 2,
            ["wood"] = 1,
            ["leather"] = 1
        },
        result = {
            id = "bronze_dagger",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    ["bronze_shield"] = {
        name = "Bouclier en bronze",
        description = "Protection efficace contre les attaques.",
        ingredients = {
            ["bronze"] = 3,
            ["wood"] = 4,
            ["leather"] = 2
        },
        result = {
            id = "bronze_shield",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "bronze",
        requiredStation = "anvil"
    },
    
    -- Construction avancée
    ["brick"] = {
        name = "Brique",
        description = "Un bloc de construction solide.",
        ingredients = {
            ["clay"] = 2
        },
        result = {
            id = "brick",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "bronze",
        requiredStation = "furnace"
    },
    
    ["stone_wall"] = {
        name = "Mur en pierre",
        description = "Plus solide qu'un mur en bois.",
        ingredients = {
            ["stone"] = 15
        },
        result = {
            id = "stone_wall",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["stone_floor"] = {
        name = "Sol en pierre",
        description = "Un sol solide et durable.",
        ingredients = {
            ["stone"] = 10
        },
        result = {
            id = "stone_floor",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["stone_foundation"] = {
        name = "Fondation en pierre",
        description = "Base très solide pour une construction.",
        ingredients = {
            ["stone"] = 20
        },
        result = {
            id = "stone_foundation",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["brick_wall"] = {
        name = "Mur en briques",
        description = "Un mur élégant et très résistant.",
        ingredients = {
            ["brick"] = 10
        },
        result = {
            id = "brick_wall",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["brick_floor"] = {
        name = "Sol en briques",
        description = "Un sol élégant et durable.",
        ingredients = {
            ["brick"] = 8
        },
        result = {
            id = "brick_floor",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    -- Nourriture avancée
    ["flour"] = {
        name = "Farine",
        description = "Moulue à partir de grains, nécessaire pour faire du pain.",
        ingredients = {
            ["grain"] = 3
        },
        result = {
            id = "flour",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "bronze",
        requiredStation = "grinding_stone"
    },
    
    ["bread"] = {
        name = "Pain",
        description = "Du pain fraîchement cuit.",
        ingredients = {
            ["flour"] = 2,
            ["water_container"] = 1
        },
        result = {
            id = "bread",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "bronze",
        requiredStation = "campfire"
    },
    
    ["meat_pie"] = {
        name = "Tourte à la viande",
        description = "Un repas copieux et nourrissant.",
        ingredients = {
            ["flour"] = 2,
            ["cooked_meat"] = 1,
            ["root_vegetable"] = 1
        },
        result = {
            id = "meat_pie",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "bronze",
        requiredStation = "campfire"
    },
    
    ["brewery"] = {
        name = "Brasserie",
        description = "Pour fabriquer des boissons fermentées.",
        ingredients = {
            ["wooden_plank"] = 10,
            ["clay_pot"] = 3,
            ["copper_ore"] = 2
        },
        result = {
            id = "brewery",
            quantity = 1
        },
        craftTime = 35,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["ale"] = {
        name = "Bière",
        description = "Boisson fermentée à base de grains.",
        ingredients = {
            ["grain"] = 5,
            ["water_container"] = 2
        },
        result = {
            id = "ale",
            quantity = 2
        },
        craftTime = 60,
        techLevel = "bronze",
        requiredStation = "brewery"
    },
    
    -- ============================================
    -- ÂGE DU FER - MÉTALLURGIE AVANCÉE
    -- ============================================
    
    ["iron"] = {
        name = "Fer",
        description = "Du minerai de fer raffiné.",
        ingredients = {
            ["iron_ore"] = 2
        },
        result = {
            id = "iron",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "iron",
        requiredStation = "furnace"
    },
    
    ["forge"] = {
        name = "Forge",
        description = "Une version améliorée du four, permettant de travailler les métaux plus rapidement.",
        ingredients = {
            ["brick"] = 15,
            ["iron"] = 5,
            ["stone"] = 10
        },
        result = {
            id = "forge",
            quantity = 1
        },
        craftTime = 45,
        techLevel = "iron",
        requiredStation = nil
    },
    
    ["steel"] = {
        name = "Acier",
        description = "Un métal plus résistant que le fer.",
        ingredients = {
            ["iron"] = 2,
            ["charcoal"] = 1
        },
        result = {
            id = "steel",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "iron",
        requiredStation = "forge"
    },
    
    -- Outils en fer
    ["iron_axe"] = {
        name = "Hache en fer",
        description = "Une hache robuste et efficace.",
        ingredients = {
            ["iron"] = 3,
            ["wood"] = 2
        },
        result = {
            id = "iron_axe",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_pickaxe"] = {
        name = "Pioche en fer",
        description = "Une pioche puissante pour miner tous types de minerais.",
        ingredients = {
            ["iron"] = 3,
            ["wood"] = 2
        },
        result = {
            id = "iron_pickaxe",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_hoe"] = {
        name = "Houe en fer",
        description = "Une version améliorée de la houe en bronze.",
        ingredients = {
            ["iron"] = 2,
            ["wood"] = 3
        },
        result = {
            id = "iron_hoe",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_hammer"] = {
        name = "Marteau en fer",
        description = "Outil de construction de qualité supérieure.",
        ingredients = {
            ["iron"] = 3,
            ["wood"] = 2
        },
        result = {
            id = "iron_hammer",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    -- Armes en fer
    ["iron_sword"] = {
        name = "Épée en fer",
        description = "Une arme redoutable, plus puissante que l'épée en bronze.",
        ingredients = {
            ["iron"] = 5,
            ["wood"] = 1,
            ["leather"] = 1
        },
        result = {
            id = "iron_sword",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_spear"] = {
        name = "Lance en fer",
        description = "Une lance puissante et durable.",
        ingredients = {
            ["iron"] = 3,
            ["wood"] = 3
        },
        result = {
            id = "iron_spear",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_mace"] = {
        name = "Masse en fer",
        description = "Arme contondante dévastatrice.",
        ingredients = {
            ["iron"] = 4,
            ["wood"] = 2
        },
        result = {
            id = "iron_mace",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["crossbow"] = {
        name = "Arbalète",
        description = "Arme à distance puissante et précise.",
        ingredients = {
            ["iron"] = 4,
            ["wood"] = 6,
            ["rope"] = 3
        },
        result = {
            id = "crossbow",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "iron",
        requiredStation = "workbench"
    },
    
    ["crossbow_bolt"] = {
        name = "Carreau d'arbalète",
        description = "Munition pour l'arbalète.",
        ingredients = {
            ["iron"] = 1,
            ["wood"] = 2
        },
        result = {
            id = "crossbow_bolt",
            quantity = 6
        },
        craftTime = 8,
        techLevel = "iron",
        requiredStation = "workbench"
    },
    
    -- Armures en fer
    ["iron_helmet"] = {
        name = "Casque en fer",
        description = "Protège efficacement la tête.",
        ingredients = {
            ["iron"] = 3,
            ["leather"] = 1
        },
        result = {
            id = "iron_helmet",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_chestplate"] = {
        name = "Plastron en fer",
        description = "Protège efficacement le torse.",
        ingredients = {
            ["iron"] = 5,
            ["leather"] = 2
        },
        result = {
            id = "iron_chestplate",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_leggings"] = {
        name = "Jambières en fer",
        description = "Protège efficacement les jambes.",
        ingredients = {
            ["iron"] = 4,
            ["leather"] = 2
        },
        result = {
            id = "iron_leggings",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_boots"] = {
        name = "Bottes en fer",
        description = "Protège efficacement les pieds.",
        ingredients = {
            ["iron"] = 3,
            ["leather"] = 1
        },
        result = {
            id = "iron_boots",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_shield"] = {
        name = "Bouclier en fer",
        description = "Offre une excellente protection.",
        ingredients = {
            ["iron"] = 4,
            ["wood"] = 3,
            ["leather"] = 2
        },
        result = {
            id = "iron_shield",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    -- Mobilier avancé
    ["cooking_pot"] = {
        name = "Marmite",
        description = "Pour des recettes de cuisine plus élaborées.",
        ingredients = {
            ["iron"] = 3
        },
        result = {
            id = "cooking_pot",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["fish_stew"] = {
        name = "Ragoût de poisson",
        description = "Un repas complet et nourrissant.",
        ingredients = {
            ["fish"] = 2,
            ["root_vegetable"] = 1,
            ["water_container"] = 1
        },
        result = {
            id = "fish_stew",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "iron",
        requiredStation = "cooking_pot"
    },
    
    ["vegetable_soup"] = {
        name = "Soupe de légumes",
        description = "Bon pour la santé et le moral.",
        ingredients = {
            ["root_vegetable"] = 2,
            ["berries"] = 1,
            ["water_container"] = 1
        },
        result = {
            id = "vegetable_soup",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "iron",
        requiredStation = "cooking_pot"
    },
    
    ["meat_stew"] = {
        name = "Ragoût de viande",
        description = "Un repas très nourrissant.",
        ingredients = {
            ["cooked_meat"] = 2,
            ["root_vegetable"] = 2,
            ["water_container"] = 1
        },
        result = {
            id = "meat_stew",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "iron",
        requiredStation = "cooking_pot"
    },
    
    ["iron_chest"] = {
        name = "Coffre en fer",
        description = "Coffre sécurisé pour objets précieux.",
        ingredients = {
            ["iron"] = 6,
            ["wooden_plank"] = 4
        },
        result = {
            id = "iron_chest",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["iron_door"] = {
        name = "Porte en fer",
        description = "Porte renforcée très sécurisée.",
        ingredients = {
            ["iron"] = 8
        },
        result = {
            id = "iron_door",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    -- Infrastructure
    ["well"] = {
        name = "Puits",
        description = "Source d'eau permanente.",
        ingredients = {
            ["stone"] = 30,
            ["wood"] = 10,
            ["rope"] = 5
        },
        result = {
            id = "well",
            quantity = 1
        },
        craftTime = 60,
        techLevel = "iron",
        requiredStation = nil
    },
    
    ["wooden_bridge"] = {
        name = "Pont en bois",
        description = "Pour traverser des obstacles.",
        ingredients = {
            ["wooden_plank"] = 20,
            ["rope"] = 6
        },
        result = {
            id = "wooden_bridge",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "iron",
        requiredStation = nil
    },
    
    ["windmill"] = {
        name = "Moulin à vent",
        description = "Pour moudre automatiquement les grains.",
        ingredients = {
            ["wood"] = 40,
            ["stone"] = 20,
            ["iron"] = 10
        },
        result = {
            id = "windmill",
            quantity = 1
        },
        craftTime = 120,
        techLevel = "iron",
        requiredStation = nil
    },
    
    ["water_wheel"] = {
        name = "Roue à eau",
        description = "Source d'énergie mécanique.",
        ingredients = {
            ["wood"] = 30,
            ["iron"] = 8,
            ["stone"] = 15
        },
        result = {
            id = "water_wheel",
            quantity = 1
        },
        craftTime = 90,
        techLevel = "iron",
        requiredStation = nil
    },
    
    -- ============================================
    -- ÂGE DE L'OR - LUXE ET PRESTIGE
    -- ============================================
    
    ["gold"] = {
        name = "Or",
        description = "Un métal précieux et malléable.",
        ingredients = {
            ["gold_ore"] = 2
        },
        result = {
            id = "gold",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "gold",
        requiredStation = "furnace"
    },
    
    ["gem"] = {
        name = "Gemme",
        description = "Une pierre précieuse polie.",
        ingredients = {
            ["raw_gem"] = 1
        },
        result = {
            id = "gem",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "gold",
        requiredStation = "grinding_stone"
    },
    
    -- Bijoux
    ["gold_ring"] = {
        name = "Anneau en or",
        description = "Un bijou simple mais élégant.",
        ingredients = {
            ["gold"] = 1
        },
        result = {
            id = "gold_ring",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    ["gold_necklace"] = {
        name = "Collier en or",
        description = "Un bijou précieux et prestigieux.",
        ingredients = {
            ["gold"] = 2
        },
        result = {
            id = "gold_necklace",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    ["gold_crown"] = {
        name = "Couronne en or",
        description = "Symbole de pouvoir et d'autorité.",
        ingredients = {
            ["gold"] = 5,
            ["gem"] = 1
        },
        result = {
            id = "gold_crown",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    ["gem_ring"] = {
        name = "Anneau serti de gemme",
        description = "Un bijou de grande valeur.",
        ingredients = {
            ["gold"] = 2,
            ["gem"] = 1
        },
        result = {
            id = "gem_ring",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    ["gem_necklace"] = {
        name = "Collier serti de gemme",
        description = "Un bijou somptueux.",
        ingredients = {
            ["gold"] = 3,
            ["gem"] = 2
        },
        result = {
            id = "gem_necklace",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    -- Objets de luxe
    ["golden_chalice"] = {
        name = "Calice en or",
        description = "Un récipient pour boisson de grande valeur.",
        ingredients = {
            ["gold"] = 3
        },
        result = {
            id = "golden_chalice",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    ["golden_plate"] = {
        name = "Assiette en or",
        description = "Vaisselle de luxe pour les banquets.",
        ingredients = {
            ["gold"] = 2
        },
        result = {
            id = "golden_plate",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "gold",
        requiredStation = "anvil"
    },
    
    ["throne"] = {
        name = "Trône",
        description = "Siège majestueux pour un chef ou roi.",
        ingredients = {
            ["wooden_plank"] = 15,
            ["gold"] = 5,
            ["leather"] = 8,
            ["gem"] = 2
        },
        result = {
            id = "throne",
            quantity = 1
        },
        craftTime = 60,
        techLevel = "gold",
        requiredStation = "workbench"
    },
    
    ["gold_statue"] = {
        name = "Statue en or",
        description = "Monument de prestige pour votre civilisation.",
        ingredients = {
            ["gold"] = 10,
            ["stone"] = 20
        },
        result = {
            id = "gold_statue",
            quantity = 1
        },
        craftTime = 90,
        techLevel = "gold",
        requiredStation = nil
    },
    
    -- ============================================
    -- AGRICULTURE ET ÉLEVAGE
    -- ============================================
    
    ["scarecrow"] = {
        name = "Épouvantail",
        description = "Protège les cultures des oiseaux.",
        ingredients = {
            ["wood"] = 4,
            ["fiber_clothes"] = 1,
            ["fiber"] = 8
        },
        result = {
            id = "scarecrow",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["compost_bin"] = {
        name = "Composteur",
        description = "Produit de l'engrais naturel.",
        ingredients = {
            ["wooden_plank"] = 8
        },
        result = {
            id = "compost_bin",
            quantity = 1
        },
        craftTime = 10,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["fertilizer"] = {
        name = "Engrais",
        description = "Améliore la croissance des cultures.",
        ingredients = {
            ["plant_fiber"] = 5,
            ["bone"] = 2
        },
        result = {
            id = "fertilizer",
            quantity = 3
        },
        craftTime = 15,
        techLevel = "bronze",
        requiredStation = "compost_bin"
    },
    
    ["irrigation_channel"] = {
        name = "Canal d'irrigation",
        description = "Pour arroser automatiquement les cultures.",
        ingredients = {
            ["stone"] = 20,
            ["wood"] = 10
        },
        result = {
            id = "irrigation_channel",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["animal_pen"] = {
        name = "Enclos pour animaux",
        description = "Pour élever des animaux domestiques.",
        ingredients = {
            ["wooden_fence"] = 8,
            ["wooden_gate"] = 1
        },
        result = {
            id = "animal_pen",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["feeding_trough"] = {
        name = "Auge",
        description = "Pour nourrir les animaux d'élevage.",
        ingredients = {
            ["wooden_plank"] = 6
        },
        result = {
            id = "feeding_trough",
            quantity = 1
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["beehive"] = {
        name = "Ruche",
        description = "Pour élever des abeilles et produire du miel.",
        ingredients = {
            ["wooden_plank"] = 8,
            ["fiber"] = 6
        },
        result = {
            id = "beehive",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    -- ============================================
    -- OBJETS TRIBAUX ET CULTURELS
    -- ============================================
    
    ["wooden_totem"] = {
        name = "Totem en bois",
        description = "Symbole spirituel de la tribu.",
        ingredients = {
            ["wood"] = 10,
            ["stone"] = 5
        },
        result = {
            id = "wooden_totem",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["tribal_drum"] = {
        name = "Tambour tribal",
        description = "Instrument pour les cérémonies.",
        ingredients = {
            ["wood"] = 6,
            ["animal_hide"] = 2,
            ["rope"] = 3
        },
        result = {
            id = "tribal_drum",
            quantity = 1
        },
        craftTime = 15,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["tribal_banner"] = {
        name = "Bannière tribale",
        description = "Étendard représentant votre tribu.",
        ingredients = {
            ["wood"] = 4,
            ["fiber_clothes"] = 1,
            ["rope"] = 2
        },
        result = {
            id = "tribal_banner",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["war_paint"] = {
        name = "Peinture de guerre",
        description = "Pour intimider les ennemis.",
        ingredients = {
            ["berries"] = 5,
            ["clay"] = 2,
            ["charcoal"] = 1
        },
        result = {
            id = "war_paint",
            quantity = 3
        },
        craftTime = 8,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["ceremonial_mask"] = {
        name = "Masque cérémoniel",
        description = "Pour les rituels tribaux.",
        ingredients = {
            ["wood"] = 3,
            ["feather"] = 5,
            ["leather"] = 2
        },
        result = {
            id = "ceremonial_mask",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "stone",
        requiredStation = nil
    },
    
    ["tribal_altar"] = {
        name = "Autel tribal",
        description = "Lieu sacré pour les cérémonies.",
        ingredients = {
            ["stone"] = 25,
            ["wood"] = 10,
            ["bone"] = 5
        },
        result = {
            id = "tribal_altar",
            quantity = 1
        },
        craftTime = 45,
        techLevel = "stone",
        requiredStation = nil
    },
    
    -- ============================================
    -- DÉCORATION ET CONFORT
    -- ============================================
    
    ["carpet"] = {
        name = "Tapis",
        description = "Décoration confortable pour le sol.",
        ingredients = {
            ["fiber"] = 20,
            ["fur"] = 3
        },
        result = {
            id = "carpet",
            quantity = 1
        },
        craftTime = 18,
        techLevel = "bronze",
        requiredStation = "loom"
    },
    
    ["tapestry"] = {
        name = "Tapisserie",
        description = "Décoration murale élégante.",
        ingredients = {
            ["fiber"] = 15,
            ["wood"] = 2
        },
        result = {
            id = "tapestry",
            quantity = 1
        },
        craftTime = 25,
        techLevel = "bronze",
        requiredStation = "loom"
    },
    
    ["painting"] = {
        name = "Peinture",
        description = "Œuvre d'art pour décorer les murs.",
        ingredients = {
            ["wooden_plank"] = 4,
            ["fiber"] = 2,
            ["berries"] = 3,
            ["charcoal"] = 2
        },
        result = {
            id = "painting",
            quantity = 1
        },
        craftTime = 30,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["stone_statue"] = {
        name = "Statue en pierre",
        description = "Monument décoratif imposant.",
        ingredients = {
            ["stone"] = 30
        },
        result = {
            id = "stone_statue",
            quantity = 1
        },
        craftTime = 60,
        techLevel = "bronze",
        requiredStation = nil
    },
    
    ["fountain"] = {
        name = "Fontaine",
        description = "Élément décoratif avec de l'eau.",
        ingredients = {
            ["stone"] = 25,
            ["clay_pot"] = 2,
            ["iron"] = 3
        },
        result = {
            id = "fountain",
            quantity = 1
        },
        craftTime = 45,
        techLevel = "iron",
        requiredStation = nil
    },
    
    ["lantern"] = {
        name = "Lanterne",
        description = "Source de lumière portable améliorée.",
        ingredients = {
            ["iron"] = 2,
            ["glass"] = 1
        },
        result = {
            id = "lantern",
            quantity = 1
        },
        craftTime = 12,
        techLevel = "iron",
        requiredStation = "anvil"
    },
    
    ["chandelier"] = {
        name = "Lustre",
        description = "Éclairage élégant pour les grandes salles.",
        ingredients = {
            ["iron"] = 6,
            ["rope"] = 3
        },
        result = {
            id = "chandelier",
            quantity = 1
        },
        craftTime = 20,
        techLevel = "iron",
        requiredStation = "anvil"
    }
}

return CraftingRecipes
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">GameSettings</string>
            <string name="Source">-- src/shared/constants/GameSettings.lua
local GameSettings = {
    -- Paramètres de temps
    Time = {
        yearInSeconds = 3600,       -- 1 heure réelle = 1 an dans le jeu
        dayNightCycle = 720,        -- 12 minutes pour un cycle jour/nuit complet
        dayLength = 420,            -- 7 minutes de jour
        nightLength = 180,          -- 3 minutes de nuit
        dawnDuskLength = 60,        -- 1 minute pour l'aube/crépuscule
    },

    -- Paramètres des joueurs
    Player = {
        startingAge = 16,           -- Âge de départ
        maxNaturalAge = 60,         -- Âge maximum naturel
        deathChanceStart = 50,      -- Âge où la mort naturelle devient possible
        initialInventorySize = 20,  -- Taille d'inventaire initiale
        spawnWithItems = {          -- Objets de départ
            ["stone"] = 1
        },
        walkSpeed = 16,             -- Vitesse de marche
        runSpeed = 24,              -- Vitesse de course
        interactionDistance = 5,    -- Distance d'interaction avec les objets
    },

    -- Paramètres de survie
    Survival = {
        -- Faim
        maxHunger = 100,            -- Valeur maximale de faim
        hungerDecayRate = 0.01,     -- Diminution par seconde (réévalué)
        criticalHungerThreshold = 15, -- Seuil critique
        hungerDamageAmount = 1,     -- Dégâts par tick quand affamé

        -- Soif
        maxThirst = 100,            -- Valeur maximale de soif
        thirstDecayRate = 0.02,     -- Diminution par seconde (réévalué)
        criticalThirstThreshold = 10, -- Seuil critique
        thirstDamageAmount = 2,     -- Dégâts par tick quand assoiffé

        -- Énergie
        maxEnergy = 100,            -- Valeur maximale d'énergie
        energyDecayRate = 0.005,    -- Diminution par seconde (éveil) (réévalué)
        energyRecoveryRate = 0.1,   -- Récupération par seconde (sommeil)
        criticalEnergyThreshold = 10, -- Seuil critique

        -- Température
        idealTemperature = 50,      -- Température idéale (0-100)
        criticalColdThreshold = 20, -- Seuil de froid critique
        criticalHeatThreshold = 80, -- Seuil de chaleur critique
        temperatureDamageAmount = 1, -- Dégâts par tick en température critique
    },

    -- Ressources
    Resources = {
        respawnTime = {
            ["wood"] = 300,         -- 5 minutes
            ["stone"] = 600,        -- 10 minutes
            ["fiber"] = 180,        -- 3 minutes
            ["berry_bush"] = 240,   -- 4 minutes
            ["clay"] = 480,         -- 8 minutes
            ["copper_ore"] = 900,   -- 15 minutes
            ["tin_ore"] = 900,      -- 15 minutes
            ["iron_ore"] = 1200,    -- 20 minutes
            ["gold_ore"] = 1800,    -- 30 minutes
        },

        harvestAmount = {
            ["wood"] = {min = 1, max = 3},
            ["stone"] = {min = 1, max = 2},
            ["fiber"] = {min = 1, max = 4},
            ["berries"] = {min = 2, max = 5},
            ["clay"] = {min = 1, max = 3},
            ["copper_ore"] = {min = 1, max = 2},
            ["tin_ore"] = {min = 1, max = 2},
            ["iron_ore"] = {min = 1, max = 2},
            ["gold_ore"] = {min = 1, max = 1},
        },

        toolRequirement = {
            ["wood"] = "axe",
            ["stone"] = "pickaxe",
            ["fiber"] = nil,         -- Pas d'outil requis
            ["berries"] = nil,       -- Pas d'outil requis
            ["clay"] = nil,          -- Pas d'outil requis
            ["copper_ore"] = "pickaxe",
            ["tin_ore"] = "pickaxe",
            ["iron_ore"] = "pickaxe",
            ["gold_ore"] = "pickaxe",
        },

        techLevelRequirement = {
            ["wood"] = "stone",
            ["stone"] = "stone",
            ["fiber"] = "stone",
            ["berries"] = "stone",
            ["clay"] = "stone",
            ["copper_ore"] = "stone",
            ["tin_ore"] = "stone",
            ["iron_ore"] = "bronze",
            ["gold_ore"] = "iron",
        },
    },

    -- Construction
    Building = {
        maxStructuresPerPlayer = 10,  -- Nombre max de structures par joueur
        maxDistanceFromTribe = 50,    -- Distance max de construction depuis le centre de la tribu
        structureDurability = {
            ["wooden"] = 100,         -- Points de durabilité pour structures en bois
            ["stone"] = 200,          -- Points de durabilité pour structures en pierre
            ["brick"] = 300,          -- Points de durabilité pour structures en brique
        },
    },

    -- Tribus
    Tribe = {
        maxMembers = 20,              -- Nombre max de membres par tribu
        creationCost = {              -- Coût pour créer une tribu
            ["wooden_totem"] = 1,
        },
    },
}

return GameSettings</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="28">
          <Properties>
            <string name="Name">ItemTypes</string>
            <string name="Source"><![CDATA[-- src/shared/constants/ItemTypes.lua

local ItemTypes = {
    -- Matériaux de base
    ["stone"] = {
        name = "Pierre",
        description = "Une pierre ordinaire, utile pour des outils basiques.",
        category = "material",
        stackable = true,
        maxStack = 64,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Rocks.Stone",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.stone_icon"
    },
    
    ["wood"] = {
        name = "Bois",
        description = "Un morceau de bois, utilisé pour l'artisanat.",
        category = "material",
        stackable = true,
        maxStack = 64,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Trees.Wood",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.wood_icon"
    },
    
    ["fiber"] = {
        name = "Fibre",
        description = "Des fibres végétales, utilisées pour tisser des cordes.",
        category = "material",
        stackable = true,
        maxStack = 64,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Plants.Fiber",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.fiber_icon"
    },
    
    ["clay"] = {
        name = "Argile",
        description = "De l'argile utilisée pour fabriquer de la poterie.",
        category = "material",
        stackable = true,
        maxStack = 64,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Rocks.Clay",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.clay_icon"
    },
    
    -- Minerais
    ["copper_ore"] = {
        name = "Minerai de cuivre",
        description = "Peut être fondu pour obtenir du bronze.",
        category = "material",
        stackable = true,
        maxStack = 32,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Ores.CopperOre",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.copper_ore_icon"
    },
    
    ["tin_ore"] = {
        name = "Minerai d'étain",
        description = "Mélangé au cuivre pour faire du bronze.",
        category = "material",
        stackable = true,
        maxStack = 32,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Ores.TinOre",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.tin_ore_icon"
    },
    
    ["iron_ore"] = {
        name = "Minerai de fer",
        description = "Peut être fondu pour obtenir du fer.",
        category = "material",
        stackable = true,
        maxStack = 32,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Ores.IronOre",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.iron_ore_icon"
    },
    
    ["gold_ore"] = {
        name = "Minerai d'or",
        description = "Un métal précieux et malléable.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Ores.GoldOre",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.gold_ore_icon"
    },
    
    -- Métaux raffinés
    ["bronze"] = {
        name = "Bronze",
        description = "Un alliage de cuivre et d'étain.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Metals.Bronze",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.bronze_icon"
    },
    
    ["iron"] = {
        name = "Fer",
        description = "Un métal solide pour fabriquer des outils et armes.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Metals.Iron",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.iron_icon"
    },
    
    ["gold"] = {
        name = "Or",
        description = "Un métal précieux utilisé pour la décoration et les bijoux.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Metals.Gold",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.gold_icon"
    },
    
    -- Outils de l'âge de pierre
    ["stone_axe"] = {
        name = "Hache en pierre",
        description = "Un outil primitif pour couper du bois.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "axe",
        durability = 100,
        damage = 5,
        gatherMultiplier = {
            ["wood"] = 2 -- Récolte 2x plus de bois
        },
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.StoneAxe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.stone_axe_icon"
    },
    
    ["stone_pickaxe"] = {
        name = "Pioche en pierre",
        description = "Un outil pour miner des minerais.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "pickaxe",
        durability = 100,
        damage = 4,
        gatherMultiplier = {
            ["stone"] = 2,
            ["copper_ore"] = 1.5,
            ["tin_ore"] = 1.5
        },
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.StonePickaxe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.stone_pickaxe_icon"
    },
    
    ["stone_spear"] = {
        name = "Lance en pierre",
        description = "Une arme primitive pour chasser.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 80,
        damage = 8,
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.StoneSpear",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.stone_spear_icon"
    },
    
    -- Outils en bronze
    ["bronze_axe"] = {
        name = "Hache en bronze",
        description = "Une hache efficace en bronze.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "axe",
        durability = 200,
        damage = 8,
        gatherMultiplier = {
            ["wood"] = 3
        },
        model = "ReplicatedStorage.Assets.Models.Tools.BronzeTools.BronzeAxe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.bronze_axe_icon"
    },
    
    ["bronze_pickaxe"] = {
        name = "Pioche en bronze",
        description = "Une pioche solide pour miner.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "pickaxe",
        durability = 200,
        damage = 7,
        gatherMultiplier = {
            ["stone"] = 3,
            ["copper_ore"] = 2,
            ["tin_ore"] = 2,
            ["iron_ore"] = 1.5
        },
        model = "ReplicatedStorage.Assets.Models.Tools.BronzeTools.BronzePickaxe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.bronze_pickaxe_icon"
    },
    
    -- Outils en fer
    ["iron_axe"] = {
        name = "Hache en fer",
        description = "Une hache puissante pour couper du bois rapidement.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "axe",
        durability = 400,
        damage = 12,
        gatherMultiplier = {
            ["wood"] = 4
        },
        model = "ReplicatedStorage.Assets.Models.Tools.IronTools.IronAxe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.iron_axe_icon"
    },
    
    ["iron_pickaxe"] = {
        name = "Pioche en fer",
        description = "Une pioche robuste qui peut miner tous les types de minerais.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "pickaxe",
        durability = 400,
        damage = 10,
        gatherMultiplier = {
            ["stone"] = 4,
            ["copper_ore"] = 3,
            ["tin_ore"] = 3,
            ["iron_ore"] = 2,
            ["gold_ore"] = 2
        },
        model = "ReplicatedStorage.Assets.Models.Tools.IronTools.IronPickaxe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.iron_pickaxe_icon"
    },
    
    -- Vêtements
    ["fiber_clothes"] = {
        name = "Vêtements en fibre",
        description = "Des vêtements primitifs faits de fibres végétales.",
        category = "clothing",
        stackable = false,
        equipable = true,
        equipSlot = "body",
        temperatureModifier = 5, -- +5 résistance au froid
        model = "ReplicatedStorage.Assets.Models.Clothing.FiberClothes",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.fiber_clothes_icon"
    },
    
    ["leather_clothes"] = {
        name = "Vêtements en cuir",
        description = "Des vêtements robustes en cuir d'animal.",
        category = "clothing",
        stackable = false,
        equipable = true,
        equipSlot = "body",
        temperatureModifier = 10, -- +10 résistance au froid
        model = "ReplicatedStorage.Assets.Models.Clothing.LeatherClothes",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.leather_clothes_icon"
    },
    
    ["fur_coat"] = {
        name = "Manteau de fourrure",
        description = "Un manteau chaud pour les environnements froids.",
        category = "clothing",
        stackable = false,
        equipable = true,
        equipSlot = "body",
        temperatureModifier = 20, -- +20 résistance au froid
        model = "ReplicatedStorage.Assets.Models.Clothing.FurCoat",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.fur_coat_icon"
    },
    
    -- Nourriture
    ["berries"] = {
        name = "Baies",
        description = "Des baies sauvages comestibles.",
        category = "food",
        stackable = true,
        maxStack = 16,
        foodValue = 10, -- Restaure 10 points de faim
        spoilTime = 1800, -- 30 minutes avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Berries",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.berries_icon"
    },
    
    ["cooked_meat"] = {
        name = "Viande cuite",
        description = "De la viande cuite sur un feu.",
        category = "food",
        stackable = true,
        maxStack = 8,
        foodValue = 30,
        spoilTime = 3600, -- 1 heure avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.CookedMeat",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.cooked_meat_icon"
    },
    
    ["bread"] = {
        name = "Pain",
        description = "Du pain cuit à partir de graines récoltées.",
        category = "food",
        stackable = true,
        maxStack = 8,
        foodValue = 25,
        spoilTime = 7200, -- 2 heures avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Bread",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.bread_icon"
    },
    
    -- Boissons
    ["water_container"] = {
        name = "Eau",
        description = "Un conteneur rempli d'eau potable.",
        category = "drink",
        stackable = false,
        drinkValue = 40, -- Restaure 40 points de soif
        model = "ReplicatedStorage.Assets.Models.Food.WaterContainer",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.water_container_icon"
    },
    
    -- Matériaux de construction
    ["wooden_plank"] = {
        name = "Planche en bois",
        description = "Un matériau de base pour la construction.",
        category = "building",
        stackable = true,
        maxStack = 64,
        model = "ReplicatedStorage.Assets.Models.Buildings.Materials.WoodenPlank",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.wooden_plank_icon"
    },
    
    ["brick"] = {
        name = "Brique",
        description = "Une brique solide pour des constructions durables.",
        category = "building",
        stackable = true,
        maxStack = 64,
        model = "ReplicatedStorage.Assets.Models.Buildings.Materials.Brick",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.brick_icon"
    },
    
    -- Mobilier
    ["wooden_bed"] = {
        name = "Lit en bois",
        description = "Un lit simple pour dormir.",
        category = "furniture",
        stackable = false,
        sleepQuality = 1, -- Taux de récupération d'énergie
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.WoodenBed",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.wooden_bed_icon"
    },
    
    ["wooden_table"] = {
        name = "Table en bois",
        description = "Une table simple.",
        category = "furniture",
        stackable = false,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.WoodenTable",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.wooden_table_icon"
    },
    
    ["wooden_chair"] = {
        name = "Chaise en bois",
        description = "Une chaise simple.",
        category = "furniture",
        stackable = false,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.WoodenChair",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.wooden_chair_icon"
    },
    
    ["campfire"] = {
        name = "Feu de camp",
        description = "Fournit chaleur et lumière, permet de cuire des aliments.",
        category = "furniture",
        stackable = false,
        heatSource = true,
        heatRadius = 10,
        heatIntensity = 15,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.Campfire",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.campfire_icon"
    },
    
    -- NOUVEAUX OBJETS AJOUTÉS
    
    -- Matériaux supplémentaires
    ["bone"] = {
        name = "Os",
        description = "Des os qui peuvent être utilisés pour fabriquer des outils.",
        category = "material",
        stackable = true,
        maxStack = 32,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Bones.Bone",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.bone_icon"
    },
    
    ["feather"] = {
        name = "Plume",
        description = "Des plumes d'oiseaux utiles pour fabriquer des flèches.",
        category = "material",
        stackable = true,
        maxStack = 64,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Feathers.Feather",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.feather_icon"
    },
    
    ["flint"] = {
        name = "Silex",
        description = "Une pierre dure utilisée pour faire du feu ou des outils tranchants.",
        category = "material",
        stackable = true,
        maxStack = 32,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Rocks.Flint",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.flint_icon"
    },
    
    ["animal_hide"] = {
        name = "Peau d'animal",
        description = "Une peau brute qui peut être tannée pour faire du cuir.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Skins.AnimalHide",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.animal_hide_icon"
    },
    
    ["fur"] = {
        name = "Fourrure",
        description = "Une fourrure douce et chaude provenant d'animaux.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Skins.Fur",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.fur_icon"
    },
    
    ["leather"] = {
        name = "Cuir",
        description = "Du cuir tanné à partir de peaux d'animaux.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Skins.Leather",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.leather_icon"
    },
    
    ["rope"] = {
        name = "Corde",
        description = "Une corde solide fabriquée à partir de fibres.",
        category = "material",
        stackable = true,
        maxStack = 16,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Materials.Rope",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.rope_icon"
    },
    
    ["charcoal"] = {
        name = "Charbon de bois",
        description = "Utilisé comme combustible ou pour la purification.",
        category = "material",
        stackable = true,
        maxStack = 32,
        equipable = false,
        model = "ReplicatedStorage.Assets.Models.Resources.Materials.Charcoal",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.charcoal_icon"
    },
    
    -- Armes et outils supplémentaires
    ["wooden_bow"] = {
        name = "Arc en bois",
        description = "Une arme de chasse à distance.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "bow",
        durability = 120,
        damage = 6,
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.WoodenBow",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.wooden_bow_icon",
        ammo = "arrow"
    },
    
    ["arrow"] = {
        name = "Flèche",
        description = "Munition pour l'arc.",
        category = "ammo",
        stackable = true,
        maxStack = 24,
        equipable = false,
        damage = 4,
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.Arrow",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.arrow_icon"
    },
    
    ["fishing_rod"] = {
        name = "Canne à pêche",
        description = "Pour attraper des poissons dans l'eau.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "fishing",
        durability = 100,
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.FishingRod",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.fishing_rod_icon"
    },
    
    ["stone_hammer"] = {
        name = "Marteau en pierre",
        description = "Un outil utile pour la construction.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "hammer",
        durability = 120,
        damage = 5,
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.StoneHammer",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.stone_hammer_icon"
    },
    
    ["bone_knife"] = {
        name = "Couteau en os",
        description = "Un outil tranchant pour couper et tailler.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "knife",
        durability = 80,
        damage = 4,
        model = "ReplicatedStorage.Assets.Models.Tools.StoneTools.BoneKnife",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.bone_knife_icon"
    },
    
    ["bronze_sword"] = {
        name = "Épée en bronze",
        description = "Une arme redoutable en bronze.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 200,
        damage = 12,
        model = "ReplicatedStorage.Assets.Models.Tools.BronzeTools.BronzeSword",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.bronze_sword_icon"
    },
    
    ["iron_sword"] = {
        name = "Épée en fer",
        description = "Une arme puissante et tranchante.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 400,
        damage = 16,
        model = "ReplicatedStorage.Assets.Models.Tools.IronTools.IronSword",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.iron_sword_icon"
    },
    
    ["bronze_hoe"] = {
        name = "Houe en bronze",
        description = "Un outil pour cultiver la terre.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "hoe",
        durability = 150,
        model = "ReplicatedStorage.Assets.Models.Tools.BronzeTools.BronzeHoe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.bronze_hoe_icon"
    },
    
    ["iron_hoe"] = {
        name = "Houe en fer",
        description = "Un outil agricole plus durable.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "hoe",
        durability = 300,
        model = "ReplicatedStorage.Assets.Models.Tools.IronTools.IronHoe",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.iron_hoe_icon"
    },
    
    -- Nourriture et boissons supplémentaires
    ["raw_meat"] = {
        name = "Viande crue",
        description = "De la viande d'animal non cuite, à préparer avant de manger.",
        category = "food",
        stackable = true,
        maxStack = 8,
        foodValue = 15,
        spoilTime = 1200, -- 20 minutes avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.RawMeat",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.raw_meat_icon"
    },
    
    ["fish"] = {
        name = "Poisson",
        description = "Un poisson frais, à préparer avant de manger.",
        category = "food",
        stackable = true,
        maxStack = 8,
        foodValue = 12,
        spoilTime = 1500, -- 25 minutes avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Fish",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.fish_icon"
    },
    
    ["cooked_fish"] = {
        name = "Poisson cuit",
        description = "Un poisson cuit, prêt à être consommé.",
        category = "food",
        stackable = true,
        maxStack = 8,
        foodValue = 25,
        spoilTime = 3000, -- 50 minutes avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.CookedFish",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.cooked_fish_icon"
    },
    
    ["apple"] = {
        name = "Pomme",
        description = "Un fruit frais et juteux.",
        category = "food",
        stackable = true,
        maxStack = 16,
        foodValue = 8,
        drinkValue = 5,
        spoilTime = 2400, -- 40 minutes avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Apple",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.apple_icon"
    },
    
    ["mushroom"] = {
        name = "Champignon",
        description = "Un champignon comestible des forêts.",
        category = "food",
        stackable = true,
        maxStack = 16,
        foodValue = 6,
        spoilTime = 3600, -- 1 heure avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Mushroom",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.mushroom_icon"
    },
    
    ["grain"] = {
        name = "Grain",
        description = "Des céréales qui peuvent être transformées en farine.",
        category = "food",
        stackable = true,
        maxStack = 32,
        foodValue = 3,
        spoilTime = 14400, -- 4 heures avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Grain",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.grain_icon"
    },
    
    ["flour"] = {
        name = "Farine",
        description = "De la farine moulue, utilisée pour faire du pain.",
        category = "food",
        stackable = true,
        maxStack = 16,
        spoilTime = 28800, -- 8 heures avant de pourrir
        model = "ReplicatedStorage.Assets.Models.Food.Flour",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.flour_icon"
    },
    
    ["berry_juice"] = {
        name = "Jus de baies",
        description = "Une boisson rafraîchissante à base de baies.",
        category = "drink",
        stackable = false,
        drinkValue = 30,
        model = "ReplicatedStorage.Assets.Models.Food.BerryJuice",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.berry_juice_icon"
    },
    
    -- Vêtements et accessoires supplémentaires
    ["leather_backpack"] = {
        name = "Sac à dos en cuir",
        description = "Augmente la capacité d'inventaire.",
        category = "accessory",
        stackable = false,
        equipable = true,
        equipSlot = "back",
        inventoryBonus = 10, -- Ajoute 10 emplacements d'inventaire
        model = "ReplicatedStorage.Assets.Models.Clothing.LeatherBackpack",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.leather_backpack_icon"
    },
    
    ["leather_boots"] = {
        name = "Bottes en cuir",
        description = "Protège les pieds et augmente légèrement la vitesse.",
        category = "clothing",
        stackable = false,
        equipable = true,
        equipSlot = "feet",
        speedBonus = 0.1, -- +10% de vitesse de déplacement
        model = "ReplicatedStorage.Assets.Models.Clothing.LeatherBoots",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.leather_boots_icon"
    },
    
    ["fur_hat"] = {
        name = "Chapeau en fourrure",
        description = "Protège la tête du froid.",
        category = "clothing",
        stackable = false,
        equipable = true,
        equipSlot = "head",
        temperatureModifier = 8, -- +8 résistance au froid
        model = "ReplicatedStorage.Assets.Models.Clothing.FurHat",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.fur_hat_icon"
    },
    
    -- Bijoux et objets précieux
    ["gold_necklace"] = {
        name = "Collier en or",
        description = "Un bijou précieux fait d'or pur.",
        category = "jewelry",
        stackable = false,
        equipable = true,
        equipSlot = "neck",
        model = "ReplicatedStorage.Assets.Models.Jewelry.GoldNecklace",
        icon = "ReplicatedStorage.Assets.UI.Icons.Jewelry.gold_necklace_icon"
    },
    
    ["gold_crown"] = {
        name = "Couronne en or",
        description = "Un symbole d'autorité et de richesse.",
        category = "jewelry",
        stackable = false,
        equipable = true,
        equipSlot = "head",
        model = "ReplicatedStorage.Assets.Models.Jewelry.GoldCrown",
        icon = "ReplicatedStorage.Assets.UI.Icons.Jewelry.gold_crown_icon"
    },
    
    -- Structures et éléments de construction
    ["wooden_wall"] = {
        name = "Mur en bois",
        description = "Un mur simple pour délimiter un espace.",
        category = "building",
        stackable = true,
        maxStack = 10,
        placeable = true,
        durability = 100,
        model = "ReplicatedStorage.Assets.Models.Buildings.Structures.WoodenWall",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.wooden_wall_icon"
    },
    
    ["wooden_floor"] = {
        name = "Sol en bois",
        description = "Un plancher en bois pour votre construction.",
        category = "building",
        stackable = true,
        maxStack = 10,
        placeable = true,
        durability = 80,
        model = "ReplicatedStorage.Assets.Models.Buildings.Structures.WoodenFloor",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.wooden_floor_icon"
    },
    
    ["wooden_door"] = {
        name = "Porte en bois",
        description = "Une porte pour votre construction.",
        category = "building",
        stackable = true,
        maxStack = 5,
        placeable = true,
        isDoor = true,
        durability = 90,
        model = "ReplicatedStorage.Assets.Models.Buildings.Structures.WoodenDoor",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.wooden_door_icon"
    },
    
    ["stone_wall"] = {
        name = "Mur en pierre",
        description = "Un mur solide en pierre.",
        category = "building",
        stackable = true,
        maxStack = 10,
        placeable = true,
        durability = 200,
        model = "ReplicatedStorage.Assets.Models.Buildings.Structures.StoneWall",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.stone_wall_icon"
    },
    
    ["brick_wall"] = {
        name = "Mur en briques",
        description = "Un mur élégant et solide en briques.",
        category = "building",
        stackable = true,
        maxStack = 10,
        placeable = true,
        durability = 250,
        model = "ReplicatedStorage.Assets.Models.Buildings.Structures.BrickWall",
        icon = "ReplicatedStorage.Assets.UI.Icons.Building.brick_wall_icon"
    },
    
    -- Conteneurs et stockage
    ["wooden_chest"] = {
        name = "Coffre en bois",
        description = "Pour stocker vos objets.",
        category = "furniture",
        stackable = false,
        placeable = true,
        storage = 20, -- Nombre d'emplacements
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.WoodenChest",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.wooden_chest_icon"
    },
    
    ["clay_pot"] = {
        name = "Pot en argile",
        description = "Pour stocker des liquides ou des aliments.",
        category = "furniture",
        stackable = true,
        maxStack = 5,
        placeable = true,
        storage = 5,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.ClayPot",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.clay_pot_icon"
    },
    
    -- Équipement d'artisanat avancé
    ["anvil"] = {
        name = "Enclume",
        description = "Nécessaire pour forger des outils et armes en métal.",
        category = "station",
        stackable = false,
        placeable = true,
        forgingStation = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.Anvil",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.anvil_icon"
    },
    
    ["loom"] = {
        name = "Métier à tisser",
        description = "Pour créer des vêtements et textiles.",
        category = "station",
        stackable = false,
        placeable = true,
        textileStation = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.Loom",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.loom_icon"
    },
    
    ["tanning_rack"] = {
        name = "Cadre de tannage",
        description = "Pour transformer des peaux en cuir.",
        category = "station",
        stackable = false,
        placeable = true,
        tanningStation = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.TanningRack",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.tanning_rack_icon"
    },
    
    ["pottery_wheel"] = {
        name = "Tour de potier",
        description = "Pour créer des objets en argile.",
        category = "station",
        stackable = false,
        placeable = true,
        potteryStation = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.PotteryWheel",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.pottery_wheel_icon"
    },
    
    -- Graines et agriculture
    ["wheat_seeds"] = {
        name = "Graines de blé",
        description = "À planter pour cultiver du blé.",
        category = "seed",
        stackable = true,
        maxStack = 32,
        plantable = true,
        growsInto = "wheat_crop",
        growthTime = 1200, -- 20 minutes
        model = "ReplicatedStorage.Assets.Models.Food.WheatSeeds",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.wheat_seeds_icon"
    },
    
    ["carrot_seeds"] = {
        name = "Graines de carotte",
        description = "À planter pour cultiver des carottes.",
        category = "seed",
        stackable = true,
        maxStack = 32,
        plantable = true,
        growsInto = "carrot_crop",
        growthTime = 900, -- 15 minutes
        model = "ReplicatedStorage.Assets.Models.Food.CarrotSeeds",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.carrot_seeds_icon"
    },
    
    -- Récoltes agricoles
    ["wheat"] = {
        name = "Blé",
        description = "Peut être moulu pour obtenir de la farine.",
        category = "crop",
        stackable = true,
        maxStack = 32,
        model = "ReplicatedStorage.Assets.Models.Food.Wheat",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.wheat_icon"
    },
    
    ["carrot"] = {
        name = "Carotte",
        description = "Un légume nourrissant.",
        category = "food",
        stackable = true,
        maxStack = 16,
        foodValue = 15,
        spoilTime = 2400, -- 40 minutes
        model = "ReplicatedStorage.Assets.Models.Food.Carrot",
        icon = "ReplicatedStorage.Assets.UI.Icons.Food.carrot_icon"
    },
    
    -- Récipients et outils de transport
    ["water_pouch"] = {
        name = "Outre d'eau",
        description = "Pour transporter de l'eau.",
        category = "container",
        stackable = false,
        equipable = true,
        equipSlot = "back",
        capacity = 1,
        model = "ReplicatedStorage.Assets.Models.Tools.WaterPouch",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.water_pouch_icon"
    },
    
    ["basket"] = {
        name = "Panier",
        description = "Pour transporter des objets.",
        category = "container",
        stackable = false,
        equipable = true,
        equipSlot = "back",
        capacity = 5,
        model = "ReplicatedStorage.Assets.Models.Tools.Basket",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.basket_icon"
    },
    
    -- Armes avancées
    ["iron_shield"] = {
        name = "Bouclier en fer",
        description = "Offre une excellente protection contre les attaques.",
        category = "weapon",
        stackable = false,
        equipable = true,
        equipSlot = "offhand",
        durability = 300,
        defenseBonus = 40,
        model = "ReplicatedStorage.Assets.Models.Tools.IronTools.IronShield",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.iron_shield_icon"
    },
    
    ["bronze_mace"] = {
        name = "Masse en bronze",
        description = "Une arme contondante efficace.",
        category = "weapon",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 150,
        damage = 10,
        model = "ReplicatedStorage.Assets.Models.Tools.BronzeTools.BronzeMace",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.bronze_mace_icon"
    },
    
    -- Équipement d'armure avancé
    ["iron_helmet"] = {
        name = "Casque en fer",
        description = "Protège efficacement la tête.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "head",
        durability = 200,
        defenseBonus = 15,
        temperatureModifier = 5,
        model = "ReplicatedStorage.Assets.Models.Clothing.IronHelmet",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.iron_helmet_icon"
    },
    
    ["iron_chestplate"] = {
        name = "Plastron en fer",
        description = "Protège efficacement le torse.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "body",
        durability = 300,
        defenseBonus = 25,
        temperatureModifier = 8,
        model = "ReplicatedStorage.Assets.Models.Clothing.IronChestplate",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.iron_chestplate_icon"
    },
    
    ["iron_leggings"] = {
        name = "Jambières en fer",
        description = "Protège efficacement les jambes.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "legs",
        durability = 250,
        defenseBonus = 20,
        temperatureModifier = 6,
        model = "ReplicatedStorage.Assets.Models.Clothing.IronLeggings",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.iron_leggings_icon"
    },
    
    ["iron_boots"] = {
        name = "Bottes en fer",
        description = "Protège efficacement les pieds.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "feet",
        durability = 200,
        defenseBonus = 10,
        temperatureModifier = 4,
        model = "ReplicatedStorage.Assets.Models.Clothing.IronBoots",
        icon = "ReplicatedStorage.Assets.UI.Icons.Clothing.iron_boots_icon"
    },
    
    -- Éléments de décoration et ambiance
    ["torch"] = {
        name = "Torche",
        description = "Fournit de la lumière dans l'obscurité.",
        category = "tool",
        stackable = true,
        maxStack = 10,
        equipable = true,
        equipSlot = "offhand",
        placeable = true,
        lightSource = true,
        lightRadius = 15,
        burnTime = 1800, -- 30 minutes
        model = "ReplicatedStorage.Assets.Models.Tools.Torch",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tools.torch_icon"
    },
    
    ["wooden_sign"] = {
        name = "Panneau en bois",
        description = "Pour écrire des messages.",
        category = "furniture",
        stackable = true,
        maxStack = 5,
        placeable = true,
        customizable = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Furniture.WoodenSign",
        icon = "ReplicatedStorage.Assets.UI.Icons.Furniture.wooden_sign_icon"
    },
    
    -- Ressources et matériaux spéciaux
    ["gem"] = {
        name = "Gemme",
        description = "Une pierre précieuse rare et brillante.",
        category = "material",
        stackable = true,
        maxStack = 10,
        model = "ReplicatedStorage.Assets.Models.Resources.Gems.Gem",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.gem_icon"
    },
    
    ["obsidian"] = {
        name = "Obsidienne",
        description = "Un matériau volcanique noir et très dur.",
        category = "material",
        stackable = true,
        maxStack = 16,
        model = "ReplicatedStorage.Assets.Models.Resources.Rocks.Obsidian",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.obsidian_icon"
    },
    
    -- Objets tribaux et de cérémonie
    ["wooden_totem"] = {
        name = "Totem en bois",
        description = "Un symbole spirituel et identitaire pour une tribu.",
        category = "tribal",
        stackable = false,
        placeable = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Tribal.WoodenTotem",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tribal.wooden_totem_icon"
    },
    
    ["tribal_drum"] = {
        name = "Tambour tribal",
        description = "Un instrument pour les cérémonies tribales.",
        category = "tribal",
        stackable = false,
        placeable = true,
        interactable = true,
        model = "ReplicatedStorage.Assets.Models.Buildings.Tribal.TribalDrum",
        icon = "ReplicatedStorage.Assets.UI.Icons.Tribal.tribal_drum_icon"
    },
    
    -- Ressources et matériaux de construction avancés
    ["cement"] = {
        name = "Ciment",
        description = "Un matériau de construction avancé.",
        category = "material",
        stackable = true,
        maxStack = 32,
        model = "ReplicatedStorage.Assets.Models.Resources.Materials.Cement",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.cement_icon"
    },
    
    ["concrete"] = {
        name = "Béton",
        description = "Un matériau de construction très solide.",
        category = "material",
        stackable = true,
        maxStack = 16,
        model = "ReplicatedStorage.Assets.Models.Resources.Materials.Concrete",
        icon = "ReplicatedStorage.Assets.UI.Icons.Materials.concrete_icon"
    }
}

return ItemTypes
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="29">
        <Properties>
          <string name="Name">modules</string>
        </Properties>
        <Item class="ModuleScript" referent="30">
          <Properties>
            <string name="Name">Maid</string>
            <string name="Source"><![CDATA[--[[
	Maid Module
	
	Un module d'utilitaire pour gérer le nettoyage des objets, événements et connections.
	Utilisé pour éviter les fuites de mémoire et assurer un nettoyage propre quand des objets ne sont plus nécessaires.
	
	API:
		Maid.new()
			Crée une nouvelle instance de Maid.
		
		Maid:GiveTask(task)
			Donne une tâche à Maid qui sera nettoyée plus tard.
			Les tâches peuvent être:
				- Une fonction à appeler
				- Une RBXScriptConnection à déconnecter
				- Une instance à détruire
				- Une table avec une méthode Destroy ou destroy
				- Une autre instance de Maid
				- Une table de tâches qui seront toutes nettoyées
		
		Maid:DoCleaning()
			Nettoie toutes les tâches assignées au Maid.
		
		Maid:Destroy()
			Nettoie toutes les tâches et déréférence le Maid pour la collecte des déchets.
--]]

local Maid = {}
Maid.__index = Maid

--- Crée une nouvelle instance Maid
function Maid.new()
	return setmetatable({
		_tasks = {}
	}, Maid)
end

--- Détermine si une valeur peut être nettoyée
-- @param value La valeur à vérifier
-- @return booléen, indiquant si la valeur peut être nettoyée
function Maid:CanClean(value)
	return typeof(value) == "function"
		or typeof(value) == "RBXScriptConnection"
		or typeof(value) == "Instance"
		or typeof(value) == "table" and (value.Destroy or value.destroy or value.Disconnect or value.disconnect)
		or typeof(value) == "table" and getmetatable(value) == Maid
end

--- Ajoute une tâche au Maid
-- @param task La tâche à ajouter. Voir les types supportés dans la documentation
-- @return La tâche ajoutée
function Maid:GiveTask(task)
	if not task then
		return task
	end
	
	if typeof(task) == "table" and not (task.Destroy or task.destroy or task.Disconnect or task.disconnect or getmetatable(task) == Maid) then
		-- Si c'est une table sans méthode de destruction, supposons que c'est une liste de tâches
		for _, subtask in pairs(task) do
			if self:CanClean(subtask) then
				self:GiveTask(subtask)
			end
		end
		return task
	end
	
	-- Vérifier si la tâche peut être nettoyée, sinon retourner telle quelle
	if not self:CanClean(task) then
		return task
	end
	
	-- Ajouter la tâche à la table des tâches pour le nettoyage futur
	local taskId = #self._tasks + 1
	self._tasks[taskId] = task
	
	return task
end

--- Nettoie une tâche spécifique
-- @param task La tâche à nettoyer
function Maid:_CleanTask(task)
	if typeof(task) == "function" then
		task()
	elseif typeof(task) == "RBXScriptConnection" then
		task:Disconnect()
	elseif typeof(task) == "Instance" then
		task:Destroy()
	elseif typeof(task) == "table" then
		if getmetatable(task) == Maid then
			-- Si c'est un autre Maid
			task:Destroy()
		elseif task.Destroy then
			task:Destroy()
		elseif task.destroy then
			task:destroy()
		elseif task.Disconnect then
			task:Disconnect()
		elseif task.disconnect then
			task:disconnect()
		end
	end
end

--- Nettoie toutes les tâches assignées au Maid
function Maid:DoCleaning()
	local tasks = self._tasks
	
	-- Réinitialiser la table des tâches pour éviter des problèmes pendant le nettoyage
	self._tasks = {}
	
	-- Nettoyer chaque tâche
	for _, task in pairs(tasks) do
		self:_CleanTask(task)
	end
end

--- Détruit le Maid et nettoie toutes les tâches
function Maid:Destroy()
	self:DoCleaning()
	setmetatable(self, nil)
end

return Maid
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="31">
          <Properties>
            <string name="Name">Promise</string>
            <string name="Source"><![CDATA[--[[
	Promise Module
	
	Une implémentation légère du pattern Promise pour Lua/Roblox.
	Permet d'écrire du code asynchrone de manière plus propre et lisible.
	
	API:
		Promise.new(executor)
			Crée une nouvelle promesse avec un exécuteur qui reçoit resolve et reject.
		
		Promise.resolve(value)
			Crée une promesse résolue avec la valeur donnée.
		
		Promise.reject(reason)
			Crée une promesse rejetée avec la raison donnée.
		
		Promise.all(promises)
			Attend que toutes les promesses soient résolues ou qu'une soit rejetée.
		
		Promise.race(promises)
			Attend que n'importe quelle promesse soit résolue ou rejetée.
		
		Promise.delay(seconds)
			Crée une promesse qui se résout après un délai.
			
		promise:andThen(successHandler, failureHandler)
			Ajoute des gestionnaires de continuation à la promesse.
		
		promise:catch(failureHandler)
			Ajoute un gestionnaire d'erreur à la promesse.
		
		promise:finally(finallyHandler)
			Ajoute un gestionnaire qui est appelé indépendamment du résultat.
		
		promise:await()
			Attend de manière synchrone la résolution de la promesse (utiliser avec précaution).
--]]

local Promise = {}
Promise.__index = Promise

-- États de promesse
local STATUS = {
	PENDING = "pending",
	FULFILLED = "fulfilled",
	REJECTED = "rejected"
}

--- Crée une nouvelle promesse
-- @param executor Fonction qui prend (resolve, reject) comme arguments
-- @return Une nouvelle promesse
function Promise.new(executor)
	local self = setmetatable({
		_status = STATUS.PENDING,
		_value = nil,
		_reason = nil,
		_thenQueue = {},
		_finallyQueue = {}
	}, Promise)
	
	-- Fonctions pour résoudre ou rejeter la promesse
	local resolve = function(value)
		self:_resolve(value)
	end
	
	local reject = function(reason)
		self:_reject(reason)
	end
	
	-- Exécuter l'exécuteur en sécurité
	local success, err = pcall(function()
		executor(resolve, reject)
	end)
	
	-- Si l'exécuteur a généré une erreur, rejeter la promesse
	if not success then
		reject(err)
	end
	
	return self
end

--- Résout la promesse avec une valeur
-- @param value La valeur de résolution
function Promise:_resolve(value)
	if self._status ~= STATUS.PENDING then
		return
	end
	
	-- Gérer le cas où la valeur est une autre promesse
	if typeof(value) == "table" and getmetatable(value) == Promise then
		value:andThen(
			function(resolvedValue)
				self:_resolve(resolvedValue)
			end,
			function(rejectedReason)
				self:_reject(rejectedReason)
			end
		)
		return
	end
	
	self._status = STATUS.FULFILLED
	self._value = value
	self:_executeHandlers()
end

--- Rejette la promesse avec une raison
-- @param reason La raison du rejet
function Promise:_reject(reason)
	if self._status ~= STATUS.PENDING then
		return
	end
	
	self._status = STATUS.REJECTED
	self._reason = reason
	self:_executeHandlers()
end

--- Exécute les gestionnaires en attente
function Promise:_executeHandlers()
	-- Planifier l'exécution pour le prochain cycle d'événements
	spawn(function()
		if self._status == STATUS.FULFILLED then
			-- Gestionnaires then
			for _, handler in ipairs(self._thenQueue) do
				if handler.success then
					local success, result = pcall(handler.success, self._value)
					if success then
						handler.promise:_resolve(result)
					else
						handler.promise:_reject(result)
					end
				else
					handler.promise:_resolve(self._value)
				end
			end
			
			-- Gestionnaires finally
			for _, handler in ipairs(self._finallyQueue) do
				if handler.func then
					local success, result = pcall(handler.func)
					if success then
						handler.promise:_resolve(self._value)
					else
						handler.promise:_reject(result)
					end
				else
					handler.promise:_resolve(self._value)
				end
			end
		elseif self._status == STATUS.REJECTED then
			-- Gestionnaires then (failure)
			local handled = false
			for _, handler in ipairs(self._thenQueue) do
				if handler.failure then
					handled = true
					local success, result = pcall(handler.failure, self._reason)
					if success then
						handler.promise:_resolve(result)
					else
						handler.promise:_reject(result)
					end
				else
					handler.promise:_reject(self._reason)
				end
			end
			
			-- Gestionnaires finally
			for _, handler in ipairs(self._finallyQueue) do
				if handler.func then
					local success, result = pcall(handler.func)
					if success then
						handler.promise:_reject(self._reason)
					else
						handler.promise:_reject(result)
					end
				else
					handler.promise:_reject(self._reason)
				end
			end
			
			-- Si aucun gestionnaire d'erreur, avertir dans la console
			if not handled and typeof(self._reason) == "string" then
				warn("Promesse rejetée non gérée: " .. self._reason)
			elseif not handled then
				warn("Promesse rejetée non gérée")
			end
		end
		
		-- Nettoyer les files d'attente
		self._thenQueue = {}
		self._finallyQueue = {}
	end)
end

--- Ajoute des gestionnaires de continuation à la promesse
-- @param successHandler Fonction à appeler si la promesse est résolue
-- @param failureHandler Fonction à appeler si la promesse est rejetée
-- @return Une nouvelle promesse
function Promise:andThen(successHandler, failureHandler)
	local newPromise = Promise.new(function() end)
	
	table.insert(self._thenQueue, {
		success = successHandler,
		failure = failureHandler,
		promise = newPromise
	})
	
	-- Si la promesse a déjà été résolue ou rejetée, exécuter les gestionnaires
	if self._status ~= STATUS.PENDING then
		self:_executeHandlers()
	end
	
	return newPromise
end

--- Ajoute un gestionnaire d'erreur à la promesse
-- @param failureHandler Fonction à appeler si la promesse est rejetée
-- @return Une nouvelle promesse
function Promise:catch(failureHandler)
	return self:andThen(nil, failureHandler)
end

--- Ajoute un gestionnaire qui est appelé indépendamment du résultat
-- @param finallyHandler Fonction à appeler quand la promesse est résolue ou rejetée
-- @return Une nouvelle promesse
function Promise:finally(finallyHandler)
	local newPromise = Promise.new(function() end)
	
	table.insert(self._finallyQueue, {
		func = finallyHandler,
		promise = newPromise
	})
	
	-- Si la promesse a déjà été résolue ou rejetée, exécuter les gestionnaires
	if self._status ~= STATUS.PENDING then
		self:_executeHandlers()
	end
	
	return newPromise
end

--- Crée une promesse résolue avec la valeur donnée
-- @param value La valeur de résolution
-- @return Une promesse résolue
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--- Crée une promesse rejetée avec la raison donnée
-- @param reason La raison du rejet
-- @return Une promesse rejetée
function Promise.reject(reason)
	return Promise.new(function(_, reject)
		reject(reason)
	end)
end

--- Attend que toutes les promesses soient résolues
-- @param promises Une table de promesses
-- @return Une promesse qui se résout avec un tableau des résultats
function Promise.all(promises)
	if #promises == 0 then
		return Promise.resolve({})
	end
	
	return Promise.new(function(resolve, reject)
		local results = {}
		local completedCount = 0
		local expectedCount = #promises
		
		for i, promise in ipairs(promises) do
			if typeof(promise) ~= "table" or getmetatable(promise) ~= Promise then
				-- Si l'élément n'est pas une promesse, le traiter comme une valeur résolue
				results[i] = promise
				completedCount = completedCount + 1
				if completedCount == expectedCount then
					resolve(results)
				end
			else
				promise:andThen(
					function(result)
						results[i] = result
						completedCount = completedCount + 1
						if completedCount == expectedCount then
							resolve(results)
						end
					end,
					function(reason)
						reject(reason)
					end
				)
			end
		end
	end)
end

--- Attend que n'importe quelle promesse soit résolue ou rejetée
-- @param promises Une table de promesses
-- @return Une promesse qui se résout avec le résultat de la première promesse résolue
function Promise.race(promises)
	return Promise.new(function(resolve, reject)
		for _, promise in ipairs(promises) do
			promise:andThen(resolve, reject)
		end
	end)
end

--- Crée une promesse qui se résout après un délai
-- @param seconds Délai en secondes
-- @return Une promesse qui se résout après le délai
function Promise.delay(seconds)
	return Promise.new(function(resolve)
		spawn(function()
			wait(seconds)
			resolve()
		end)
	end)
end

--- Attend de manière synchrone la résolution de la promesse
-- AVERTISSEMENT: Cette méthode bloque le thread actuel et ne doit être utilisée qu'avec précaution
-- @return Le résultat ou la raison, et un booléen indiquant si la promesse a été résolue ou rejetée
function Promise:await()
	if self._status == STATUS.FULFILLED then
		return self._value, true
	elseif self._status == STATUS.REJECTED then
		return self._reason, false
	end
	
	-- Créer un événement pour attendre la résolution
	local bindable = Instance.new("BindableEvent")
	local result, success
	
	self:andThen(
		function(value)
			result = value
			success = true
			bindable:Fire()
		end,
		function(reason)
			result = reason
			success = false
			bindable:Fire()
		end
	)
	
	bindable.Event:Wait()
	bindable:Destroy()
	
	return result, success
end

return Promise
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="32">
          <Properties>
            <string name="Name">Signal</string>
            <string name="Source"><![CDATA[--[[
	Signal Module
	
	Un système d'événements personnalisés pour Lua/Roblox.
	Permet de créer, connecter et déclencher des événements personnalisés.
	
	API:
		Signal.new()
			Crée un nouveau signal (événement).
		
		Signal:Connect(handler)
			Connecte une fonction au signal.
			Retourne une connexion qui peut être déconnectée.
		
		Signal:Once(handler)
			Connecte une fonction qui ne sera appelée qu'une seule fois.
			Retourne une connexion qui peut être déconnectée.
		
		Signal:Wait()
			Attend que le signal soit déclenché et retourne les arguments.
		
		Signal:Fire(...)
			Déclenche le signal avec les arguments fournis.
		
		Signal:DisconnectAll()
			Déconnecte toutes les connexions.
		
		Signal:Destroy()
			Nettoie et désactive le signal. Les connexions existantes seront invalidées.
		
		connection:Disconnect()
			Déconnecte une connexion spécifique.
--]]

local Signal = {}
Signal.__index = Signal

-- Classe pour les connexions
local Connection = {}
Connection.__index = Connection

--- Crée une nouvelle connexion
-- @param signal Le signal parent
-- @param handler La fonction à appeler
-- @return Une connexion
function Connection.new(signal, handler)
	return setmetatable({
		_signal = signal,
		_handler = handler,
		_connected = true,
        _once = false
	}, Connection)
end

--- Déconnecte la connexion
function Connection:Disconnect()
	if not self._connected then return end
	
	self._connected = false
	
	-- Trouver et supprimer cette connexion de la liste du signal
	for i, connection in ipairs(self._signal._connections) do
		if connection == self then
			table.remove(self._signal._connections, i)
			break
		end
	end
	
	-- Nettoyage des références
	self._signal = nil
	self._handler = nil
end

--- Alias pour Disconnect
function Connection:disconnect()
	return self:Disconnect()
end

--- Crée un nouveau signal
-- @return Nouvel objet Signal
function Signal.new()
	return setmetatable({
		_connections = {},
		_destroyed = false,
		_yieldingThreads = {}
	}, Signal)
end

--- Connecte une fonction au signal
-- @param handler Fonction à appeler quand le signal est déclenché
-- @return Une connexion
function Signal:Connect(handler)
	assert(typeof(handler) == "function", "Handler doit être une fonction")
	assert(not self._destroyed, "Signal a été détruit")
	
	local connection = Connection.new(self, handler)
	table.insert(self._connections, connection)
	
	return connection
end

--- Alias pour Connect
function Signal:connect(handler)
	return self:Connect(handler)
end

--- Connecte une fonction qui ne sera appelée qu'une seule fois
-- @param handler Fonction à appeler quand le signal est déclenché
-- @return Une connexion
function Signal:Once(handler)
	assert(typeof(handler) == "function", "Handler doit être une fonction")
	assert(not self._destroyed, "Signal a été détruit")
	
	-- Wrapper la fonction pour qu'elle se déconnecte après utilisation
	local connection
	connection = self:Connect(function(...)
		connection:Disconnect()
		handler(...)
	end)
    
    -- Marquer cette connexion comme once pour clarté
    connection._once = true
	
	return connection
end

--- Alias pour Once
function Signal:once(handler)
	return self:Once(handler)
end

--- Attend que le signal soit déclenché
-- @return Les arguments du signal
function Signal:Wait()
	assert(not self._destroyed, "Signal a été détruit")
	
	-- Créer un fil d'attente pour ce thread
	local thread = coroutine.running()
	table.insert(self._yieldingThreads, thread)
	
	-- Suspendre le thread jusqu'à ce que le signal soit déclenché
	local results = {coroutine.yield()}
	
	-- Confirmer que nous avons été réanimés par le signal
	-- Si le fil est dans la table, il a été réanimé par quelque chose d'autre
	for i, yieldingThread in ipairs(self._yieldingThreads) do
		if yieldingThread == thread then
			table.remove(self._yieldingThreads, i)
			break
		end
	end
	
	return unpack(results)
end

--- Alias pour Wait
function Signal:wait()
	return self:Wait()
end

--- Déclenche le signal avec les arguments fournis
-- @param ... Arguments à passer aux gestionnaires
function Signal:Fire(...)
	assert(not self._destroyed, "Signal a été détruit")
	
	-- Copier les connexions pour éviter les problèmes de modification pendant l'itération
	local connections = {}
	for _, connection in ipairs(self._connections) do
		table.insert(connections, connection)
	end
	
	-- Appeler chaque gestionnaire connecté
	for _, connection in ipairs(connections) do
		if connection._connected then
			spawn(function()
				connection._handler(...)
			end)
		end
	end
	
	-- Réanimer les threads en attente
	for _, thread in ipairs(self._yieldingThreads) do
		coroutine.resume(thread, ...)
	end
	self._yieldingThreads = {}
end

--- Alias pour Fire
function Signal:fire(...)
	return self:Fire(...)
end

--- Déclenche le signal immédiatement (pas dans un nouveau thread)
-- Attention: Les exceptions dans les gestionnaires ne sont pas attrapées
-- @param ... Arguments à passer aux gestionnaires
function Signal:FireSync(...)
	assert(not self._destroyed, "Signal a été détruit")
	
	-- Copier les connexions pour éviter les problèmes de modification pendant l'itération
	local connections = {}
	for _, connection in ipairs(self._connections) do
		table.insert(connections, connection)
	end
	
	-- Appeler chaque gestionnaire connecté
	for _, connection in ipairs(connections) do
		if connection._connected then
			connection._handler(...)
		end
	end
	
	-- Réanimer les threads en attente
	for _, thread in ipairs(self._yieldingThreads) do
		coroutine.resume(thread, ...)
	end
	self._yieldingThreads = {}
end

--- Alias pour FireSync
function Signal:fireSync(...)
	return self:FireSync(...)
end

--- Déconnecte toutes les connexions
function Signal:DisconnectAll()
	for _, connection in ipairs(self._connections) do
		connection._connected = false
		connection._signal = nil
		connection._handler = nil
	end
	
	self._connections = {}
	
	-- Réanimer les threads en attente avec aucune valeur
	for _, thread in ipairs(self._yieldingThreads) do
		coroutine.resume(thread)
	end
	self._yieldingThreads = {}
end

--- Détruit le signal
function Signal:Destroy()
	if self._destroyed then return end
	
	self:DisconnectAll()
	self._destroyed = true
end

--- Alias utilitaire pour compatibilité avec Maid
function Signal:destroy()
	return self:Destroy()
end

return Signal
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="33">
        <Properties>
          <string name="Name">types</string>
        </Properties>
        <Item class="ModuleScript" referent="34">
          <Properties>
            <string name="Name">ItemData</string>
            <string name="Source"><![CDATA[--[[
    ItemData.lua
    
    Module définissant tous les types d'objets et leurs propriétés dans le jeu The Beginning.
    Ce module centralise les informations sur les objets pour une consistance à travers le jeu.
    
    Structure:
    - Propriétés par défaut pour tous les objets
    - Catégories d'objets
    - Rareté des objets
    - Fonctions utilitaires pour accéder aux données
    - Définition complète de tous les objets du jeu
]]

local ItemData = {}

-- Constantes globales
ItemData.MAX_STACK_SIZE = 64
ItemData.MAX_DURABILITY = 1000

-- Structure de base pour tous les types d'items
-- Ces valeurs sont les valeurs par défaut si non spécifiées
ItemData.DefaultProperties = {
    stackable = false,       -- Si l'objet peut être empilé
    maxStack = 1,            -- Quantité max par pile si stackable
    equipable = false,       -- Si l'objet peut être équipé
    equipSlot = nil,         -- Emplacement d'équipement ("tool", "head", "body", etc.)
    durability = nil,        -- Points de durabilité (nil = indestructible)
    consumable = false,      -- Si l'objet peut être consommé
    placeable = false,       -- Si l'objet peut être placé dans le monde
    weight = 1,              -- Poids en unités d'inventaire
    rarity = "common",       -- Rareté de l'objet
    value = 1,               -- Valeur de base pour commerce/vente
    techLevel = "stone",     -- Niveau technologique minimal requis
    model = "",              -- Chemin vers le modèle 3D
    icon = "",               -- Chemin vers l'icône 2D
    animations = {},         -- Animations associées (utilisation, équipement, etc.)
    sounds = {}              -- Sons associés (utilisation, équipement, etc.)
}

-- Catégories d'objets (pour filtrage et organisation)
ItemData.Categories = {
    MATERIAL = "material",       -- Matières premières
    TOOL = "tool",               -- Outils
    WEAPON = "weapon",           -- Armes
    ARMOR = "armor",             -- Équipement de protection
    CLOTHING = "clothing",       -- Vêtements
    FOOD = "food",               -- Nourriture
    DRINK = "drink",             -- Boissons
    BUILDING = "building",       -- Éléments de construction
    FURNITURE = "furniture",     -- Mobilier
    CONTAINER = "container",     -- Conteneurs
    STATION = "station",         -- Stations d'artisanat
    SEED = "seed",               -- Graines
    RESOURCE = "resource",       -- Ressources naturelles
    JEWELRY = "jewelry",         -- Bijoux et objets précieux
    MEDICINE = "medicine",       -- Remèdes et médicaments
    TRIBAL = "tribal"            -- Objets tribaux et cérémoniels
}

-- Niveaux de rareté
ItemData.Rarity = {
    COMMON = {
        id = "common",
        name = "Commun",
        color = Color3.fromRGB(255, 255, 255),
        value_multiplier = 1
    },
    UNCOMMON = {
        id = "uncommon",
        name = "Peu commun",
        color = Color3.fromRGB(100, 255, 100),
        value_multiplier = 2
    },
    RARE = {
        id = "rare",
        name = "Rare",
        color = Color3.fromRGB(100, 100, 255),
        value_multiplier = 5
    },
    EPIC = {
        id = "epic",
        name = "Épique",
        color = Color3.fromRGB(200, 100, 255),
        value_multiplier = 10
    },
    LEGENDARY = {
        id = "legendary",
        name = "Légendaire",
        color = Color3.fromRGB(255, 200, 0),
        value_multiplier = 25
    },
    ARTIFACT = {
        id = "artifact",
        name = "Artéfact",
        color = Color3.fromRGB(255, 100, 100),
        value_multiplier = 50
    }
}

-- Niveaux technologiques
ItemData.TechLevels = {
    STONE = {
        id = "stone",
        name = "Âge de pierre",
        order = 1
    },
    BRONZE = {
        id = "bronze",
        name = "Âge du bronze",
        order = 2
    },
    IRON = {
        id = "iron",
        name = "Âge du fer",
        order = 3
    },
    GOLD = {
        id = "gold",
        name = "Âge d'or",
        order = 4
    }
}

-- Cache pour les données d'objets calculées
local calculatedItemDataCache = {}

-- Fonction pour obtenir les données d'un item par son ID
function ItemData:GetItemData(itemId)
    -- Vérifier si les données calculées sont déjà en cache
    if calculatedItemDataCache[itemId] then
        return calculatedItemDataCache[itemId]
    end
    
    local itemData = self.Items[itemId]
    
    if not itemData then
        warn("ItemData: Item non trouvé - " .. tostring(itemId))
        return nil
    end
    
    -- Créer une copie profonde pour éviter de modifier l'original
    local resultData = {}
    for key, value in pairs(itemData) do
        if type(value) == "table" then
            resultData[key] = table.clone(value)
        else
            resultData[key] = value
        end
    end
    
    -- Appliquer les propriétés par défaut si non spécifiées
    for prop, defaultValue in pairs(self.DefaultProperties) do
        if resultData[prop] == nil then
            resultData[prop] = defaultValue
        end
    end
    
    -- Ajouter l'ID de l'objet aux données
    resultData.id = itemId
    
    -- Mettre en cache pour les futurs accès
    calculatedItemDataCache[itemId] = resultData
    
    return resultData
end

-- Fonction pour obtenir tous les items d'une catégorie
function ItemData:GetItemsByCategory(category)
    local result = {}
    
    for itemId, itemData in pairs(self.Items) do
        if itemData.category == category then
            result[itemId] = self:GetItemData(itemId)
        end
    end
    
    return result
end

-- Fonction pour vérifier si un item est de type spécifique
function ItemData:IsItemOfType(itemId, typeCheck)
    local itemData = self:GetItemData(itemId)
    if not itemData then return false end
    
    return itemData.category == typeCheck
end

-- Fonction pour obtenir tous les items d'un certain niveau technologique
function ItemData:GetItemsByTechLevel(techLevel)
    local result = {}
    
    for itemId, itemData in pairs(self.Items) do
        if itemData.techLevel == techLevel then
            result[itemId] = self:GetItemData(itemId)
        end
    end
    
    return result
end

-- Fonction pour obtenir la couleur de rareté d'un objet
function ItemData:GetRarityColor(itemId)
    local itemData = self:GetItemData(itemId)
    if not itemData then return Color3.fromRGB(255, 255, 255) end
    
    local rarityInfo = self.Rarity[string.upper(itemData.rarity)] or self.Rarity.COMMON
    return rarityInfo.color
end

-- Fonction pour obtenir la valeur marchande d'un objet
function ItemData:GetItemValue(itemId, quality)
    local itemData = self:GetItemData(itemId)
    if not itemData then return 1 end
    
    local baseValue = itemData.value or 1
    local rarityMultiplier = 1
    
    if itemData.rarity then
        local rarityInfo = self.Rarity[string.upper(itemData.rarity)] or self.Rarity.COMMON
        rarityMultiplier = rarityInfo.value_multiplier
    end
    
    -- Facteur de qualité (optionnel, pour les objets avec différentes qualités)
    quality = quality or 1
    
    return math.floor(baseValue * rarityMultiplier * quality)
end

-- Fonction pour calculer la durabilité réelle en tenant compte du matériau
function ItemData:CalculateMaxDurability(itemId)
    local itemData = self:GetItemData(itemId)
    if not itemData or not itemData.durability then return nil end
    
    local baseDurability = itemData.durability
    local materialMultiplier = 1
    
    -- Modificateurs selon le niveau technologique
    if itemData.techLevel == "bronze" then
        materialMultiplier = 2
    elseif itemData.techLevel == "iron" then
        materialMultiplier = 3
    elseif itemData.techLevel == "gold" then
        materialMultiplier = 1.5  -- L'or est plus précieux mais moins durable
    end
    
    return math.floor(baseDurability * materialMultiplier)
end

-- Fonction pour vérifier si un objet peut être utilisé à un niveau technologique donné
function ItemData:CanUseAtTechLevel(itemId, playerTechLevel)
    local itemData = self:GetItemData(itemId)
    if not itemData then return false end
    
    local techLevelOrder = {
        stone = 1,
        bronze = 2,
        iron = 3,
        gold = 4
    }
    
    local itemTechLevel = itemData.techLevel or "stone"
    local playerLevel = techLevelOrder[playerTechLevel] or 1
    local requiredLevel = techLevelOrder[itemTechLevel] or 1
    
    return playerLevel >= requiredLevel
end

-- Fonction pour nettoyer le cache (utile après des modifications de données)
function ItemData:ClearCache()
    calculatedItemDataCache = {}
end

-- Définition complète de tous les objets du jeu
ItemData.Items = {
    -- ============================
    -- MATÉRIAUX DE BASE
    -- ============================
    
    ["stone"] = {
        name = "Pierre",
        description = "Une pierre ordinaire, utile pour des outils basiques.",
        category = "material",
        stackable = true,
        maxStack = 64,
        icon = "rbxassetid://12345600",
        model = "rbxassetid://12345650",
        weight = 2
    },
    
    ["wood"] = {
        name = "Bois",
        description = "Un morceau de bois, utilisé pour l'artisanat.",
        category = "material",
        stackable = true,
        maxStack = 64,
        icon = "rbxassetid://12345601",
        model = "rbxassetid://12345651",
        weight = 1
    },
    
    ["fiber"] = {
        name = "Fibre",
        description = "Des fibres végétales, utilisées pour tisser des cordes.",
        category = "material",
        stackable = true,
        maxStack = 64,
        icon = "rbxassetid://12345602",
        model = "rbxassetid://12345652",
        weight = 0.5
    },
    
    ["clay"] = {
        name = "Argile",
        description = "De l'argile utilisée pour fabriquer de la poterie.",
        category = "material",
        stackable = true,
        maxStack = 64,
        icon = "rbxassetid://12345603",
        model = "rbxassetid://12345653",
        weight = 1.5
    },
    
    ["bone"] = {
        name = "Os",
        description = "Des os qui peuvent être utilisés pour fabriquer des outils.",
        category = "material",
        stackable = true,
        maxStack = 32,
        icon = "rbxassetid://12345604",
        model = "rbxassetid://12345654",
        weight = 0.8
    },
    
    ["flint"] = {
        name = "Silex",
        description = "Une pierre dure utilisée pour faire du feu ou des outils tranchants.",
        category = "material",
        stackable = true,
        maxStack = 32,
        icon = "rbxassetid://12345605",
        model = "rbxassetid://12345655",
        weight = 0.5
    },
    
    ["leather"] = {
        name = "Cuir",
        description = "Du cuir tanné à partir de peaux d'animaux.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345606",
        model = "rbxassetid://12345656",
        weight = 0.7,
        value = 5
    },
    
    ["animal_hide"] = {
        name = "Peau d'animal",
        description = "Une peau brute qui peut être tannée pour faire du cuir.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345607",
        model = "rbxassetid://12345657",
        weight = 1,
        value = 3
    },
    
    ["fur"] = {
        name = "Fourrure",
        description = "Une fourrure douce et chaude provenant d'animaux.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345608",
        model = "rbxassetid://12345658",
        weight = 0.8,
        value = 6
    },
    
    ["rope"] = {
        name = "Corde",
        description = "Une corde solide fabriquée à partir de fibres.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345609",
        model = "rbxassetid://12345659",
        weight = 0.6,
        value = 3
    },
    
    ["charcoal"] = {
        name = "Charbon de bois",
        description = "Utilisé comme combustible ou pour la purification.",
        category = "material",
        stackable = true,
        maxStack = 32,
        icon = "rbxassetid://12345610",
        model = "rbxassetid://12345660",
        weight = 0.5,
        value = 2
    },
    
    -- ============================
    -- MINERAIS
    -- ============================
    
    ["copper_ore"] = {
        name = "Minerai de cuivre",
        description = "Peut être fondu pour obtenir du bronze avec de l'étain.",
        category = "material",
        stackable = true,
        maxStack = 32,
        icon = "rbxassetid://12345611",
        model = "rbxassetid://12345661",
        weight = 3,
        value = 5,
        techLevel = "stone"
    },
    
    ["tin_ore"] = {
        name = "Minerai d'étain",
        description = "Mélangé au cuivre pour faire du bronze.",
        category = "material",
        stackable = true,
        maxStack = 32,
        icon = "rbxassetid://12345612",
        model = "rbxassetid://12345662",
        weight = 3,
        value = 5,
        techLevel = "stone"
    },
    
    ["iron_ore"] = {
        name = "Minerai de fer",
        description = "Peut être fondu pour obtenir du fer.",
        category = "material",
        stackable = true,
        maxStack = 32,
        icon = "rbxassetid://12345613",
        model = "rbxassetid://12345663",
        weight = 4,
        value = 8,
        techLevel = "bronze"
    },
    
    ["gold_ore"] = {
        name = "Minerai d'or",
        description = "Un métal précieux et malléable.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345614",
        model = "rbxassetid://12345664",
        weight = 5,
        value = 20,
        rarity = "uncommon",
        techLevel = "iron"
    },
    
    -- ============================
    -- MÉTAUX RAFFINÉS
    -- ============================
    
    ["bronze"] = {
        name = "Bronze",
        description = "Un alliage de cuivre et d'étain.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345615",
        model = "rbxassetid://12345665",
        weight = 2,
        value = 12,
        techLevel = "bronze"
    },
    
    ["iron"] = {
        name = "Fer",
        description = "Un métal solide pour fabriquer des outils et armes.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345616",
        model = "rbxassetid://12345666",
        weight = 3,
        value = 15,
        techLevel = "iron"
    },
    
    ["gold"] = {
        name = "Or",
        description = "Un métal précieux utilisé pour la décoration et les bijoux.",
        category = "material",
        stackable = true,
        maxStack = 16,
        icon = "rbxassetid://12345617",
        model = "rbxassetid://12345667",
        weight = 4,
        value = 40,
        rarity = "uncommon",
        techLevel = "gold"
    },
    
    -- ============================
    -- OUTILS DE L'ÂGE DE PIERRE
    -- ============================
    
    ["stone_axe"] = {
        name = "Hache en pierre",
        description = "Un outil primitif pour couper du bois.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "axe",
        durability = 100,
        damage = 5,
        icon = "rbxassetid://12345618",
        model = "rbxassetid://12345668",
        weight = 3,
        value = 10,
        techLevel = "stone",
        gatherMultiplier = {
            ["wood"] = 2 -- Récolte 2x plus de bois
        }
    },
    
    ["stone_pickaxe"] = {
        name = "Pioche en pierre",
        description = "Un outil pour miner des minerais.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "pickaxe",
        durability = 100,
        damage = 4,
        icon = "rbxassetid://12345619",
        model = "rbxassetid://12345669",
        weight = 3,
        value = 10,
        techLevel = "stone",
        gatherMultiplier = {
            ["stone"] = 2,
            ["copper_ore"] = 1.5,
            ["tin_ore"] = 1.5
        }
    },
    
    ["stone_spear"] = {
        name = "Lance en pierre",
        description = "Une arme primitive pour chasser.",
        category = "weapon",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 80,
        damage = 8,
        icon = "rbxassetid://12345620",
        model = "rbxassetid://12345670",
        weight = 2,
        value = 15,
        techLevel = "stone"
    },
    
    ["stone_hammer"] = {
        name = "Marteau en pierre",
        description = "Un outil basique pour la construction.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "hammer",
        durability = 120,
        damage = 5,
        icon = "rbxassetid://12345621",
        model = "rbxassetid://12345671",
        weight = 3,
        value = 12,
        techLevel = "stone"
    },
    
    ["bone_knife"] = {
        name = "Couteau en os",
        description = "Un outil tranchant fait à partir d'os.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "knife",
        durability = 80,
        damage = 4,
        icon = "rbxassetid://12345622",
        model = "rbxassetid://12345672",
        weight = 1,
        value = 8,
        techLevel = "stone"
    },
    
    ["fishing_rod"] = {
        name = "Canne à pêche",
        description = "Pour attraper des poissons dans l'eau.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "fishing",
        durability = 100,
        icon = "rbxassetid://12345623",
        model = "rbxassetid://12345673",
        weight = 2,
        value = 15,
        techLevel = "stone"
    },
    
    ["wooden_bow"] = {
        name = "Arc en bois",
        description = "Une arme de chasse à distance.",
        category = "weapon",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "bow",
        durability = 120,
        damage = 6,
        icon = "rbxassetid://12345624",
        model = "rbxassetid://12345674",
        weight = 2,
        value = 18,
        techLevel = "stone",
        ammo = "arrow"
    },
    
    ["arrow"] = {
        name = "Flèche",
        description = "Munition pour l'arc.",
        category = "ammo",
        stackable = true,
        maxStack = 24,
        damage = 4,
        icon = "rbxassetid://12345625",
        model = "rbxassetid://12345675",
        weight = 0.1,
        value = 1,
        techLevel = "stone"
    },
    
    -- ============================
    -- OUTILS EN BRONZE
    -- ============================
    
    ["bronze_axe"] = {
        name = "Hache en bronze",
        description = "Une hache efficace en bronze.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "axe",
        durability = 200,
        damage = 8,
        icon = "rbxassetid://12345626",
        model = "rbxassetid://12345676",
        weight = 4,
        value = 25,
        techLevel = "bronze",
        gatherMultiplier = {
            ["wood"] = 3
        }
    },
    
    ["bronze_pickaxe"] = {
        name = "Pioche en bronze",
        description = "Une pioche solide pour miner.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "pickaxe",
        durability = 200,
        damage = 7,
        icon = "rbxassetid://12345627",
        model = "rbxassetid://12345677",
        weight = 4,
        value = 25,
        techLevel = "bronze",
        gatherMultiplier = {
            ["stone"] = 3,
            ["copper_ore"] = 2,
            ["tin_ore"] = 2,
            ["iron_ore"] = 1.5
        }
    },
    
    ["bronze_sword"] = {
        name = "Épée en bronze",
        description = "Une arme tranchante efficace.",
        category = "weapon",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 200,
        damage = 12,
        icon = "rbxassetid://12345628",
        model = "rbxassetid://12345678",
        weight = 3,
        value = 35,
        techLevel = "bronze"
    },
    
    ["bronze_shield"] = {
        name = "Bouclier en bronze",
        description = "Protection efficace contre les attaques.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "offhand",
        durability = 250,
        defenseBonus = 10,
        icon = "rbxassetid://12345629",
        model = "rbxassetid://12345679",
        weight = 5,
        value = 30,
        techLevel = "bronze"
    },
    
    ["bronze_hoe"] = {
        name = "Houe en bronze",
        description = "Pour cultiver la terre.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "hoe",
        durability = 150,
        icon = "rbxassetid://12345630",
        model = "rbxassetid://12345680",
        weight = 3,
        value = 20,
        techLevel = "bronze"
    },
    
    -- ============================
    -- OUTILS EN FER
    -- ============================
    
    ["iron_axe"] = {
        name = "Hache en fer",
        description = "Une hache puissante pour couper du bois rapidement.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "axe",
        durability = 400,
        damage = 12,
        icon = "rbxassetid://12345631",
        model = "rbxassetid://12345681",
        weight = 5,
        value = 40,
        techLevel = "iron",
        gatherMultiplier = {
            ["wood"] = 4
        }
    },
    
    ["iron_pickaxe"] = {
        name = "Pioche en fer",
        description = "Une pioche robuste qui peut miner tous les types de minerais.",
        category = "tool",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "pickaxe",
        durability = 400,
        damage = 10,
        icon = "rbxassetid://12345632",
        model = "rbxassetid://12345682",
        weight = 5,
        value = 40,
        techLevel = "iron",
        gatherMultiplier = {
            ["stone"] = 4,
            ["copper_ore"] = 3,
            ["tin_ore"] = 3,
            ["iron_ore"] = 2,
            ["gold_ore"] = 2
        }
    },
    
    ["iron_sword"] = {
        name = "Épée en fer",
        description = "Une arme redoutable, plus puissante que l'épée en bronze.",
        category = "weapon",
        stackable = false,
        equipable = true,
        equipSlot = "tool",
        toolType = "weapon",
        durability = 400,
        damage = 16,
        icon = "rbxassetid://12345633",
        model = "rbxassetid://12345683",
        weight = 4,
        value = 50,
        techLevel = "iron"
    },
    
    ["iron_shield"] = {
        name = "Bouclier en fer",
        description = "Offre une excellente protection contre les attaques.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "offhand",
        durability = 450,
        defenseBonus = 15,
        icon = "rbxassetid://12345634",
        model = "rbxassetid://12345684",
        weight = 6,
        value = 45,
        techLevel = "iron"
    },
    
    ["iron_helmet"] = {
        name = "Casque en fer",
        description = "Protège efficacement la tête.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "head",
        durability = 300,
        defenseBonus = 10,
        temperatureModifier = 5,
        icon = "rbxassetid://12345635",
        model = "rbxassetid://12345685",
        weight = 4,
        value = 35,
        techLevel = "iron"
    },
    
    ["iron_chestplate"] = {
        name = "Plastron en fer",
        description = "Protège efficacement le torse.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "body",
        durability = 400,
        defenseBonus = 20,
        temperatureModifier = 8,
        icon = "rbxassetid://12345636",
        model = "rbxassetid://12345686",
        weight = 8,
        value = 50,
        techLevel = "iron"
    },
    
    ["iron_leggings"] = {
        name = "Jambières en fer",
        description = "Protège efficacement les jambes.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "legs",
        durability = 350,
        defenseBonus = 15,
        temperatureModifier = 6,
        icon = "rbxassetid://12345637",
        model = "rbxassetid://12345687",
        weight = 6,
        value = 40,
        techLevel = "iron"
    },
    
    ["iron_boots"] = {
        name = "Bottes en fer",
        description = "Protège efficacement les pieds.",
        category = "armor",
        stackable = false,
        equipable = true,
        equipSlot = "feet",
        durability
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="35">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="36">
      <Properties>
        <string name="Name">Server</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[-- src/server/init.lua
-- Point d'entrée principal du serveur

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local Server = ServerScriptService:WaitForChild("Server")
local Services = Server:WaitForChild("services")

-- Initialiser les RemoteEvents avant de démarrer les services
local function InitializeRemoteEvents()
    print("Serveur: Initialisation des RemoteEvents...")
    
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if not Events then
        Events = Instance.new("Folder")
        Events.Name = "Events"
        Events.Parent = ReplicatedStorage
    end
    
    -- Liste de tous les RemoteEvents nécessaires
    local requiredEvents = {
        -- Inventaire
        "UpdateInventory",
        "InventoryAction",
        
        -- Survie
        "UpdateStats",
        "Sleep",
        
        -- Artisanat
        "UpdateRecipes",
        "CraftComplete",
        "CraftRequest",
        
        -- Tribus
        "TribeAction",
        "TribeUpdate",
        
        -- Temps
        "TimeUpdate",
        
        -- Ressources
        "ResourceHarvest",
        "ResourceGenerate",
        
        -- Construction
        "BuildingStart",
        "BuildingPlacement",
        "BuildingAction",
        
        -- Combat
        "AttackPlayer",
        "TakeDamage",
        "UpdateHealth",
        "EquipWeapon",
        
        -- Farming
        "PlantSeed",
        "HarvestCrop",
        "UpdateCrop",
        
        -- Général
        "Notification",
        "PlayerAction",
        "PlayAnimation",
        "UpdatePlayerData"
    }
    
    -- Créer les RemoteEvents
    for _, eventName in ipairs(requiredEvents) do
        if not Events:FindFirstChild(eventName) then
            local remoteEvent = Instance.new("RemoteEvent")
            remoteEvent.Name = eventName
            remoteEvent.Parent = Events
            print("  ✓ RemoteEvent créé: " .. eventName)
        end
    end
    
    -- Liste des RemoteFunctions nécessaires
    local requiredFunctions = {
        "GetPlayerData",
        "GetInventory",
        "GetTribeData",
        "CanCraft"
    }
    
    -- Créer les RemoteFunctions
    for _, functionName in ipairs(requiredFunctions) do
        if not Events:FindFirstChild(functionName) then
            local remoteFunction = Instance.new("RemoteFunction")
            remoteFunction.Name = functionName
            remoteFunction.Parent = Events
            print("  ✓ RemoteFunction créée: " .. functionName)
        end
    end
    
    print("Serveur: RemoteEvents initialisés avec succès")
end

-- Initialiser les services
local function InitializeServices()
    print("Serveur: Initialisation des services...")
    
    -- Charger tous les services
    local PlayerService = require(Services.PlayerService).new()
    local InventoryService = require(Services.InventoryService).new()
    local SurvivalService = require(Services.SurvivalService).new()
    local CraftingService = require(Services.CraftingService).new()
    local ResourceService = require(Services.ResourceService).new()
    local BuildingService = require(Services.BuildingService).new()
    local TimeService = require(Services.TimeService).new()
    local TribeService = require(Services.TribeService).new()
    local CombatService = require(Services.CombatService).new()
    local FarmingService = require(Services.FarmingService).new()
    
    -- Créer la table de services
    local services = {
        PlayerService = PlayerService,
        InventoryService = InventoryService,
        SurvivalService = SurvivalService,
        CraftingService = CraftingService,
        ResourceService = ResourceService,
        BuildingService = BuildingService,
        TimeService = TimeService,
        TribeService = TribeService,
        CombatService = CombatService,
        FarmingService = FarmingService
    }
    
    -- Démarrer chaque service (en passant la table de services pour les dépendances)
    for name, service in pairs(services) do
        if service.Start then
            local success, error = pcall(function()
                service:Start(services)
            end)
            
            if success then
                print("  ✓ Service démarré: " .. name)
            else
                warn("  ✗ Erreur lors du démarrage de " .. name .. ": " .. tostring(error))
            end
        end
    end
    
    print("Serveur: Tous les services sont démarrés")
    return services
end

-- Point d'entrée principal
print("========================================")
print("  THE BEGINNING - Serveur")
print("========================================")

-- Initialiser les RemoteEvents
InitializeRemoteEvents()

-- Initialiser les services
local services = InitializeServices()

print("========================================")
print("  Serveur initialisé avec succès!")
print("========================================")

return services
]]></string>
      </Properties>
      <Item class="Folder" referent="37">
        <Properties>
          <string name="Name">services</string>
        </Properties>
        <Item class="ModuleScript" referent="38">
          <Properties>
            <string name="Name">BuildingService</string>
            <string name="Source"><![CDATA[-- src/server/services/BuildingService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local Shared = ReplicatedStorage:FindFirstChild("Shared")
if not Shared then
    error("Dossier Shared non trouvé dans ReplicatedStorage")
    return nil
end

local GameSettings = require(Shared.constants.GameSettings)
local ItemTypes = require(Shared.constants.ItemTypes)

local BuildingService = {}
BuildingService.__index = BuildingService

-- Créer une instance du service
function BuildingService.new()
    local self = setmetatable({}, BuildingService)
    
    -- Structures construites
    self.playerStructures = {}  -- [userId] = {structureId = structure}
    self.structuresById = {}    -- [structureId] = {owner = userId, instance = modelInstance, type = buildingType}
    
    -- Joueurs en mode construction
    self.buildingMode = {}      -- [userId] = {itemId = id, previewInstance = instance, slotNumber = slot}
    
    -- Types de bâtiments disponibles
    self.buildingTypes = {
        -- Bâtiments de base
        ["wooden_wall"] = {
            name = "Mur en bois",
            model = "", -- À remplacer par un ID réel
            durability = 100,
            techLevel = "stone",
            category = "building",
            buildTime = 5, -- Secondes pour construire
            isWall = true
        },
        ["wooden_floor"] = {
            name = "Sol en bois",
            model = "", -- À remplacer par un ID réel
            durability = 80,
            techLevel = "stone",
            category = "building",
            buildTime = 3
        },
        ["wooden_door"] = {
            name = "Porte en bois",
            model = "", -- À remplacer par un ID réel
            durability = 90,
            techLevel = "stone",
            category = "building",
            buildTime = 6,
            isDoor = true
        },
        
        -- Meubles
        ["wooden_bed"] = {
            name = "Lit en bois",
            model = "", -- À remplacer par un ID réel
            durability = 60,
            techLevel = "stone",
            category = "furniture",
            buildTime = 8,
            sleepQuality = 1 -- Multiplicateur de récupération d'énergie
        },
        ["wooden_table"] = {
            name = "Table en bois",
            model = "", -- À remplacer par un ID réel
            durability = 50,
            techLevel = "stone",
            category = "furniture",
            buildTime = 5
        },
        ["wooden_chair"] = {
            name = "Chaise en bois",
            model = "", -- À remplacer par un ID réel
            durability = 40,
            techLevel = "stone",
            category = "furniture",
            buildTime = 4
        },
        ["campfire"] = {
            name = "Feu de camp",
            model = "", -- À remplacer par un ID réel
            durability = 30,
            techLevel = "stone",
            category = "furniture",
            buildTime = 5,
            heatSource = true,
            heatRadius = 10,
            heatIntensity = 15,
            cookingStation = true
        },
        ["furnace"] = {
            name = "Four",
            model = "", -- À remplacer par un ID réel
            durability = 120,
            techLevel = "stone",
            category = "furniture",
            buildTime = 10,
            heatSource = true,
            heatRadius = 5,
            heatIntensity = 20,
            smeltingStation = true
        },
        ["anvil"] = {
            name = "Enclume",
            model = "", -- À remplacer par un ID réel
            durability = 150,
            techLevel = "bronze",
            category = "furniture",
            buildTime = 12,
            forgingStation = true
        }
    }
    
    -- Compteur pour les IDs des structures
    self.nextStructureId = 1
    
    -- Références aux services (seront injectées dans Start)
    self.inventoryService = nil
    self.tribeService = nil
    self.survivalService = nil
    
    -- RemoteEvents (seront référencés dans Start)
    self.remoteEvents = {}
    
    return self
end

-- Initialiser les structures d'un joueur
function BuildingService:InitializePlayerStructures(player)
    local userId = player.UserId
    
    if not self.playerStructures[userId] then
        self.playerStructures[userId] = {}
    end
end

-- Commencer le placement d'un bâtiment
function BuildingService:StartPlacement(player, itemId, slotNumber)
    local userId = player.UserId
    
    -- Vérifier si l'objet est de type construction
    local itemType = ItemTypes[itemId]
    if not itemType or (itemType.category ~= "building" and itemType.category ~= "furniture") then
        self:SendNotification(player, "Cet objet ne peut pas être construit", "error")
        return false
    end
    
    -- Vérifier si le joueur est déjà en mode construction
    if self.buildingMode[userId] then
        self:CancelPlacement(player)
    end
    
    -- Créer un aperçu du bâtiment
    local previewInstance = self:CreateBuildingPreview(itemId)
    if not previewInstance then
        self:SendNotification(player, "Impossible de créer l'aperçu du bâtiment", "error")
        return false
    end
    
    -- Mettre à jour l'état du mode construction
    self.buildingMode[userId] = {
        itemId = itemId,
        previewInstance = previewInstance,
        slotNumber = slotNumber
    }
    
    -- Positionner l'aperçu initialement devant le joueur
    self:UpdatePreviewPosition(player)
    
    -- Informer le client qu'il est en mode construction
    if self.remoteEvents.BuildingStart then
        self.remoteEvents.BuildingStart:FireClient(player, itemId, previewInstance)
    end
    
    self:SendNotification(player, "Mode construction activé. Cliquez pour placer " .. itemType.name, "info")
    return true
end

-- Créer un aperçu de bâtiment
function BuildingService:CreateBuildingPreview(itemId)
    -- Dans une implémentation complète, charger le modèle depuis les ressources du jeu
    -- Pour cet exemple, créer un modèle simple
    
    local preview = Instance.new("Model")
    preview.Name = "BuildingPreview"
    
    local primaryPart = Instance.new("Part")
    primaryPart.Name = "PrimaryPart"
    primaryPart.Anchored = true
    primaryPart.CanCollide = false
    primaryPart.Transparency = 0.5
    primaryPart.Material = Enum.Material.Plastic
    
    -- Taille en fonction du type d'objet
    if itemId == "wooden_wall" then
        primaryPart.Size = Vector3.new(0.2, 3, 4)
    elseif itemId == "wooden_floor" then
        primaryPart.Size = Vector3.new(4, 0.2, 4)
    elseif itemId == "wooden_door" then
        primaryPart.Size = Vector3.new(0.2, 3, 1.5)
    elseif itemId == "wooden_bed" then
        primaryPart.Size = Vector3.new(2, 0.5, 4)
    elseif itemId == "wooden_table" then
        primaryPart.Size = Vector3.new(3, 1, 1.5)
    elseif itemId == "wooden_chair" then
        primaryPart.Size = Vector3.new(1, 1.5, 1)
    elseif itemId == "campfire" or itemId == "furnace" then
        primaryPart.Size = Vector3.new(2, 1, 2)
    elseif itemId == "anvil" then
        primaryPart.Size = Vector3.new(1, 1, 2)
    else
        primaryPart.Size = Vector3.new(1, 1, 1)
    end
    
    -- Définir la couleur en fonction de la validité (vert = valide, rouge = invalide)
    primaryPart.Color = Color3.fromRGB(0, 255, 0) -- Commence en vert
    
    primaryPart.Parent = preview
    preview.PrimaryPart = primaryPart
    
    -- Ajouter un attribut pour identifier le type de bâtiment
    preview:SetAttribute("BuildingType", itemId)
    
    -- Parenté à Workspace temporairement
    local previewFolder = Workspace:FindFirstChild("BuildingPreviews")
    if not previewFolder then
        previewFolder = Instance.new("Folder")
        previewFolder.Name = "BuildingPreviews"
        previewFolder.Parent = Workspace
    end
    
    preview.Parent = previewFolder
    
    return preview
end

-- Mettre à jour la position de l'aperçu du bâtiment
function BuildingService:UpdatePreviewPosition(player)
    local userId = player.UserId
    local buildModeData = self.buildingMode[userId]
    
    if not buildModeData or not buildModeData.previewInstance then return end
    
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    local rootPart = character.HumanoidRootPart
    local lookVector = rootPart.CFrame.LookVector
    
    -- Positionner devant le joueur
    local position = rootPart.Position + (lookVector * 5)
    
    -- Ajuster la hauteur selon le type d'objet
    local itemId = buildModeData.itemId
    if itemId == "wooden_floor" then
        position = position - Vector3.new(0, 1.5, 0) -- Positionner sous les pieds
    elseif itemId == "wooden_wall" or itemId == "wooden_door" then
        position = position + Vector3.new(0, 0.5, 0) -- Position légèrement plus élevée
    end
    
    -- Obtenir l'orientation de l'aperçu (alignée avec la direction du joueur)
    local orientation = CFrame.new(position, position + lookVector)
    
    -- Mettre à jour la position de l'aperçu
    buildModeData.previewInstance:PivotTo(orientation)
    
    -- Vérifier si l'emplacement est valide
    local isValid = self:CheckPlacementValidity(player, position, itemId)
    
    -- Mettre à jour la couleur de l'aperçu
    local primaryPart = buildModeData.previewInstance.PrimaryPart
    if primaryPart then
        primaryPart.Color = isValid and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    end
    
    return isValid
end

-- Vérifier si l'emplacement est valide pour placer un bâtiment
function BuildingService:CheckPlacementValidity(player, position, itemId)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
    
    local rootPart = character.HumanoidRootPart
    local distance = (rootPart.Position - position).Magnitude
    
    -- Vérification 1: Distance maximale
    local maxDistance = GameSettings.Building.maxDistanceFromTribe or 50
    if distance > 10 then -- Distance pour le placement (plus court que la distance de tribu)
        return false
    end
    
    -- Vérification 2: Collision avec d'autres structures
    local overlapParams = OverlapParams.new()
    overlapParams.FilterType = Enum.RaycastFilterType.Whitelist
    
    -- Filtrer pour ne vérifier que les structures déjà placées
    local structuresFolder = Workspace:FindFirstChild("Structures")
    if structuresFolder then
        overlapParams.FilterDescendantsInstances = {structuresFolder}
        
        -- Taille du modèle à vérifier
        local size = Vector3.new(4, 3, 4) -- Taille générique
        if itemId == "wooden_wall" then
            size = Vector3.new(0.5, 3, 4)
        elseif itemId == "wooden_floor" then
            size = Vector3.new(4, 0.5, 4)
        elseif itemId == "wooden_door" then
            size = Vector3.new(0.5, 3, 2)
        end
        
        -- Vérifier les collisions
        local parts = Workspace:GetPartBoundsInBox(CFrame.new(position), size, overlapParams)
        if #parts > 0 then
            return false
        end
    end
    
    -- Vérification 3: Collision avec les ressources naturelles
    local resourcesFolder = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Resources")
    if resourcesFolder then
        for _, typeFolder in ipairs(resourcesFolder:GetChildren()) do
            for _, resource in ipairs(typeFolder:GetChildren()) do
                if resource:IsA("Model") and resource.PrimaryPart then
                    local distance = (resource.PrimaryPart.Position - position).Magnitude
                    -- Distance minimale de 5 studs des ressources
                    if distance < 5 then
                        return false
                    end
                end
            end
        end
    end
    
    -- Vérification 4: Collision avec les cultures
    local cropsFolder = Workspace:FindFirstChild("Crops")
    if cropsFolder then
        for _, crop in ipairs(cropsFolder:GetChildren()) do
            if crop:IsA("Model") and crop.PrimaryPart then
                local distance = (crop.PrimaryPart.Position - position).Magnitude
                -- Distance minimale de 3 studs des cultures
                if distance < 3 then
                    return false
                end
            end
        end
    end
    
    -- Vérification 5: Zone de tribu (si le système de tribu est activé)
    if self.tribeService then
        local userId = player.UserId
        local tribeId = self.tribeService:GetPlayerTribeId(player)
        
        -- Si le joueur est dans une tribu, vérifier qu'il est dans le territoire
        if tribeId then
            local tribeData = self.tribeService:GetTribeData(tribeId)
            if tribeData and tribeData.territory and tribeData.territory.center then
                local tribeCenter = tribeData.territory.center
                local tribeCenterVec = Vector3.new(tribeCenter.x, tribeCenter.y, tribeCenter.z)
                local distanceFromTribes = (position - tribeCenterVec).Magnitude
                
                if distanceFromTribes > maxDistance then
                    return false
                end
            end
        else
            -- Si le joueur n'est pas dans une tribu, il ne peut construire que près de lui
            if distance > 15 then
                return false
            end
        end
    end
    
    -- Vérification 6: Le joueur a les permissions (si c'est dans une zone de tribu)
    -- À implémenter si nécessaire avec le système de tribu
    
    -- Si toutes les vérifications sont passées, l'emplacement est valide
    return true
end

-- Annuler le placement en cours
function BuildingService:CancelPlacement(player)
    local userId = player.UserId
    
    if not self.buildingMode[userId] then return end
    
    -- Supprimer l'aperçu
    if self.buildingMode[userId].previewInstance then
        self.buildingMode[userId].previewInstance:Destroy()
    end
    
    -- Réinitialiser l'état
    self.buildingMode[userId] = nil
    
    -- Informer le client
    self:SendNotification(player, "Mode construction annulé", "info")
end

-- Placer un bâtiment à la position actuelle
function BuildingService:PlaceBuilding(player, itemId, position, rotation)
    local userId = player.UserId
    
    -- Vérifier si le joueur est en mode construction ou si des données ont été fournies
    local buildModeData = self.buildingMode[userId]
    
    -- Si position et rotation sont fournis directement, utiliser ces valeurs
    if position and rotation then
        -- Vérifier si l'emplacement est valide
        if not self:CheckPlacementValidity(player, position, itemId) then
            self:SendNotification(player, "Emplacement invalide pour la construction", "error")
            return false, "Emplacement invalide"
        end
    else
        -- Sinon, utiliser les données du mode construction
        if not buildModeData or buildModeData.itemId ~= itemId then
            self:SendNotification(player, "Vous n'êtes pas en mode construction pour cet objet", "error")
            return false, "Mode construction non actif"
        end
        
        -- Vérifier si l'aperçu existe
        if not buildModeData.previewInstance then
            self:SendNotification(player, "Aperçu de construction invalide", "error")
            return false, "Aperçu invalide"
        end
        
        -- Récupérer la position et rotation de l'aperçu
        position = buildModeData.previewInstance:GetPrimaryPartCFrame().Position
        rotation = buildModeData.previewInstance.PrimaryPart.CFrame - buildModeData.previewInstance.PrimaryPart.Position
        
        -- Vérifier une dernière fois si l'emplacement est valide
        if not self:UpdatePreviewPosition(player) then
            self:SendNotification(player, "Emplacement invalide pour la construction", "error")
            return false, "Emplacement invalide"
        end
    end
    
    -- Vérifier la limite de constructions par joueur
    local maxStructures = GameSettings.Building.maxStructuresPerPlayer or 100
    local playerStructureCount = 0
    
    if self.playerStructures[userId] then
        for _ in pairs(self.playerStructures[userId]) do
            playerStructureCount = playerStructureCount + 1
        end
    end
    
    if playerStructureCount >= maxStructures then
        self:SendNotification(player, string.format("Limite de constructions atteinte (%d/%d)", playerStructureCount, maxStructures), "error")
        return false, "Limite de constructions atteinte"
    end
    
    -- Vérifier si le joueur a l'objet dans son inventaire
    if not self.inventoryService:HasItemInInventory(player, itemId, 1) then
        self:SendNotification(player, "Vous n'avez pas cet objet dans votre inventaire", "error")
        return false, "Objet manquant dans l'inventaire"
    end
    
    -- Retirer l'objet de l'inventaire
    local success = self.inventoryService:RemoveItemFromInventory(player, itemId, 1)
    if not success then
        self:SendNotification(player, "Impossible de retirer l'objet de l'inventaire", "error")
        return false, "Erreur d'inventaire"
    end
    
    -- Créer la structure dans le monde
    local structureInstance = self:CreateStructureInstance(itemId, position, rotation)
    if not structureInstance then
        -- En cas d'erreur, remettre l'objet dans l'inventaire
        self.inventoryService:AddItemToInventory(player, itemId, 1)
        self:SendNotification(player, "Erreur lors de la création de la structure", "error")
        return false, "Erreur de création"
    end
    
    -- Générer un ID pour la structure
    local structureId = "structure_" .. self.nextStructureId
    self.nextStructureId = self.nextStructureId + 1
    
    -- Stocker les données de la structure
    self.structuresById[structureId] = {
        owner = userId,
        instance = structureInstance,
        type = itemId,
        creationTime = os.time(),
        durability = self.buildingTypes[itemId] and self.buildingTypes[itemId].durability or 100,
        position = position,
        rotation = rotation
    }
    
    -- Associer la structure au joueur
    if not self.playerStructures[userId] then
        self.playerStructures[userId] = {}
    end
    self.playerStructures[userId][structureId] = true
    
    -- Définir les attributs de la structure
    structureInstance:SetAttribute("StructureId", structureId)
    structureInstance:SetAttribute("Owner", userId)
    
    -- Si c'est un meuble interactif, ajouter un ClickDetector
    if self:IsInteractiveBuilding(itemId) then
        self:MakeBuildingInteractive(structureInstance, itemId)
    end
    
    -- Annuler le mode construction
    if buildModeData then
        self:CancelPlacement(player)
    end
    
    -- Notifier le joueur
    self:SendNotification(player, "Vous avez construit: " .. (ItemTypes[itemId] and ItemTypes[itemId].name or itemId), "success")
    
    -- Notifier les clients proches de la nouvelle structure
    self:NotifyNearbyPlayers(position, player.Name .. " a construit " .. (ItemTypes[itemId] and ItemTypes[itemId].name or itemId), 30)
    
    return true, "Construction réussie"
end

-- Créer une instance de structure dans le monde
function BuildingService:CreateStructureInstance(itemId, position, rotation)
    -- Dans une implémentation complète, charger le modèle depuis les ressources du jeu
    -- Pour cet exemple, créer un modèle simple
    
    local structureModel = Instance.new("Model")
    structureModel.Name = ItemTypes[itemId] and ItemTypes[itemId].name or itemId
    
    local primaryPart = Instance.new("Part")
    primaryPart.Name = "PrimaryPart"
    primaryPart.Anchored = true
    primaryPart.CanCollide = true
    
    -- Taille en fonction du type d'objet (même logique que pour l'aperçu)
    if itemId == "wooden_wall" then
        primaryPart.Size = Vector3.new(0.2, 3, 4)
    elseif itemId == "wooden_floor" then
        primaryPart.Size = Vector3.new(4, 0.2, 4)
    elseif itemId == "wooden_door" then
        primaryPart.Size = Vector3.new(0.2, 3, 1.5)
    elseif itemId == "wooden_bed" then
        primaryPart.Size = Vector3.new(2, 0.5, 4)
    elseif itemId == "wooden_table" then
        primaryPart.Size = Vector3.new(3, 1, 1.5)
    elseif itemId == "wooden_chair" then
        primaryPart.Size = Vector3.new(1, 1.5, 1)
    elseif itemId == "campfire" or itemId == "furnace" then
        primaryPart.Size = Vector3.new(2, 1, 2)
    elseif itemId == "anvil" then
        primaryPart.Size = Vector3.new(1, 1, 2)
    else
        primaryPart.Size = Vector3.new(1, 1, 1)
    end
    
    -- Définir l'apparence
    primaryPart.Material = Enum.Material.Wood
    if itemId:find("stone") then
        primaryPart.Material = Enum.Material.Slate
    elseif itemId:find("brick") then
        primaryPart.Material = Enum.Material.Brick
    elseif itemId == "anvil" then
        primaryPart.Material = Enum.Material.Metal
    elseif itemId == "campfire" then
        primaryPart.Material = Enum.Material.Neon
        primaryPart.Color = Color3.fromRGB(255, 100, 0)
    end
    
    -- Positionner la partie principale
    primaryPart.CFrame = CFrame.new(position) * rotation
    primaryPart.Parent = structureModel
    structureModel.PrimaryPart = primaryPart
    
    -- Créer le dossier de structures s'il n'existe pas
    local structuresFolder = Workspace:FindFirstChild("Structures")
    if not structuresFolder then
        structuresFolder = Instance.new("Folder")
        structuresFolder.Name = "Structures"
        structuresFolder.Parent = Workspace
    end
    
    -- Si c'est une porte, ajouter une fonction d'ouverture/fermeture
    if itemId == "wooden_door" then
        self:SetupDoor(structureModel)
    end
    
    -- Parenter au dossier de structures
    structureModel.Parent = structuresFolder
    
    return structureModel
end

-- Configurer une porte pour qu'elle puisse s'ouvrir et se fermer
function BuildingService:SetupDoor(doorModel)
    local primaryPart = doorModel.PrimaryPart
    if not primaryPart then return end
    
    -- Ajouter un attribut pour l'état de la porte
    doorModel:SetAttribute("DoorOpen", false)
    doorModel:SetAttribute("DoorAnimating", false)
    
    -- Ajouter un ClickDetector pour l'interaction
    local clickDetector = Instance.new("ClickDetector")
    clickDetector.MaxActivationDistance = 10
    clickDetector.Parent = primaryPart
    
    -- Gérer l'ouverture/fermeture avec debounce
    clickDetector.MouseClick:Connect(function(player)
        -- Debounce : empêcher l'animation si déjà en cours
        if doorModel:GetAttribute("DoorAnimating") then
            return
        end
        
        doorModel:SetAttribute("DoorAnimating", true)
        
        local isOpen = doorModel:GetAttribute("DoorOpen")
        isOpen = not isOpen
        doorModel:SetAttribute("DoorOpen", isOpen)
        
        -- Tourner la porte
        local currentCFrame = primaryPart.CFrame
        local doorPivot = currentCFrame.Position - (currentCFrame.RightVector * primaryPart.Size.X/2)
        
        local targetRotation
        if isOpen then
            -- Ouvrir (tourner de 90 degrés)
            targetRotation = currentCFrame * CFrame.Angles(0, math.rad(90), 0)
        else
            -- Fermer (retourner à la position d'origine)
            targetRotation = CFrame.new(currentCFrame.Position) * (currentCFrame - currentCFrame.Position)
        end
        
        -- Animer l'ouverture/fermeture
        local duration = 0.5
        local startTime = tick()
        local initialCFrame = primaryPart.CFrame
        
        local connection
        connection = game:GetService("RunService").Heartbeat:Connect(function()
            local elapsed = tick() - startTime
            local alpha = math.min(elapsed / duration, 1)
            
            -- Interpolation pour une animation fluide
            primaryPart.CFrame = initialCFrame:Lerp(targetRotation, alpha)
            
            if alpha >= 1 then
                connection:Disconnect()
                -- Désactiver le debounce à la fin de l'animation
                doorModel:SetAttribute("DoorAnimating", false)
            end
        end)
    end)
end

-- Rendre un bâtiment interactif
function BuildingService:MakeBuildingInteractive(structureInstance, itemId)
    local primaryPart = structureInstance.PrimaryPart
    if not primaryPart then return end
    
    -- Ajouter un ClickDetector pour l'interaction
    local clickDetector = Instance.new("ClickDetector")
    clickDetector.MaxActivationDistance = 10
    clickDetector.Parent = primaryPart
    
    -- Fonction d'interaction basée sur le type de bâtiment
    clickDetector.MouseClick:Connect(function(player)
        -- Obtenir l'ID de la structure
        local structureId = structureInstance:GetAttribute("StructureId")
        if not structureId then return end
        
        -- Traiter différents types d'interactions
        if itemId == "wooden_bed" then
            -- Lit - permettre au joueur de dormir
            self:HandleBedInteraction(player, structureId)
        elseif itemId == "campfire" then
            -- Feu de camp - cuisson
            self:HandleCampfireInteraction(player, structureId)
        elseif itemId == "furnace" then
            -- Four - fonte
            self:HandleFurnaceInteraction(player, structureId)
        elseif itemId == "anvil" then
            -- Enclume - forge
            self:HandleAnvilInteraction(player, structureId)
        end
    end)
end

-- Gérer l'interaction avec un lit
function BuildingService:HandleBedInteraction(player, structureId)
    -- Vérifier si la structure existe
    local structureData = self.structuresById[structureId]
    if not structureData then return end
    
    -- Vérifier si le joueur a accès au lit
    if not self:CanPlayerInteractWithStructure(player, structureId) then
        self:SendNotification(player, "Vous n'avez pas accès à ce lit", "error")
        return
    end
    
    -- Appeler le SurvivalService pour démarrer le sommeil
    if self.survivalService then
        local success = self.survivalService:StartSleeping(player, structureId)
        if success then
            self:SendNotification(player, "Vous vous endormez...", "success")
        else
            self:SendNotification(player, "Impossible de dormir pour le moment", "warning")
        end
    else
        -- Fallback si SurvivalService n'est pas disponible
        if self.remoteEvents.PlayerAction then
            self.remoteEvents.PlayerAction:FireClient(player, "sleep")
        end
    end
end

-- Gérer l'interaction avec un feu de camp
function BuildingService:HandleCampfireInteraction(player, structureId)
    -- Vérifier si la structure existe
    local structureData = self.structuresById[structureId]
    if not structureData then return end
    
    -- Vérifier si le joueur a accès au feu de camp
    if not self:CanPlayerInteractWithStructure(player, structureId) then
        self:SendNotification(player, "Vous n'avez pas accès à ce feu de camp", "error")
        return
    end
    
    -- Ouvrir l'interface de cuisson pour le joueur
    if self.remoteEvents.OpenCraftingStation then
        self.remoteEvents.OpenCraftingStation:FireClient(player, "cooking", structureId)
    else
        self:SendNotification(player, "Ouverture de l'interface de cuisson", "info")
    end
end

-- Gérer l'interaction avec un four
function BuildingService:HandleFurnaceInteraction(player, structureId)
    -- Vérifier si la structure existe
    local structureData = self.structuresById[structureId]
    if not structureData then return end
    
    -- Vérifier si le joueur a accès au four
    if not self:CanPlayerInteractWithStructure(player, structureId) then
        self:SendNotification(player, "Vous n'avez pas accès à ce four", "error")
        return
    end
    
    -- Ouvrir l'interface de fonte pour le joueur
    if self.remoteEvents.OpenCraftingStation then
        self.remoteEvents.OpenCraftingStation:FireClient(player, "smelting", structureId)
    else
        self:SendNotification(player, "Ouverture de l'interface de fonte", "info")
    end
end

-- Gérer l'interaction avec une enclume
function BuildingService:HandleAnvilInteraction(player, structureId)
    -- Vérifier si la structure existe
    local structureData = self.structuresById[structureId]
    if not structureData then return end
    
    -- Vérifier si le joueur a accès à l'enclume
    if not self:CanPlayerInteractWithStructure(player, structureId) then
        self:SendNotification(player, "Vous n'avez pas accès à cette enclume", "error")
        return
    end
    
    -- Ouvrir l'interface de forge pour le joueur
    if self.remoteEvents.OpenCraftingStation then
        self.remoteEvents.OpenCraftingStation:FireClient(player, "forging", structureId)
    else
        self:SendNotification(player, "Ouverture de l'interface de forge", "info")
    end
end

-- Vérifier si un joueur peut interagir avec une structure
function BuildingService:CanPlayerInteractWithStructure(player, structureId)
    local userId = player.UserId
    local structureData = self.structuresById[structureId]
    
    if not structureData then return false end
    
    -- Le propriétaire peut toujours interagir avec sa structure
    if structureData.owner == userId then
        return true
    end
    
    -- Vérifier si le joueur est dans la même tribu que le propriétaire
    if self.tribeService then
        local playerTribeId = self.tribeService:GetPlayerTribeId(player)
        local ownerPlayer = Players:GetPlayerByUserId(structureData.owner)
        local ownerTribeId = ownerPlayer and self.tribeService:GetPlayerTribeId(ownerPlayer) or nil
        
        -- Si les deux joueurs sont dans la même tribu, permettre l'interaction
        if playerTribeId and ownerTribeId and playerTribeId == ownerTribeId then
            return true
        end
    end
    
    -- Par défaut, refuser l'accès
    return false
end

-- Vérifier si un bâtiment est interactif
function BuildingService:IsInteractiveBuilding(buildingType)
    -- Liste des bâtiments interactifs
    local interactiveTypes = {
        ["wooden_bed"] = true,
        ["campfire"] = true,
        ["furnace"] = true,
        ["anvil"] = true,
        ["wooden_door"] = true, -- Les portes sont interactives (ouverture/fermeture)
        ["wooden_chest"] = true -- Coffres pour stockage
    }
    
    return interactiveTypes[buildingType] or false
end

-- Détruire une structure
function BuildingService:DestroyStructure(structureId, byPlayer)
    local structureData = self.structuresById[structureId]
    if not structureData then return false, "Structure introuvable" end
    
    -- Vérifier si le joueur a le droit de détruire cette structure
    if byPlayer then
        if not self:CanPlayerModifyStructure(byPlayer, structureId) then
            self:SendNotification(byPlayer, "Vous n'avez pas le droit de détruire cette structure", "error")
            return false, "Permissions insuffisantes"
        end
    end
    
    -- Récupérer l'instance de la structure
    local structureInstance = structureData.instance
    
    -- Retourner une partie des matériaux au joueur qui détruit (si c'est un joueur)
    if byPlayer and self.inventoryService then
        local itemId = structureData.type
        local refundAmount = 1 -- Par défaut, retourner 1 unité
        
        -- Ajouter l'objet à l'inventaire du joueur
        self.inventoryService:AddItemToInventory(byPlayer, itemId, refundAmount)
        self:SendNotification(byPlayer, "Vous avez récupéré " .. refundAmount .. "x " .. (ItemTypes[itemId] and ItemTypes[itemId].name or itemId), "success")
    end
    
    -- Détruire l'instance physique
    if structureInstance then
        structureInstance:Destroy()
    end
    
    -- Supprimer les références à la structure
    if structureData.owner and self.playerStructures[structureData.owner] then
        self.playerStructures[structureData.owner][structureId] = nil
    end
    
    self.structuresById[structureId] = nil
    
    -- Informer les joueurs proches
    if structureData.position and byPlayer then
        self:NotifyNearbyPlayers(structureData.position, byPlayer.Name .. " a détruit " .. (ItemTypes[structureData.type] and ItemTypes[structureData.type].name or structureData.type), 30)
    end
    
    return true, "Structure détruite avec succès"
end

-- Vérifier si un joueur peut modifier une structure (détruire, réparer, etc.)
function BuildingService:CanPlayerModifyStructure(player, structureId)
    local userId = player.UserId
    local structureData = self.structuresById[structureId]
    
    if not structureData then return false end
    
    -- Le propriétaire peut toujours modifier sa structure
    if structureData.owner == userId then
        return true
    end
    
    -- Vérifier si le joueur a des permissions via la tribu
    if self.tribeService then
        local playerTribeId = self.tribeService:GetPlayerTribeId(player)
        local ownerPlayer = Players:GetPlayerByUserId(structureData.owner)
        local ownerTribeId = ownerPlayer and self.tribeService:GetPlayerTribeId(ownerPlayer) or nil
        
        -- Si les deux joueurs sont dans la même tribu, vérifier le rôle du joueur
        if playerTribeId and ownerTribeId and playerTribeId == ownerTribeId then
            local playerRole = self.tribeService:GetPlayerRole(player)
            -- Seuls les leaders et les anciens peuvent modifier les structures des autres
            if playerRole == "leader" or playerRole == "elder" then
                return true
            end
        end
    end
    
    -- Par défaut, refuser l'accès
    return false
end

-- Réparer une structure
function BuildingService:RepairStructure(player, structureId)
    local structureData = self.structuresById[structureId]
    if not structureData then 
        self:SendNotification(player, "Structure introuvable", "error")
        return false 
    end
    
    -- Vérifier si le joueur a le droit de réparer cette structure
    if not self:CanPlayerModifyStructure(player, structureId) then
        self:SendNotification(player, "Vous n'avez pas le droit de réparer cette structure", "error")
        return false
    end
    
    -- Vérifier si la structure a besoin de réparation
    local buildingType = structureData.type
    local maxDurability = self.buildingTypes[buildingType] and self.buildingTypes[buildingType].durability or 100
    
    if structureData.durability >= maxDurability then
        self:SendNotification(player, "Cette structure n'a pas besoin de réparation", "info")
        return false
    end
    
    -- Coût de réparation (matériaux nécessaires)
    local repairCost = {
        [buildingType] = 1 -- Par défaut, 1 unité du même type
    }
    
    -- Vérifier si le joueur a les matériaux nécessaires
    for itemId, amount in pairs(repairCost) do
        if not self.inventoryService:HasItemInInventory(player, itemId, amount) then
            self:SendNotification(player, "Matériaux insuffisants pour la réparation", "error")
            return false
        end
    end
    
    -- Retirer les matériaux
    for itemId, amount in pairs(repairCost) do
        self.inventoryService:RemoveItemFromInventory(player, itemId, amount)
    end
    
    -- Effectuer la réparation
    structureData.durability = maxDurability
    
    -- Mettre à jour l'apparence si nécessaire
    if structureData.instance and structureData.instance.PrimaryPart then
        structureData.instance.PrimaryPart.Color = Color3.fromRGB(255, 255, 255) -- Réinitialiser la couleur
    end
    
    self:SendNotification(player, "Structure réparée avec succès", "success")
    return true
end

-- Vérifier les structures endommagées qui pourraient s'effondrer
function BuildingService:CheckDamagedStructures()
    local currentTime = os.time()
    
    for structureId, structureData in pairs(self.structuresById) do
        -- Appliquer la dégradation naturelle (optionnel - peut être désactivé)
        local enableNaturalDecay = true -- Peut être configuré dans GameSettings
        
        if enableNaturalDecay then
            -- Calculer l'âge de la structure en jours
            local ageInSeconds = currentTime - structureData.creationTime
            local ageInDays = ageInSeconds / (24 * 60 * 60)
            
            -- Vérifier si un jour s'est écoulé depuis la dernière dégradation
            if not structureData.lastDecayCheck then
                structureData.lastDecayCheck = structureData.creationTime
            end
            
            local timeSinceLastDecay = currentTime - structureData.lastDecayCheck
            
            -- Appliquer la dégradation toutes les 24 heures
            if timeSinceLastDecay >= (24 * 60 * 60) then
                -- Calculer la dégradation selon le type de matériau
                local decayRate = 1 -- Par défaut, 1 point par jour
                
                if structureData.type:find("wooden") then
                    decayRate = 2 -- Le bois se dégrade plus vite
                elseif structureData.type:find("stone") then
                    decayRate = 0.5 -- La pierre se dégrade plus lentement
                elseif structureData.type:find("brick") then
                    decayRate = 0.3 -- La brique est très résistante
                end
                
                -- Appliquer la dégradation
                self:DamageStructure(structureId, decayRate, "dégradation naturelle")
                
                -- Mettre à jour le temps de dernière vérification
                structureData.lastDecayCheck = currentTime
                
                -- Avertir le propriétaire si la structure a besoin d'entretien
                if structureData.durability < 50 then
                    local owner = Players:GetPlayerByUserId(structureData.owner)
                    if owner then
                        local structureName = ItemTypes[structureData.type] and ItemTypes[structureData.type].name or structureData.type
                        self:SendNotification(owner, structureName .. " a besoin d'entretien (" .. math.floor(structureData.durability) .. "% durabilité)", "warning")
                    end
                end
            end
        end
        
        -- Si la durabilité est nulle ou négative, la structure s'effondre
        if structureData.durability <= 0 then
            self:DestroyStructure(structureId)
        elseif structureData.durability < 30 then
            -- Avertir le propriétaire si la structure est très endommagée
            local owner = Players:GetPlayerByUserId(structureData.owner)
            if owner then
                self:SendNotification(owner, "Votre structure " .. (ItemTypes[structureData.type] and ItemTypes[structureData.type].name or structureData.type) .. " est gravement endommagée", "warning")
            end
        end
    end
end

-- Endommager une structure (par le temps, des attaques, etc.)
function BuildingService:DamageStructure(structureId, amount, cause)
    local structureData = self.structuresById[structureId]
    if not structureData then return false end
    
    -- Réduire la durabilité
    structureData.durability = math.max(0, structureData.durability - amount)
    
    -- Si la durabilité atteint 0, la structure sera détruite lors de la prochaine vérification
    if structureData.durability <= 0 then
        -- Destruction immédiate si configuré ainsi
        self:DestroyStructure(structureId)
        return true
    elseif structureData.durability < 30 then
        -- Changer l'apparence pour montrer qu'elle est endommagée
        if structureData.instance and structureData.instance.PrimaryPart then
            structureData.instance.PrimaryPart.Color = Color3.fromRGB(150, 150, 150) -- Grisé pour indiquer des dommages
        end
    end
    
    return true
end

-- Notifier les joueurs proches d'une position
function BuildingService:NotifyNearbyPlayers(position, message, radius)
    radius = radius or 50
    
    for _, player in ipairs(Players:GetPlayers()) do
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local distance = (character.HumanoidRootPart.Position - position).Magnitude
            
            if distance <= radius then
                self:SendNotification(player, message, "info")
            end
        end
    end
end

-- Envoyer une notification à un joueur
function BuildingService:SendNotification(player, message, messageType)
    if self.remoteEvents.Notification then
        self.remoteEvents.Notification:FireClient(player, message, messageType or "info")
    else
        -- Fallback si le RemoteEvent n'est pas disponible
        print("Notification pour " .. player.Name .. ": " .. message)
    end
end

-- Initialiser le service
function BuildingService:Start(services)
    print("BuildingService: Démarrage...")
    
    -- Récupérer les références aux autres services
    self.inventoryService = services.InventoryService
    self.tribeService = services.TribeService
    self.survivalService = services.SurvivalService
    
    if not self.inventoryService then
        warn("BuildingService: InventoryService non disponible. Certaines fonctionnalités seront limitées.")
    end
    
    -- Récupérer les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            BuildingStart = Events:FindFirstChild("BuildingStart"),
            BuildingPlacement = Events:FindFirstChild("BuildingPlacement"),
            Notification = Events:FindFirstChild("Notification"),
            PlayerAction = Events:FindFirstChild("PlayerAction")
        }
        
        -- Créer le RemoteEvent pour les stations de crafting s'il n'existe pas
        if not Events:FindFirstChild("OpenCraftingStation") then
            local openCraftingStation = Instance.new("RemoteEvent")
            openCraftingStation.Name = "OpenCraftingStation"
            openCraftingStation.Parent = Events
            self.remoteEvents.OpenCraftingStation = openCraftingStation
            print("BuildingService: RemoteEvent OpenCraftingStation créé")
        else
            self.remoteEvents.OpenCraftingStation = Events:FindFirstChild("OpenCraftingStation")
        end
    else
        warn("BuildingService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Initialiser les structures pour les joueurs déjà connectés
    for _, player in ipairs(Players:GetPlayers()) do
        self:InitializePlayerStructures(player)
    end
    
    -- Gérer les nouveaux joueurs
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerStructures(player)
    end)
    
    -- Gérer les déconnexions de joueurs
    Players.PlayerRemoving:Connect(function(player)
        local userId = player.UserId
        
        -- Annuler le mode construction si actif
        if self.buildingMode[userId] then
            self:CancelPlacement(player)
        end
        
        -- Sauvegarde des structures du joueur (dans une implémentation réelle)
        -- self:SavePlayerStructures(player)
    end)
    
    -- Démarrer la vérification périodique des structures endommagées
    spawn(function()
        while true do
            wait(60) -- Vérifier toutes les minutes
            pcall(function()
                self:CheckDamagedStructures()
            end)
        end
    end)
    
    print("BuildingService: Démarré avec succès")
    return self
end

return BuildingService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="39">
          <Properties>
            <string name="Name">CombatService</string>
            <string name="Source"><![CDATA[-- src/server/services/CombatService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemTypes = require(Shared.constants.ItemTypes)
local GameSettings = require(Shared.constants.GameSettings)

local CombatService = {}
CombatService.__index = CombatService

-- Créer une instance du service
function CombatService.new()
    local self = setmetatable({}, CombatService)
    
    -- Données de combat des joueurs
    self.playerCombatData = {}  -- [userId] = {health, maxHealth, armor, etc.}
    
    -- Suivi des attaques pour éviter le spam
    self.lastAttackTime = {}  -- [userId] = timestamp
    self.attackCooldown = 0.5  -- 0.5 seconde entre chaque attaque
    
    -- Suivi des projectiles
    self.activeProjectiles = {}
    self.nextProjectileId = 1
    
    -- Références aux services
    self.inventoryService = nil
    self.playerService = nil
    self.tribeService = nil
    self.buildingService = nil
    self.survivalService = nil
    
    -- RemoteEvents
    self.remoteEvents = {}
    
    return self
end

-- Initialiser les données de combat d'un joueur
function CombatService:InitializePlayerCombat(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    
    if self.playerCombatData[userId] then return end
    
    -- Créer les données de combat
    self.playerCombatData[userId] = {
        maxHealth = 100,
        currentHealth = 100,
        armor = 0,  -- Points d'armure
        isInCombat = false,
        lastCombatTime = 0,
        combatTarget = nil,
        damageDealt = 0,
        damageTaken = 0,
        kills = 0,
        deaths = 0,
        statusEffects = {}, -- Effets de statut actifs
        isBlocking = false, -- État de blocage
        lastBlockTime = 0, -- Dernier blocage
        comboCount = 0, -- Compteur de combo
        lastAttackTime = 0 -- Dernière attaque pour combos
    }
    
    -- Configurer le personnage si disponible
    if player.Character then
        self:SetupCharacterCombat(player.Character)
    end
    
    -- Mettre à jour le client
    self:UpdateClientCombatData(player)
    
    print("CombatService: Combat initialisé pour " .. player.Name)
end

-- Configurer le combat pour un personnage
function CombatService:SetupCharacterCombat(character)
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Désactiver la santé par défaut de Roblox (on gère notre propre système)
    humanoid.MaxHealth = 100
    humanoid.Health = 100
    
    -- Connecter l'événement de dégâts
    humanoid.HealthChanged:Connect(function(health)
        -- On ignore les changements de santé automatiques
        -- Notre système gère tout via TakeDamage
    end)
end

-- Attaquer un joueur ou une entité
function CombatService:AttackTarget(attacker, target, attackType)
    if not attacker or not attacker:IsA("Player") then return false end
    if not target or not target:IsA("Player") then return false end
    
    local attackerId = attacker.UserId
    local targetId = target.UserId
    
    -- Vérifier le cooldown d'attaque
    local currentTime = tick()
    local lastAttack = self.lastAttackTime[attackerId] or 0
    
    if currentTime - lastAttack < self.attackCooldown then
        return false, "Attaque trop rapide"
    end
    
    -- Vérifier que l'attaquant n'est pas lui-même
    if attackerId == targetId then
        return false, "Vous ne pouvez pas vous attaquer vous-même"
    end
    
    -- Vérifier que les deux joueurs sont vivants
    if not self.playerCombatData[attackerId] or not self.playerCombatData[targetId] then
        return false, "Données de combat invalides"
    end
    
    -- Vérifier la distance
    local attackerChar = attacker.Character
    local targetChar = target.Character
    
    if not attackerChar or not targetChar then
        return false, "Personnage invalide"
    end
    
    local attackerRoot = attackerChar:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    
    if not attackerRoot or not targetRoot then
        return false, "Position invalide"
    end
    
    local distance = (attackerRoot.Position - targetRoot.Position).Magnitude
    
    -- Obtenir l'arme équipée
    local weapon = self:GetEquippedWeapon(attacker)
    local weaponData = weapon and ItemTypes[weapon.id]
    
    -- Déterminer la portée d'attaque
    local attackRange = 5  -- Portée par défaut (mêlée)
    
    if weaponData then
        if weaponData.toolType == "bow" then
            attackRange = 50  -- Portée pour arc
        elseif weaponData.toolType == "weapon" then
            attackRange = 7  -- Portée pour armes de mêlée
        end
    end
    
    if distance > attackRange then
        self:SendNotification(attacker, "Cible trop éloignée", "warning")
        return false, "Cible trop éloignée"
    end
    
    -- Vérifier si l'un des joueurs est dans une zone de sécurité
    if self:IsInSafeZone(attacker) or self:IsInSafeZone(target) then
        self:SendNotification(attacker, "Combat impossible dans une zone de sécurité", "error")
        return false, "Zone de sécurité"
    end
    
    -- Vérifier si c'est un allié (même tribu) - sauf en duel
    local inDuel = self:ArePlayersInDuel(attacker, target)
    if not inDuel and self.tribeService and self.tribeService:ArePlayersInSameTribe(attacker, target) then
        self:SendNotification(attacker, "Vous ne pouvez pas attaquer un membre de votre tribu", "error")
        return false, "Allié"
    end
    
    -- Calculer les dégâts
    local baseDamage = 5  -- Dégâts à mains nues
    
    if weaponData and weaponData.damage then
        baseDamage = weaponData.damage
    end
    
    -- Appliquer les modificateurs
    local finalDamage = baseDamage
    
    -- Bonus de combo
    local comboMultiplier = self:GetComboMultiplier(attacker)
    finalDamage = finalDamage * comboMultiplier
    
    -- Mettre à jour le combo
    self:UpdateComboCount(attacker)
    
    -- Si c'est une arme à distance (arc), créer un projectile
    if weaponData and weaponData.toolType == "bow" then
        -- Vérifier les munitions
        if weaponData.ammo and self.inventoryService then
            if not self.inventoryService:HasItemInInventory(attacker, weaponData.ammo, 1) then
                self:SendNotification(attacker, "Vous n'avez plus de munitions", "error")
                return false, "Pas de munitions"
            end
            
            -- Retirer une munition
            self.inventoryService:RemoveItemFromInventory(attacker, weaponData.ammo, 1)
            
            -- Créer le projectile
            self:CreateProjectile(attacker, target, finalDamage)
            
            -- Mettre à jour le cooldown
            self.lastAttackTime[attackerId] = currentTime
            
            return true, "Projectile tiré"
        end
    else
        -- Attaque de mêlée directe
        self:DealDamage(attacker, target, finalDamage, "melee")
        
        -- Mettre à jour le cooldown
        self.lastAttackTime[attackerId] = currentTime
        
        return true, "Attaque réussie"
    end
    
    return false, "Erreur d'attaque"
end

-- Créer un projectile (flèche, etc.)
function CombatService:CreateProjectile(attacker, target, damage)
    local attackerChar = attacker.Character
    local targetChar = target.Character
    
    if not attackerChar or not targetChar then return end
    
    local attackerRoot = attackerChar:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    
    if not attackerRoot or not targetRoot then return end
    
    -- Créer le projectile visuel
    local projectile = Instance.new("Part")
    projectile.Name = "Projectile"
    projectile.Size = Vector3.new(0.2, 0.2, 1)
    projectile.Material = Enum.Material.Wood
    projectile.Color = Color3.fromRGB(139, 69, 19)
    projectile.CanCollide = false
    projectile.Anchored = false
    
    -- Position de départ (devant l'attaquant)
    local startPos = attackerRoot.Position + attackerRoot.CFrame.LookVector * 2
    projectile.Position = startPos
    
    -- Orienter vers la cible
    local direction = (targetRoot.Position - startPos).Unit
    projectile.CFrame = CFrame.lookAt(startPos, targetRoot.Position)
    
    -- Ajouter une vélocité
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = direction * 80  -- Vitesse de la flèche
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Parent = projectile
    
    projectile.Parent = Workspace
    
    -- Stocker les données du projectile
    local projectileId = "projectile_" .. self.nextProjectileId
    self.nextProjectileId = self.nextProjectileId + 1
    
    self.activeProjectiles[projectileId] = {
        instance = projectile,
        attacker = attacker,
        damage = damage,
        startTime = tick(),
        hasHit = false
    }
    
    -- Détection de collision
    projectile.Touched:Connect(function(hit)
        local projectileData = self.activeProjectiles[projectileId]
        if not projectileData or projectileData.hasHit then return end
        
        -- Vérifier si c'est un joueur
        local hitPlayer = Players:GetPlayerFromCharacter(hit.Parent)
        
        if hitPlayer and hitPlayer ~= attacker then
            -- Touché!
            projectileData.hasHit = true
            self:DealDamage(attacker, hitPlayer, damage, "ranged")
            
            -- Détruire le projectile
            projectile:Destroy()
            self.activeProjectiles[projectileId] = nil
        elseif hit:IsDescendantOf(Workspace) and not hit:IsDescendantOf(attackerChar) then
            -- Touché un objet du décor
            projectileData.hasHit = true
            projectile:Destroy()
            self.activeProjectiles[projectileId] = nil
        end
    end)
    
    -- Nettoyer après 5 secondes si pas de collision
    Debris:AddItem(projectile, 5)
    
    delay(5, function()
        self.activeProjectiles[projectileId] = nil
    end)
end

-- Infliger des dégâts à un joueur
function CombatService:DealDamage(attacker, victim, damage, damageType)
    if not attacker or not victim then return end
    if not victim:IsA("Player") then return end
    
    local victimId = victim.UserId
    local victimData = self.playerCombatData[victimId]
    
    if not victimData then return end
    
    -- Vérifier si la victime bloque
    if victimData.isBlocking then
        -- Réduire les dégâts de 70% en bloquant
        damage = damage * 0.3
        self:SendNotification(victim, "Attaque bloquée!", "info")
        if attacker and attacker:IsA("Player") then
            self:SendNotification(attacker, "Attaque bloquée par " .. victim.Name, "warning")
        end
    end
    
    -- Vérifier si la victime a paré
    if victimData.parryWindow and tick() <= victimData.parryWindow then
        -- Parade réussie : annuler l'attaque et étourdir l'attaquant
        victimData.parryWindow = nil
        self:SendNotification(victim, "Parade réussie!", "success")
        if attacker and attacker:IsA("Player") then
            self:SendNotification(attacker, "Vous avez été paré!", "error")
            self:ApplyStatusEffect(attacker, "stunned", 2, 1)
        end
        return
    end
    
    -- Calculer les dégâts finaux avec l'armure
    local armorReduction = victimData.armor * 0.5  -- Chaque point d'armure réduit de 0.5 point de dégâts
    local finalDamage = math.max(1, damage - armorReduction)  -- Minimum 1 dégât
    
    -- Appliquer les dégâts
    victimData.currentHealth = math.max(0, victimData.currentHealth - finalDamage)
    victimData.damageTaken = victimData.damageTaken + finalDamage
    victimData.isInCombat = true
    victimData.lastCombatTime = tick()
    
    -- Mettre à jour les statistiques de l'attaquant
    if attacker:IsA("Player") then
        local attackerId = attacker.UserId
        local attackerData = self.playerCombatData[attackerId]
        
        if attackerData then
            attackerData.damageDealt = attackerData.damageDealt + finalDamage
            attackerData.isInCombat = true
            attackerData.lastCombatTime = tick()
            attackerData.combatTarget = victimId
        end
    end
    
    -- Mettre à jour le client de la victime
    self:UpdateClientCombatData(victim)
    
    -- Envoyer un événement de dégâts
    if self.remoteEvents.TakeDamage then
        self.remoteEvents.TakeDamage:FireClient(victim, finalDamage, damageType, attacker.Name)
    end
    
    -- Effet visuel de dégâts
    self:ShowDamageIndicator(victim, finalDamage)
    
    -- Vérifier si le joueur est mort
    if victimData.currentHealth <= 0 then
        self:HandlePlayerDeath(victim, attacker)
    end
end

-- Afficher un indicateur de dégâts
function CombatService:ShowDamageIndicator(player, damage)
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    -- Créer un BillboardGui pour afficher les dégâts
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = humanoidRootPart
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "-" .. math.floor(damage)
    textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.Parent = billboard
    
    -- Animer et détruire
    Debris:AddItem(billboard, 1)
end

-- Attaquer une structure
function CombatService:AttackStructure(attacker, structureId, hitPart)
    if not attacker or not attacker:IsA("Player") then return false end
    if not self.buildingService then return false end
    
    local attackerId = attacker.UserId
    
    -- Vérifier le cooldown d'attaque
    local currentTime = tick()
    local lastAttack = self.lastAttackTime[attackerId] or 0
    
    if currentTime - lastAttack < self.attackCooldown then
        return false, "Attaque trop rapide"
    end
    
    -- Vérifier que la structure existe
    local structureData = self.buildingService.structuresById[structureId]
    if not structureData then
        return false, "Structure introuvable"
    end
    
    -- Vérifier la distance
    local attackerChar = attacker.Character
    if not attackerChar then return false, "Personnage invalide" end
    
    local attackerRoot = attackerChar:FindFirstChild("HumanoidRootPart")
    if not attackerRoot then return false, "Position invalide" end
    
    -- Calculer la distance jusqu'à la structure
    local structurePos = hitPart and hitPart.Position or structureData.position
    if not structurePos then return false, "Position de structure invalide" end
    
    local distance = (attackerRoot.Position - structurePos).Magnitude
    
    -- Obtenir l'arme équipée
    local weapon = self:GetEquippedWeapon(attacker)
    local weaponData = weapon and ItemTypes[weapon.id]
    
    -- Déterminer la portée d'attaque
    local attackRange = 7  -- Portée par défaut (mêlée)
    
    if weaponData then
        if weaponData.toolType == "bow" then
            attackRange = 50  -- Portée pour arc
        elseif weaponData.toolType == "weapon" or weaponData.toolType == "tool" then
            attackRange = 10  -- Portée pour armes/outils de mêlée
        end
    end
    
    if distance > attackRange then
        self:SendNotification(attacker, "Structure trop éloignée", "warning")
        return false, "Structure trop éloignée"
    end
    
    -- Vérifier si le joueur peut endommager cette structure
    -- Le propriétaire peut endommager sa propre structure
    -- Les autres joueurs peuvent attaquer les structures ennemies
    local canDamage = true
    
    if structureData.owner == attackerId then
        -- Le propriétaire peut toujours endommager sa structure (par exemple pour la détruire)
        canDamage = true
    elseif self.tribeService and self.tribeService:ArePlayersInSameTribe then
        -- Vérifier si c'est une structure d'un allié
        local ownerPlayer = Players:GetPlayerByUserId(structureData.owner)
        if ownerPlayer and self.tribeService:ArePlayersInSameTribe(attacker, ownerPlayer) then
            self:SendNotification(attacker, "Vous ne pouvez pas attaquer les structures de votre tribu", "error")
            return false, "Structure alliée"
        end
    end
    
    if not canDamage then
        return false, "Vous ne pouvez pas endommager cette structure"
    end
    
    -- Calculer les dégâts
    local baseDamage = 2  -- Dégâts à mains nues sur structure (réduit)
    
    if weaponData then
        if weaponData.damage then
            baseDamage = weaponData.damage * 0.5  -- Les structures prennent 50% des dégâts d'arme
        end
        if weaponData.toolType == "tool" then
            -- Les outils font plus de dégâts aux structures
            baseDamage = weaponData.damage or 5
        end
    end
    
    -- Appliquer les dégâts à la structure
    local success = self.buildingService:DamageStructure(structureId, baseDamage, "player_attack")
    
    if success then
        -- Mettre à jour le cooldown
        self.lastAttackTime[attackerId] = currentTime
        
        -- Notifier le joueur
        local structureName = ItemTypes[structureData.type] and ItemTypes[structureData.type].name or structureData.type
        self:SendNotification(attacker, string.format("Vous avez endommagé %s (-%.0f durabilité)", structureName, baseDamage), "info")
        
        -- Mettre l'attaquant en combat
        if self.playerCombatData[attackerId] then
            self.playerCombatData[attackerId].isInCombat = true
            self.playerCombatData[attackerId].lastCombatTime = currentTime
            self:UpdateClientCombatData(attacker)
        end
        
        return true, "Structure endommagée"
    end
    
    return false, "Erreur lors de l'endommagement de la structure"
end

-- Gérer la mort d'un joueur en combat
function CombatService:HandlePlayerDeath(victim, killer)
    local victimId = victim.UserId
    local victimData = self.playerCombatData[victimId]
    
    if not victimData then return end
    
    -- Mettre à jour les statistiques
    victimData.deaths = victimData.deaths + 1
    victimData.currentHealth = 0
    
    if killer and killer:IsA("Player") then
        local killerId = killer.UserId
        local killerData = self.playerCombatData[killerId]
        
        if killerData then
            killerData.kills = killerData.kills + 1
        end
        
        -- Notifier le tueur
        self:SendNotification(killer, "Vous avez éliminé " .. victim.Name, "success")
    end
    
    -- Notifier la victime
    self:SendNotification(victim, "Vous avez été éliminé", "error")
    
    -- Appeler le service de joueur pour gérer la mort
    if self.playerService then
        self.playerService:HandlePlayerDeath(victim, "killed")
    end
    
    -- Réinitialiser la santé après respawn
    delay(5, function()
        self:ResetPlayerHealth(victim)
    end)
end

-- Réinitialiser la santé d'un joueur
function CombatService:ResetPlayerHealth(player)
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    
    if not combatData then return end
    
    combatData.currentHealth = combatData.maxHealth
    combatData.isInCombat = false
    combatData.combatTarget = nil
    
    self:UpdateClientCombatData(player)
end

-- Soigner un joueur
function CombatService:HealPlayer(player, amount)
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    
    if not combatData then return false end
    
    local oldHealth = combatData.currentHealth
    combatData.currentHealth = math.min(combatData.maxHealth, combatData.currentHealth + amount)
    
    local actualHealing = combatData.currentHealth - oldHealth
    
    if actualHealing > 0 then
        self:UpdateClientCombatData(player)
        self:SendNotification(player, "+" .. math.floor(actualHealing) .. " PV", "success")
        return true
    end
    
    return false
end

-- Obtenir l'arme équipée d'un joueur
function CombatService:GetEquippedWeapon(player)
    if not self.inventoryService then return nil end
    
    local userId = player.UserId
    local inventory = self.inventoryService.playerInventories[userId]
    
    if not inventory or not inventory.equipped then return nil end
    
    local toolSlot = inventory.equipped["tool"]
    if not toolSlot then return nil end
    
    return inventory.items[toolSlot]
end

-- Calculer l'armure totale d'un joueur
function CombatService:CalculatePlayerArmor(player)
    if not self.inventoryService then return 0 end
    
    local userId = player.UserId
    local inventory = self.inventoryService.playerInventories[userId]
    
    if not inventory or not inventory.equipped then return 0 end
    
    local totalArmor = 0
    
    -- Parcourir tous les équipements
    for slot, itemSlot in pairs(inventory.equipped) do
        local item = inventory.items[itemSlot]
        if item then
            local itemType = ItemTypes[item.id]
            if itemType and itemType.defenseBonus then
                totalArmor = totalArmor + itemType.defenseBonus
            end
        end
    end
    
    return totalArmor
end

-- Mettre à jour régulièrement les données de combat
function CombatService:UpdateCombatStates()
    local currentTime = tick()
    
    for userId, combatData in pairs(self.playerCombatData) do
        local player = Players:GetPlayerByUserId(userId)
        
        -- Mettre à jour les effets de statut
        if player then
            self:UpdateStatusEffects(player)
        end
        
        -- Sortir du combat après 10 secondes sans activité
        if combatData.isInCombat and (currentTime - combatData.lastCombatTime) > 10 then
            combatData.isInCombat = false
            combatData.combatTarget = nil
            
            if player then
                self:UpdateClientCombatData(player)
            end
        end
        
        -- Régénération de santé hors combat (liée à la survie)
        if not combatData.isInCombat and combatData.currentHealth < combatData.maxHealth then
            local regenRate = 0.5 -- Taux de base
            
            -- Modifier selon la survie
            local player = Players:GetPlayerByUserId(userId)
            if player and self.survivalService then
                local survivalData = self.survivalService.playerSurvivalData[userId]
                if survivalData then
                    -- Bonus si bien nourri et hydraté
                    if survivalData.hunger >= 70 and survivalData.thirst >= 70 then
                        regenRate = regenRate * 1.5
                    -- Ralentir si faim < 30%
                    elseif survivalData.hunger < 30 then
                        regenRate = regenRate * 0.3
                    end
                    
                    -- Arrêter si soif critique < 20%
                    if survivalData.thirst < 20 then
                        regenRate = 0
                    end
                    
                    -- Bonus si bien reposé
                    if survivalData.energy >= 80 then
                        regenRate = regenRate * 1.2
                    end
                end
            end
            
            combatData.currentHealth = math.min(combatData.maxHealth, combatData.currentHealth + regenRate)
            
            if player then
                self:UpdateClientCombatData(player)
            end
        end
        
        -- Mettre à jour l'armure
        local player = Players:GetPlayerByUserId(userId)
        if player then
            combatData.armor = self:CalculatePlayerArmor(player)
        end
    end
end

-- Mettre à jour les données de combat pour le client
function CombatService:UpdateClientCombatData(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    
    if not combatData then return end
    
    -- Envoyer les données au client
    if self.remoteEvents.UpdateHealth then
        self.remoteEvents.UpdateHealth:FireClient(player, {
            currentHealth = combatData.currentHealth,
            maxHealth = combatData.maxHealth,
            armor = combatData.armor,
            isInCombat = combatData.isInCombat
        })
    end
end

-- Système d'effets de statut
function CombatService:ApplyStatusEffect(player, effectType, duration, intensity)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return false end
    
    -- Créer l'effet
    local effect = {
        type = effectType,
        startTime = tick(),
        duration = duration,
        intensity = intensity or 1,
        lastTick = tick()
    }
    
    table.insert(combatData.statusEffects, effect)
    
    -- Notifier le joueur
    local effectNames = {
        poison = "Empoisonnement",
        bleeding = "Saignement",
        burning = "Brûlure",
        frozen = "Gelé",
        stunned = "Étourdi"
    }
    
    local effectName = effectNames[effectType] or effectType
    self:SendNotification(player, "Vous subissez: " .. effectName, "warning")
    
    return true
end

-- Mettre à jour les effets de statut
function CombatService:UpdateStatusEffects(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return end
    
    local currentTime = tick()
    local effectsToRemove = {}
    
    for i, effect in ipairs(combatData.statusEffects) do
        -- Vérifier si l'effet a expiré
        if currentTime - effect.startTime >= effect.duration then
            table.insert(effectsToRemove, i)
        else
            -- Appliquer l'effet périodiquement (toutes les secondes)
            if currentTime - effect.lastTick >= 1 then
                effect.lastTick = currentTime
                
                if effect.type == "poison" then
                    -- Poison : 2 dégâts par seconde
                    self:DealDamage(nil, player, 2 * effect.intensity, "poison")
                elseif effect.type == "bleeding" then
                    -- Saignement : 3 dégâts par seconde
                    self:DealDamage(nil, player, 3 * effect.intensity, "bleeding")
                elseif effect.type == "burning" then
                    -- Brûlure : 4 dégâts par seconde
                    self:DealDamage(nil, player, 4 * effect.intensity, "burning")
                elseif effect.type == "frozen" then
                    -- Gelé : ralentissement
                    local character = player.Character
                    if character and character:FindFirstChild("Humanoid") then
                        character.Humanoid.WalkSpeed = 8
                    end
                elseif effect.type == "stunned" then
                    -- Étourdi : impossible de bouger
                    local character = player.Character
                    if character and character:FindFirstChild("Humanoid") then
                        character.Humanoid.WalkSpeed = 0
                    end
                end
            end
        end
    end
    
    -- Retirer les effets expirés
    for i = #effectsToRemove, 1, -1 do
        local effectIndex = effectsToRemove[i]
        local removedEffect = table.remove(combatData.statusEffects, effectIndex)
        
        -- Réinitialiser la vitesse si nécessaire
        if removedEffect.type == "frozen" or removedEffect.type == "stunned" then
            local character = player.Character
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.WalkSpeed = 16
            end
        end
    end
end

-- Système de blocage
function CombatService:StartBlocking(player)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return false end
    
    -- Vérifier le cooldown de blocage (2 secondes)
    local currentTime = tick()
    if currentTime - combatData.lastBlockTime < 2 then
        self:SendNotification(player, "Blocage en cooldown", "warning")
        return false
    end
    
    combatData.isBlocking = true
    combatData.lastBlockTime = currentTime
    
    -- Ralentir le joueur pendant le blocage
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.WalkSpeed = 8
    end
    
    self:SendNotification(player, "Blocage activé", "info")
    
    return true
end

-- Arrêter le blocage
function CombatService:StopBlocking(player)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return false end
    
    combatData.isBlocking = false
    
    -- Restaurer la vitesse normale
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.WalkSpeed = 16
    end
    
    return true
end

-- Système de parade (parry)
function CombatService:AttemptParry(player)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return false end
    
    -- La parade doit être activée juste avant de recevoir une attaque
    -- On marque un temps de parade de 0.5 secondes
    combatData.parryWindow = tick() + 0.5
    
    self:SendNotification(player, "Tentative de parade", "info")
    
    return true
end

-- Système de combos
function CombatService:UpdateComboCount(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return end
    
    local currentTime = tick()
    
    -- Réinitialiser le combo si plus de 3 secondes depuis la dernière attaque
    if currentTime - combatData.lastAttackTime > 3 then
        combatData.comboCount = 0
    end
    
    combatData.lastAttackTime = currentTime
    combatData.comboCount = combatData.comboCount + 1
    
    -- Bonus de dégâts pour les combos
    if combatData.comboCount >= 3 then
        self:SendNotification(player, "Combo x" .. combatData.comboCount .. "!", "success")
    end
end

-- Obtenir le multiplicateur de combo
function CombatService:GetComboMultiplier(player)
    if not player or not player:IsA("Player") then return 1 end
    
    local userId = player.UserId
    local combatData = self.playerCombatData[userId]
    if not combatData then return 1 end
    
    -- Bonus de 10% par attaque dans le combo (max 50%)
    local bonus = math.min(0.5, (combatData.comboCount - 1) * 0.1)
    return 1 + bonus
end

-- Zones de sécurité (safe zones)
function CombatService:IsInSafeZone(player)
    if not player or not player:IsA("Player") then return false end
    
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
    
    local position = character.HumanoidRootPart.Position
    
    -- Vérifier les zones de sécurité dans le workspace
    local safeZonesFolder = game:GetService("Workspace"):FindFirstChild("SafeZones")
    if safeZonesFolder then
        for _, zone in ipairs(safeZonesFolder:GetChildren()) do
            if zone:IsA("BasePart") or (zone:IsA("Model") and zone.PrimaryPart) then
                local zonePart = zone:IsA("BasePart") and zone or zone.PrimaryPart
                local distance = (zonePart.Position - position).Magnitude
                local radius = zone:GetAttribute("SafeRadius") or zonePart.Size.Magnitude
                
                if distance <= radius then
                    return true
                end
            end
        end
    end
    
    -- Vérifier si le joueur est dans un spawn point
    local spawnLocations = game:GetService("Workspace"):FindFirstChild("SpawnLocations")
    if spawnLocations then
        for _, spawn in ipairs(spawnLocations:GetChildren()) do
            if spawn:IsA("SpawnLocation") then
                local distance = (spawn.Position - position).Magnitude
                if distance <= 20 then -- Rayon de 20 studs autour du spawn
                    return true
                end
            end
        end
    end
    
    return false
end

-- Système de duels
function CombatService:ChallengeToDuel(challenger, target)
    if not challenger or not target then return false end
    if not challenger:IsA("Player") or not target:IsA("Player") then return false end
    
    -- Ne pas permettre de duel contre soi-même
    if challenger.UserId == target.UserId then
        self:SendNotification(challenger, "Vous ne pouvez pas vous défier vous-même", "error")
        return false
    end
    
    -- Vérifier que les deux joueurs ne sont pas déjà en duel
    if self.activeDuels then
        for _, duel in pairs(self.activeDuels) do
            if duel.player1 == challenger.UserId or duel.player2 == challenger.UserId then
                self:SendNotification(challenger, "Vous êtes déjà en duel", "error")
                return false
            end
            if duel.player1 == target.UserId or duel.player2 == target.UserId then
                self:SendNotification(challenger, target.Name .. " est déjà en duel", "error")
                return false
            end
        end
    else
        self.activeDuels = {}
        self.duelChallenges = {}
        self.nextDuelId = 1
    end
    
    -- Créer une invitation de duel
    local challengeId = "challenge_" .. challenger.UserId .. "_" .. target.UserId
    
    self.duelChallenges[challengeId] = {
        challenger = challenger.UserId,
        target = target.UserId,
        timestamp = tick()
    }
    
    -- Notifier les joueurs
    self:SendNotification(challenger, "Invitation de duel envoyée à " .. target.Name, "info")
    self:SendNotification(target, challenger.Name .. " vous défie en duel! Acceptez ou refusez.", "warning")
    
    -- Auto-expiration après 30 secondes
    delay(30, function()
        if self.duelChallenges[challengeId] then
            self.duelChallenges[challengeId] = nil
            self:SendNotification(challenger, "L'invitation de duel a expiré", "info")
        end
    end)
    
    return true
end

-- Accepter un duel
function CombatService:AcceptDuel(target, challengerId)
    if not target or not target:IsA("Player") then return false end
    
    local challengeId = "challenge_" .. challengerId .. "_" .. target.UserId
    local challenge = self.duelChallenges[challengeId]
    
    if not challenge then
        self:SendNotification(target, "Aucune invitation de duel trouvée", "error")
        return false
    end
    
    local challenger = Players:GetPlayerByUserId(challengerId)
    if not challenger then
        self:SendNotification(target, "Le challenger n'est plus connecté", "error")
        self.duelChallenges[challengeId] = nil
        return false
    end
    
    -- Créer le duel
    local duelId = "duel_" .. self.nextDuelId
    self.nextDuelId = self.nextDuelId + 1
    
    self.activeDuels[duelId] = {
        player1 = challengerId,
        player2 = target.UserId,
        startTime = tick(),
        winner = nil
    }
    
    -- Retirer l'invitation
    self.duelChallenges[challengeId] = nil
    
    -- Notifier les joueurs
    self:SendNotification(challenger, "Duel accepté! Combat contre " .. target.Name, "success")
    self:SendNotification(target, "Duel commencé contre " .. challenger.Name, "success")
    
    -- Téléporter les joueurs dans une arène de duel (optionnel)
    -- Pour l'instant, ils se battent là où ils sont
    
    return true
end

-- Refuser un duel
function CombatService:DeclineDuel(target, challengerId)
    if not target or not target:IsA("Player") then return false end
    
    local challengeId = "challenge_" .. challengerId .. "_" .. target.UserId
    local challenge = self.duelChallenges[challengeId]
    
    if not challenge then
        return false
    end
    
    local challenger = Players:GetPlayerByUserId(challengerId)
    if challenger then
        self:SendNotification(challenger, target.Name .. " a refusé votre duel", "warning")
    end
    
    self:SendNotification(target, "Vous avez refusé le duel", "info")
    self.duelChallenges[challengeId] = nil
    
    return true
end

-- Vérifier si deux joueurs sont en duel
function CombatService:ArePlayersInDuel(player1, player2)
    if not self.activeDuels then return false end
    
    local userId1 = player1.UserId
    local userId2 = player2.UserId
    
    for _, duel in pairs(self.activeDuels) do
        if (duel.player1 == userId1 and duel.player2 == userId2) or
           (duel.player1 == userId2 and duel.player2 == userId1) then
            return true, duel
        end
    end
    
    return false
end

-- Terminer un duel
function CombatService:EndDuel(duelId, winnerId)
    local duel = self.activeDuels[duelId]
    if not duel then return false end
    
    duel.winner = winnerId
    duel.endTime = tick()
    
    local winner = Players:GetPlayerByUserId(winnerId)
    local loserId = (duel.player1 == winnerId) and duel.player2 or duel.player1
    local loser = Players:GetPlayerByUserId(loserId)
    
    if winner then
        self:SendNotification(winner, "Vous avez gagné le duel!", "success")
    end
    
    if loser then
        self:SendNotification(loser, "Vous avez perdu le duel", "error")
    end
    
    -- Retirer le duel actif
    self.activeDuels[duelId] = nil
    
    return true
end

-- Envoyer une notification
function CombatService:SendNotification(player, message, messageType)
    if self.remoteEvents.Notification then
        self.remoteEvents.Notification:FireClient(player, message, messageType or "info")
    else
        print("Notification pour " .. player.Name .. ": " .. message)
    end
end

-- Gérer la déconnexion d'un joueur
function CombatService:HandlePlayerRemoving(player)
    local userId = player.UserId
    
    if self.playerCombatData[userId] then
        -- Sauvegarder les statistiques de combat si nécessaire
        self.playerCombatData[userId] = nil
    end
    
    self.lastAttackTime[userId] = nil
end

-- Démarrer le service
function CombatService:Start(services)
    print("CombatService: Démarrage...")
    
    -- Récupérer les références aux autres services
    self.inventoryService = services.InventoryService
    self.playerService = services.PlayerService
    self.tribeService = services.TribeService
    self.buildingService = services.BuildingService
    self.survivalService = services.SurvivalService
    
    -- Récupérer les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            AttackPlayer = Events:FindFirstChild("AttackPlayer"),
            AttackStructure = Events:FindFirstChild("AttackStructure"),
            TakeDamage = Events:FindFirstChild("TakeDamage"),
            UpdateHealth = Events:FindFirstChild("UpdateHealth"),
            EquipWeapon = Events:FindFirstChild("EquipWeapon"),
            Notification = Events:FindFirstChild("Notification")
        }
        
        -- Créer l'événement AttackStructure s'il n'existe pas
        if not self.remoteEvents.AttackStructure then
            local attackStructureEvent = Instance.new("RemoteEvent")
            attackStructureEvent.Name = "AttackStructure"
            attackStructureEvent.Parent = Events
            self.remoteEvents.AttackStructure = attackStructureEvent
            print("CombatService: RemoteEvent AttackStructure créé")
        end
        
        -- Connecter les événements
        if self.remoteEvents.AttackPlayer then
            self.remoteEvents.AttackPlayer.OnServerEvent:Connect(function(player, target, attackType)
                self:AttackTarget(player, target, attackType)
            end)
        end
        
        if self.remoteEvents.AttackStructure then
            self.remoteEvents.AttackStructure.OnServerEvent:Connect(function(player, structureId, hitPart)
                self:AttackStructure(player, structureId, hitPart)
            end)
        end
    else
        warn("CombatService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Initialiser les joueurs existants
    for _, player in pairs(Players:GetPlayers()) do
        self:InitializePlayerCombat(player)
    end
    
    -- Gérer les nouveaux joueurs
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerCombat(player)
        
        player.CharacterAdded:Connect(function(character)
            self:SetupCharacterCombat(character)
            self:ResetPlayerHealth(player)
        end)
    end)
    
    -- Gérer les déconnexions
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    -- Démarrer la boucle de mise à jour
    spawn(function()
        while true do
            wait(1)  -- Mettre à jour chaque seconde
            pcall(function()
                self:UpdateCombatStates()
            end)
        end
    end)
    
    print("CombatService: Démarré avec succès")
    return self
end

return CombatService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="40">
          <Properties>
            <string name="Name">CraftingService</string>
            <string name="Source"><![CDATA[-- src/server/services/CraftingService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Références aux ressources partagées
local Shared = ReplicatedStorage:FindFirstChild("Shared")
if not Shared then
    error("Dossier Shared non trouvé dans ReplicatedStorage")
    return nil
end

local CraftingRecipes = require(Shared.constants.CraftingRecipes)

local CraftingService = {}
CraftingService.__index = CraftingService

-- Créer une instance du service
function CraftingService.new()
    local self = setmetatable({}, CraftingService)
    
    -- Recettes débloquées par niveau technologique
    self.unlockedTechLevels = {
        ["stone"] = true,       -- Niveau initial: Pierre
        ["wood"] = true,        -- Bois (débloqué au début)
        ["bronze"] = false,     -- Bronze (à débloquer)
        ["iron"] = false,       -- Fer (à débloquer)
        ["gold"] = false        -- Or (à débloquer)
    }
    
    -- Recettes débloquées pour chaque joueur
    self.playerUnlockedRecipes = {}
    
    -- Références aux autres services (seront injectées via Start)
    self.inventoryService = nil
    
    -- RemoteEvents (seront référencés dans Start)
    self.remoteEvents = {}
    
    return self
end

-- Initialiser les recettes débloquées pour un joueur
function CraftingService:InitializePlayerRecipes(player)
    local userId = player.UserId
    if self.playerUnlockedRecipes[userId] then return end
    
    -- Initialiser avec les recettes du niveau technologique de base
    self.playerUnlockedRecipes[userId] = {}
    
    -- Débloquer les recettes initiales
    for recipeId, recipe in pairs(CraftingRecipes) do
        if self.unlockedTechLevels[recipe.techLevel] then
            self.playerUnlockedRecipes[userId][recipeId] = true
        end
    end
    
    -- Mettre à jour le client avec les recettes débloquées
    self:UpdateClientRecipes(player)
end

-- Débloquer un niveau technologique (pour tous les joueurs)
function CraftingService:UnlockTechLevel(techLevel)
    if not self.unlockedTechLevels[techLevel] then
        self.unlockedTechLevels[techLevel] = true
        
        -- Débloquer les recettes associées pour tous les joueurs
        for userId, playerRecipes in pairs(self.playerUnlockedRecipes) do
            for recipeId, recipe in pairs(CraftingRecipes) do
                if recipe.techLevel == techLevel then
                    playerRecipes[recipeId] = true
                end
            end
            
            -- Mettre à jour le client
            local player = Players:GetPlayerByUserId(userId)
            if player then
                self:UpdateClientRecipes(player)
            end
        end
        
        -- Journal de débogage
        print("CraftingService: Niveau technologique débloqué - " .. techLevel)
        return true
    end
    
    return false
end

-- Débloquer une recette spécifique pour un joueur
function CraftingService:UnlockRecipeForPlayer(player, recipeId)
    local userId = player.UserId
    if not self.playerUnlockedRecipes[userId] then
        self:InitializePlayerRecipes(player)
    end
    
    if CraftingRecipes[recipeId] and not self.playerUnlockedRecipes[userId][recipeId] then
        self.playerUnlockedRecipes[userId][recipeId] = true
        self:UpdateClientRecipes(player)
        
        -- Journal de débogage
        print("CraftingService: Recette débloquée pour " .. player.Name .. " - " .. recipeId)
        return true
    end
    
    return false
end

-- Vérifier si un joueur a les ressources nécessaires pour un craft
function CraftingService:HasResourcesForCraft(player, recipeId)
    if not self.inventoryService then
        warn("CraftingService: InventoryService non initialisé")
        return false
    end
    
    local recipe = CraftingRecipes[recipeId]
    if not recipe then 
        warn("CraftingService: Recette invalide - " .. tostring(recipeId))
        return false 
    end
    
    -- Vérifier chaque ingrédient requis
    for itemId, requiredQuantity in pairs(recipe.ingredients) do
        local hasEnough = self.inventoryService:HasItemInInventory(player, itemId, requiredQuantity)
        
        if not hasEnough then
            return false
        end
    end
    
    return true
end

-- Fabriquer un objet
function CraftingService:CraftItem(player, recipeId)
    local userId = player.UserId
    
    -- Vérification de sécurité
    if not player or not player:IsA("Player") or not recipeId then
        return false, "Paramètres invalides"
    end
    
    local recipe = CraftingRecipes[recipeId]
    
    -- Vérifier si la recette existe et est débloquée
    if not recipe then
        return false, "Recette invalide"
    end
    
    if not self.playerUnlockedRecipes[userId] or not self.playerUnlockedRecipes[userId][recipeId] then
        return false, "Recette non débloquée"
    end
    
    -- Vérifier si nous avons accès au service d'inventaire
    if not self.inventoryService then
        warn("CraftingService: InventoryService non disponible")
        return false, "Service temporairement indisponible"
    end
    
    -- Vérifier si le joueur a les ressources nécessaires
    if not self:HasResourcesForCraft(player, recipeId) then
        return false, "Ressources insuffisantes"
    end
    
    -- Vérifier si une station est requise
    if recipe.requiredStation then
        -- Vérifier si le joueur est près d'une station appropriée
        -- Cette vérification serait plus complexe dans une implémentation complète
        local hasStation = true -- Temporairement mis à true pour simplifier
        
        if not hasStation then
            return false, "Station de craft requise: " .. recipe.requiredStation
        end
    end
    
    -- Retirer les ingrédients de l'inventaire
    local ingredientsRemoved = {}
    local success = true
    
    for itemId, quantity in pairs(recipe.ingredients) do
        local removed = self.inventoryService:RemoveItemFromInventory(player, itemId, quantity)
        if not removed then
            success = false
            break
        end
        
        ingredientsRemoved[itemId] = quantity
    end
    
    -- Si un ingrédient n'a pas pu être retiré, restaurer tous les ingrédients déjà retirés
    if not success then
        for itemId, quantity in pairs(ingredientsRemoved) do
            self.inventoryService:AddItemToInventory(player, itemId, quantity)
        end
        return false, "Erreur lors de la récupération des ingrédients"
    end
    
    -- Ajouter le résultat à l'inventaire du joueur
    local resultAdded = self.inventoryService:AddItemToInventory(
        player, 
        recipe.result.id, 
        recipe.result.quantity
    )
    
    -- Si l'ajout échoue (inventaire plein), remettre les ingrédients
    if not resultAdded then
        for itemId, quantity in pairs(ingredientsRemoved) do
            self.inventoryService:AddItemToInventory(player, itemId, quantity)
        end
        return false, "Inventaire plein"
    end
    
    -- Envoyer un événement de succès au client
    if self.remoteEvents.CraftComplete then
        self.remoteEvents.CraftComplete:FireClient(player, recipeId, true, "Fabrication réussie")
    end
    
    -- Journal de débogage
    print("CraftingService: " .. player.Name .. " a fabriqué " .. recipe.name)
    
    return true, "Fabrication réussie"
end

-- Mettre à jour les recettes débloquées pour le client
function CraftingService:UpdateClientRecipes(player)
    local userId = player.UserId
    
    -- S'assurer que le joueur a des données de recettes
    if not self.playerUnlockedRecipes[userId] then
        self:InitializePlayerRecipes(player)
        return
    end
    
    -- Préparer les données à envoyer au client
    local recipesData = {
        unlockedRecipes = {},
        techLevels = {}
    }
    
    -- Ajouter les recettes débloquées
    for recipeId, isUnlocked in pairs(self.playerUnlockedRecipes[userId]) do
        if isUnlocked then
            recipesData.unlockedRecipes[recipeId] = true
        end
    end
    
    -- Ajouter les niveaux technologiques débloqués
    for techLevel, isUnlocked in pairs(self.unlockedTechLevels) do
        recipesData.techLevels[techLevel] = isUnlocked
    end
    
    -- Envoyer les données au client
    if self.remoteEvents.UpdateRecipes then
        self.remoteEvents.UpdateRecipes:FireClient(player, recipesData)
    else
        warn("CraftingService: RemoteEvent UpdateRecipes non disponible")
    end
end

-- Gérer la déconnexion d'un joueur
function CraftingService:HandlePlayerRemoving(player)
    local userId = player.UserId
    if self.playerUnlockedRecipes[userId] then
        -- Ici, on pourrait sauvegarder les données dans DataStore si nécessaire
        self.playerUnlockedRecipes[userId] = nil
    end
end

-- Initialiser le service
function CraftingService:Start(services)
    -- Récupérer les références aux autres services
    self.inventoryService = services.InventoryService
    
    if not self.inventoryService then
        warn("CraftingService: InventoryService non disponible. Certaines fonctionnalités seront limitées.")
    end
    
    -- Récupérer les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            UpdateRecipes = Events:FindFirstChild("UpdateRecipes"),
            CraftComplete = Events:FindFirstChild("CraftComplete"),
            Notification = Events:FindFirstChild("Notification")
        }
    else
        warn("CraftingService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Gérer les événements de joueur
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerRecipes(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    -- Initialiser les joueurs déjà connectés
    for _, player in ipairs(Players:GetPlayers()) do
        self:InitializePlayerRecipes(player)
    end
    
    print("CraftingService: Démarré avec succès")
    return self
end

return CraftingService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="41">
          <Properties>
            <string name="Name">FarmingService</string>
            <string name="Source"><![CDATA[-- src/server/services/FarmingService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemTypes = require(Shared.constants.ItemTypes)
local GameSettings = require(Shared.constants.GameSettings)

local FarmingService = {}
FarmingService.__index = FarmingService

-- Créer une instance du service
function FarmingService.new()
    local self = setmetatable({}, FarmingService)
    
    -- Cultures plantées
    self.plantedCrops = {}  -- [cropId] = {crop data}
    self.nextCropId = 1
    
    -- Cultures par joueur
    self.playerCrops = {}  -- [userId] = {cropId1, cropId2, ...}
    
    -- Références aux services
    self.inventoryService = nil
    self.tribeService = nil
    
    -- RemoteEvents
    self.remoteEvents = {}
    
    -- Stades de croissance
    self.growthStages = {
        [1] = {name = "Graine", scale = 0.1, color = Color3.fromRGB(139, 69, 19)},
        [2] = {name = "Pousse", scale = 0.3, color = Color3.fromRGB(34, 139, 34)},
        [3] = {name = "Jeune plante", scale = 0.5, color = Color3.fromRGB(50, 205, 50)},
        [4] = {name = "Plante mature", scale = 0.8, color = Color3.fromRGB(34, 139, 34)},
        [5] = {name = "Prêt à récolter", scale = 1.0, color = Color3.fromRGB(255, 215, 0)}
    }
    
    return self
end

-- Planter une graine
function FarmingService:PlantSeed(player, seedItemId, position)
    if not player or not player:IsA("Player") then
        return false, "Joueur invalide"
    end
    
    local userId = player.UserId
    
    -- Vérifier que la graine existe et est plantable
    local seedType = ItemTypes[seedItemId]
    if not seedType or seedType.category ~= "seed" or not seedType.plantable then
        self:SendNotification(player, "Cet objet ne peut pas être planté", "error")
        return false, "Objet non plantable"
    end
    
    -- Vérifier que le joueur a la graine dans son inventaire
    if not self.inventoryService or not self.inventoryService:HasItemInInventory(player, seedItemId, 1) then
        self:SendNotification(player, "Vous n'avez pas cette graine dans votre inventaire", "error")
        return false, "Graine manquante"
    end
    
    -- Vérifier la position de plantation
    if not self:IsValidPlantingPosition(player, position) then
        self:SendNotification(player, "Vous ne pouvez pas planter ici", "error")
        return false, "Position invalide"
    end
    
    -- Vérifier qu'il n'y a pas déjà une culture à cet endroit
    if self:GetCropAtPosition(position) then
        self:SendNotification(player, "Une plante pousse déjà ici", "error")
        return false, "Emplacement occupé"
    end
    
    -- Retirer la graine de l'inventaire
    if not self.inventoryService:RemoveItemFromInventory(player, seedItemId, 1) then
        self:SendNotification(player, "Impossible de retirer la graine de l'inventaire", "error")
        return false, "Erreur d'inventaire"
    end
    
    -- Créer la culture
    local cropId = "crop_" .. self.nextCropId
    self.nextCropId = self.nextCropId + 1
    
    local cropData = {
        id = cropId,
        seedId = seedItemId,
        growsInto = seedType.growsInto,
        owner = userId,
        plantTime = os.time(),
        growthTime = seedType.growthTime or 1200,  -- 20 minutes par défaut
        stage = 1,  -- Stade de croissance (1-5)
        position = position,
        instance = nil,
        health = 100,
        watered = false,
        lastWaterTime = 0
    }
    
    -- Créer l'instance visuelle de la culture
    local cropInstance = self:CreateCropInstance(cropData)
    if cropInstance then
        cropData.instance = cropInstance
        
        -- Stocker la culture
        self.plantedCrops[cropId] = cropData
        
        -- Associer à ce joueur
        if not self.playerCrops[userId] then
            self.playerCrops[userId] = {}
        end
        table.insert(self.playerCrops[userId], cropId)
        
        -- Notifier le joueur
        self:SendNotification(player, "Graine plantée avec succès", "success")
        
        -- Démarrer la croissance
        self:StartGrowth(cropId)
        
        return true, "Plantation réussie"
    else
        -- Remettre la graine si la création échoue
        self.inventoryService:AddItemToInventory(player, seedItemId, 1)
        return false, "Erreur de création"
    end
end

-- Vérifier si une position est valide pour planter
function FarmingService:IsValidPlantingPosition(player, position)
    -- Vérifier que la position n'est pas nil
    if not position or typeof(position) ~= "Vector3" then
        return false
    end
    
    -- Vérifier que le joueur est à proximité
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local distance = (character.HumanoidRootPart.Position - position).Magnitude
    if distance > 10 then  -- Maximum 10 studs
        return false
    end
    
    -- Vérifier qu'il y a du sol sous la position
    local rayOrigin = position + Vector3.new(0, 5, 0)
    local rayDirection = Vector3.new(0, -10, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    local hitPart = raycastResult and raycastResult.Instance
    local hitPoint = raycastResult and raycastResult.Position
    
    if not hitPart then
        return false
    end
    
    -- Vérifier que c'est du terrain ou une surface appropriée
    -- (Dans une version plus avancée, on pourrait vérifier le type de matériau)
    
    return true
end

-- Obtenir une culture à une position donnée
function FarmingService:GetCropAtPosition(position)
    for cropId, cropData in pairs(self.plantedCrops) do
        if cropData.position and (cropData.position - position).Magnitude < 2 then
            return cropId, cropData
        end
    end
    return nil
end

-- Créer l'instance visuelle d'une culture
function FarmingService:CreateCropInstance(cropData)
    -- Créer un modèle pour la culture
    local cropModel = Instance.new("Model")
    cropModel.Name = "Crop"
    
    -- Partie principale
    local primaryPart = Instance.new("Part")
    primaryPart.Name = "PrimaryPart"
    primaryPart.Anchored = true
    -- Collision activée pour les plantes matures (stade 4 et 5)
    primaryPart.CanCollide = (cropData.stage >= 4)
    primaryPart.Material = Enum.Material.Grass
    
    -- Taille et couleur selon le stade
    local stage = self.growthStages[cropData.stage]
    primaryPart.Size = Vector3.new(1, 2, 1) * stage.scale
    primaryPart.Color = stage.color
    
    -- Positionner
    primaryPart.Position = cropData.position + Vector3.new(0, primaryPart.Size.Y / 2, 0)
    primaryPart.Parent = cropModel
    cropModel.PrimaryPart = primaryPart
    
    -- Ajouter des attributs
    cropModel:SetAttribute("CropId", cropData.id)
    cropModel:SetAttribute("Stage", cropData.stage)
    cropModel:SetAttribute("Owner", cropData.owner)
    
    -- Ajouter un ClickDetector pour l'interaction
    local clickDetector = Instance.new("ClickDetector")
    clickDetector.MaxActivationDistance = 10
    clickDetector.Parent = primaryPart
    
    -- Connecter l'événement de clic
    clickDetector.MouseClick:Connect(function(player)
        self:HandleCropClick(player, cropData.id)
    end)
    
    -- Créer le dossier de cultures s'il n'existe pas
    local cropsFolder = Workspace:FindFirstChild("Crops")
    if not cropsFolder then
        cropsFolder = Instance.new("Folder")
        cropsFolder.Name = "Crops"
        cropsFolder.Parent = Workspace
    end
    
    cropModel.Parent = cropsFolder
    
    return cropModel
end

-- Gérer le clic sur une culture
function FarmingService:HandleCropClick(player, cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    -- Si la culture est prête à récolter (stade 5)
    if cropData.stage >= 5 then
        self:HarvestCrop(player, cropId)
    else
        -- Afficher l'état de la culture
        local remainingTime = self:GetRemainingGrowthTime(cropId)
        local minutesLeft = math.ceil(remainingTime / 60)
        
        local stageName = self.growthStages[cropData.stage].name
        self:SendNotification(player, "État: " .. stageName .. " - Prête dans ~" .. minutesLeft .. " min", "info")
    end
end

-- Récolter une culture
function FarmingService:HarvestCrop(player, cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then
        self:SendNotification(player, "Culture introuvable", "error")
        return false
    end
    
    -- Vérifier que la culture est prête
    if cropData.stage < 5 then
        self:SendNotification(player, "Cette plante n'est pas encore prête à être récoltée", "warning")
        return false
    end
    
    -- Vérifier que le joueur est à proximité
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local distance = (character.HumanoidRootPart.Position - cropData.position).Magnitude
    if distance > 10 then
        self:SendNotification(player, "Vous êtes trop loin de cette plante", "error")
        return false
    end
    
    -- Déterminer le rendement
    local cropType = ItemTypes[cropData.growsInto]
    if not cropType then
        warn("FarmingService: Type de culture invalide - " .. tostring(cropData.growsInto))
        return false
    end
    
    -- Quantité récoltée (2-4 pour une récolte normale)
    local baseYield = math.random(2, 4)
    local bonusYield = 0
    
    -- Bonus si la plante était arrosée
    if cropData.watered then
        bonusYield = bonusYield + 1
    end
    
    -- Bonus si la plante était fertilisée
    if cropData.fertilized then
        bonusYield = bonusYield + 2
    end
    
    -- Malus si la plante est en mauvaise santé
    if cropData.health < 50 then
        bonusYield = bonusYield - 1
    end
    
    local totalYield = math.max(1, baseYield + bonusYield)
    
    -- Ajouter les produits à l'inventaire
    if self.inventoryService then
        local success = self.inventoryService:AddItemToInventory(player, cropData.growsInto, totalYield)
        
        if success then
            -- Notifier le joueur
            self:SendNotification(player, "Vous avez récolté " .. totalYield .. " " .. cropType.name, "success")
            
            -- Envoyer un événement au client
            if self.remoteEvents.HarvestCrop then
                self.remoteEvents.HarvestCrop:FireClient(player, cropData.growsInto, totalYield)
            end
            
            -- Détruire la culture
            self:DestroyCrop(cropId)
            
            return true
        else
            -- Inventaire plein : la plante reste récoltable
            self:SendNotification(player, "Inventaire plein, la plante reste prête à récolter", "warning")
            return false
        end
    end
    
    return false
end

-- Arroser une culture
function FarmingService:WaterCrop(player, cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return false end
    
    -- Vérifier que le joueur a de l'eau
    if not self.inventoryService or not self.inventoryService:HasItemInInventory(player, "water_container", 1) then
        self:SendNotification(player, "Vous avez besoin d'eau pour arroser", "warning")
        return false
    end
    
    -- Vérifier qu'elle n'est pas déjà arrosée récemment
    local timeSinceWater = os.time() - cropData.lastWaterTime
    if timeSinceWater < 300 then  -- 5 minutes
        self:SendNotification(player, "Cette plante a été arrosée récemment", "info")
        return false
    end
    
    -- Arroser
    cropData.watered = true
    cropData.lastWaterTime = os.time()
    
    -- Accélérer légèrement la croissance (10% plus rapide)
    cropData.growthTime = math.floor(cropData.growthTime * 0.9)
    
    -- Consommer l'eau
    self.inventoryService:RemoveItemFromInventory(player, "water_container", 1)
    
    self:SendNotification(player, "Plante arrosée", "success")
    
    return true
end

-- Endommager une culture
function FarmingService:DamageCrop(cropId, damage, cause)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return false end
    
    -- Réduire la santé
    cropData.health = math.max(0, cropData.health - damage)
    
    -- Mettre à jour l'apparence pour refléter la santé
    self:UpdateCropAppearance(cropId)
    
    -- Si la santé atteint 0, détruire la culture
    if cropData.health <= 0 then
        -- Notifier le propriétaire
        local owner = game:GetService("Players"):GetPlayerByUserId(cropData.owner)
        if owner then
            local causeName = cause or "inconnue"
            self:SendNotification(owner, "Une de vos plantes est morte (cause: " .. causeName .. ")", "error")
        end
        
        self:DestroyCrop(cropId)
        return true
    end
    
    return true
end

-- Soigner une culture (avec engrais ou soin)
function FarmingService:HealCrop(cropId, healAmount)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return false end
    
    cropData.health = math.min(100, cropData.health + healAmount)
    
    -- Mettre à jour l'apparence
    self:UpdateCropAppearance(cropId)
    
    return true
end

-- Appliquer de l'engrais à une culture
function FarmingService:ApplyFertilizer(player, cropId, fertilizerType)
    local cropData = self.plantedCrops[cropId]
    if not cropData then
        self:SendNotification(player, "Culture introuvable", "error")
        return false
    end
    
    -- Vérifier que le joueur est à proximité
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local distance = (character.HumanoidRootPart.Position - cropData.position).Magnitude
    if distance > 10 then
        self:SendNotification(player, "Vous êtes trop loin de cette plante", "error")
        return false
    end
    
    -- Vérifier que le joueur a l'engrais
    local fertilizerItemId = fertilizerType or "fertilizer"
    if not self.inventoryService or not self.inventoryService:HasItemInInventory(player, fertilizerItemId, 1) then
        self:SendNotification(player, "Vous n'avez pas d'engrais", "error")
        return false
    end
    
    -- Retirer l'engrais de l'inventaire
    self.inventoryService:RemoveItemFromInventory(player, fertilizerItemId, 1)
    
    -- Effets de l'engrais
    -- 1. Accélérer la croissance (30% plus rapide)
    cropData.growthTime = math.floor(cropData.growthTime * 0.7)
    
    -- 2. Soigner la plante
    self:HealCrop(cropId, 20)
    
    -- 3. Augmenter le rendement potentiel (marqueur pour la récolte)
    cropData.fertilized = true
    
    self:SendNotification(player, "Engrais appliqué avec succès", "success")
    
    return true
end

-- Système de maladies et parasites
function FarmingService:CheckCropDiseases(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    -- Maladies possibles
    local diseases = {
        {id = "blight", name = "Mildiou", chance = 0.01, damage = 5},
        {id = "aphids", name = "Pucerons", chance = 0.015, damage = 3},
        {id = "rot", name = "Pourriture", chance = 0.008, damage = 10}
    }
    
    -- Vérifier si la plante n'est pas déjà malade
    if cropData.diseased then
        -- Appliquer les dégâts de la maladie existante
        for _, disease in ipairs(diseases) do
            if cropData.disease == disease.id then
                self:DamageCrop(cropId, disease.damage, disease.name)
                break
            end
        end
        return
    end
    
    -- Chance d'attraper une maladie
    -- Réduite si la plante est arrosée et en bonne santé
    local baseChance = 1
    if cropData.watered then
        baseChance = baseChance * 0.5
    end
    if cropData.health > 70 then
        baseChance = baseChance * 0.5
    end
    
    -- Vérifier chaque maladie
    for _, disease in ipairs(diseases) do
        if math.random() < (disease.chance * baseChance) then
            cropData.diseased = true
            cropData.disease = disease.id
            
            -- Notifier le propriétaire
            local owner = game:GetService("Players"):GetPlayerByUserId(cropData.owner)
            if owner then
                self:SendNotification(owner, "Une de vos plantes a attrapé: " .. disease.name, "warning")
            end
            
            break
        end
    end
end

-- Traiter une maladie de culture
function FarmingService:TreatCropDisease(player, cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then
        self:SendNotification(player, "Culture introuvable", "error")
        return false
    end
    
    if not cropData.diseased then
        self:SendNotification(player, "Cette plante n'est pas malade", "info")
        return false
    end
    
    -- Vérifier que le joueur a un traitement
    local treatmentItemId = "plant_medicine"
    if not self.inventoryService or not self.inventoryService:HasItemInInventory(player, treatmentItemId, 1) then
        self:SendNotification(player, "Vous avez besoin d'un traitement pour plantes", "error")
        return false
    end
    
    -- Retirer le traitement
    self.inventoryService:RemoveItemFromInventory(player, treatmentItemId, 1)
    
    -- Guérir la plante
    cropData.diseased = false
    cropData.disease = nil
    
    -- Soigner un peu la plante
    self:HealCrop(cropId, 15)
    
    self:SendNotification(player, "Plante traitée avec succès", "success")
    
    return true
end

-- Système d'irrigation automatique
function FarmingService:CheckAutoIrrigation(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    -- Vérifier s'il y a un système d'irrigation à proximité
    local cropsFolder = game:GetService("Workspace"):FindFirstChild("Crops")
    if not cropsFolder then return end
    
    local structuresFolder = game:GetService("Workspace"):FindFirstChild("Structures")
    if not structuresFolder then return end
    
    -- Chercher un système d'irrigation dans un rayon de 15 studs
    for _, structure in ipairs(structuresFolder:GetChildren()) do
        if structure:GetAttribute("BuildingType") == "irrigation_system" and structure.PrimaryPart then
            local distance = (structure.PrimaryPart.Position - cropData.position).Magnitude
            
            if distance <= 15 then
                -- Arroser automatiquement si pas arrosée récemment
                local timeSinceWater = os.time() - cropData.lastWaterTime
                if timeSinceWater >= 600 then -- 10 minutes
                    cropData.watered = true
                    cropData.lastWaterTime = os.time()
                    cropData.growthTime = math.floor(cropData.growthTime * 0.95)
                    
                    -- Soigner légèrement la plante
                    self:HealCrop(cropId, 5)
                end
                break
            end
        end
    end
end

-- Système de saisons
function FarmingService:GetCurrentSeason()
    -- Obtenir le temps du jeu (cycle jour/nuit)
    local timeService = self.timeService
    if timeService and timeService.GetCurrentSeason then
        return timeService:GetCurrentSeason()
    end
    
    -- Fallback : utiliser le temps système
    local month = tonumber(os.date("%m"))
    
    if month >= 3 and month <= 5 then
        return "spring" -- Printemps
    elseif month >= 6 and month <= 8 then
        return "summer" -- Été
    elseif month >= 9 and month <= 11 then
        return "autumn" -- Automne
    else
        return "winter" -- Hiver
    end
end

-- Obtenir le modificateur de croissance selon la saison
function FarmingService:GetSeasonGrowthModifier(cropType)
    local season = self:GetCurrentSeason()
    
    -- Définir les saisons favorables pour chaque type de culture
    local seasonPreferences = {
        -- Légumes de printemps
        ["wheat_seed"] = {spring = 1.3, summer = 1.0, autumn = 0.8, winter = 0.5},
        ["carrot_seed"] = {spring = 1.2, summer = 0.9, autumn = 1.1, winter = 0.6},
        
        -- Légumes d'été
        ["tomato_seed"] = {spring = 0.8, summer = 1.4, autumn = 0.9, winter = 0.3},
        ["corn_seed"] = {spring = 0.7, summer = 1.3, autumn = 1.0, winter = 0.4},
        
        -- Légumes d'automne
        ["pumpkin_seed"] = {spring = 0.9, summer = 1.0, autumn = 1.3, winter = 0.5},
        
        -- Cultures hivernales (rares)
        ["winter_wheat_seed"] = {spring = 0.8, summer = 0.6, autumn = 1.1, winter = 1.2}
    }
    
    local preferences = seasonPreferences[cropType]
    if preferences and preferences[season] then
        return preferences[season]
    end
    
    -- Par défaut, toutes les saisons sauf l'hiver
    if season == "winter" then
        return 0.5 -- Croissance ralentie en hiver
    elseif season == "spring" then
        return 1.2 -- Croissance accélérée au printemps
    else
        return 1.0 -- Croissance normale
    end
end

-- Appliquer l'effet des saisons lors de la croissance
function FarmingService:ApplySeasonalEffects(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    local seasonModifier = self:GetSeasonGrowthModifier(cropData.seedId)
    
    -- Ajuster le temps de croissance selon la saison
    -- Plus le modificateur est élevé, plus la croissance est rapide
    if not cropData.originalGrowthTime then
        cropData.originalGrowthTime = cropData.growthTime
    end
    
    -- Recalculer le temps de croissance
    cropData.growthTime = math.floor(cropData.originalGrowthTime / seasonModifier)
    
    -- En hiver, les plantes peuvent perdre de la santé
    if self:GetCurrentSeason() == "winter" and math.random() < 0.05 then
        self:DamageCrop(cropId, 2, "froid")
    end
end

-- Démarrer la croissance d'une culture
function FarmingService:StartGrowth(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    -- La croissance sera gérée par la boucle de mise à jour
    -- Nous n'avons pas besoin de créer un nouveau thread pour chaque culture
end

-- Calculer le temps de croissance restant
function FarmingService:GetRemainingGrowthTime(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return 0 end
    
    local elapsedTime = os.time() - cropData.plantTime
    local timePerStage = cropData.growthTime / 5  -- 5 stades
    local timeForCurrentStage = timePerStage * cropData.stage
    
    return math.max(0, cropData.growthTime - elapsedTime)
end

-- Mettre à jour la croissance d'une culture
function FarmingService:UpdateCropGrowth(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    -- Calculer le stade actuel basé sur le temps écoulé
    local elapsedTime = os.time() - cropData.plantTime
    local timePerStage = cropData.growthTime / 5
    local newStage = math.min(5, math.floor(elapsedTime / timePerStage) + 1)
    
    -- Mettre à jour le stade si changé
    if newStage ~= cropData.stage then
        cropData.stage = newStage
        
        -- Mettre à jour l'apparence
        self:UpdateCropAppearance(cropId)
        
        -- Notifier le propriétaire si connecté
        local owner = Players:GetPlayerByUserId(cropData.owner)
        if owner and newStage == 5 then
            self:SendNotification(owner, "Une de vos plantes est prête à être récoltée!", "success")
        end
    end
end

-- Mettre à jour l'apparence d'une culture
function FarmingService:UpdateCropAppearance(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData or not cropData.instance then return end
    
    local primaryPart = cropData.instance.PrimaryPart
    if not primaryPart then return end
    
    local stage = self.growthStages[cropData.stage]
    if not stage then return end
    
    -- Mettre à jour la taille et la couleur
    local targetSize = Vector3.new(1, 2, 1) * stage.scale
    primaryPart.Size = targetSize
    
    -- Modifier la couleur en fonction de la santé
    if cropData.health < 30 then
        -- Plante en mauvaise santé : teinte brunâtre
        primaryPart.Color = Color3.fromRGB(139, 90, 43)
    elseif cropData.health < 60 then
        -- Plante en santé moyenne : teinte jaunâtre
        primaryPart.Color = Color3.new(
            stage.color.R * 0.9,
            stage.color.G * 0.8,
            stage.color.B * 0.5
        )
    else
        -- Plante en bonne santé : couleur normale
        primaryPart.Color = stage.color
    end
    
    -- Repositionner pour que la base reste au sol
    local position = cropData.position + Vector3.new(0, targetSize.Y / 2, 0)
    primaryPart.Position = position
    
    -- Activer la collision pour les plantes matures
    primaryPart.CanCollide = (cropData.stage >= 4)
    
    -- Mettre à jour l'attribut du stade
    cropData.instance:SetAttribute("Stage", cropData.stage)
    cropData.instance:SetAttribute("Health", cropData.health)
end

-- Détruire une culture
function FarmingService:DestroyCrop(cropId)
    local cropData = self.plantedCrops[cropId]
    if not cropData then return end
    
    -- Détruire l'instance visuelle
    if cropData.instance then
        cropData.instance:Destroy()
    end
    
    -- Retirer des données
    self.plantedCrops[cropId] = nil
    
    -- Retirer de la liste du joueur
    if self.playerCrops[cropData.owner] then
        for i, cId in ipairs(self.playerCrops[cropData.owner]) do
            if cId == cropId then
                table.remove(self.playerCrops[cropData.owner], i)
                break
            end
        end
    end
end

-- Nettoyer les cultures d'un joueur qui se déconnecte
function FarmingService:HandlePlayerRemoving(player)
    local userId = player.UserId
    
    -- Sauvegarder les cultures du joueur (dans une implémentation complète)
    -- Pour l'instant, on les laisse pousser
    
    -- Les cultures continuent de pousser même si le joueur se déconnecte
    -- Elles seront disponibles à son retour
end

-- Envoyer une notification
function FarmingService:SendNotification(player, message, messageType)
    if self.remoteEvents.Notification then
        self.remoteEvents.Notification:FireClient(player, message, messageType or "info")
    else
        print("Notification pour " .. player.Name .. ": " .. message)
    end
end

-- Démarrer le service
function FarmingService:Start(services)
    print("FarmingService: Démarrage...")
    
    -- Récupérer les références aux autres services
    self.inventoryService = services.InventoryService
    self.tribeService = services.TribeService
    
    -- Récupérer les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            PlantSeed = Events:FindFirstChild("PlantSeed"),
            HarvestCrop = Events:FindFirstChild("HarvestCrop"),
            UpdateCrop = Events:FindFirstChild("UpdateCrop"),
            Notification = Events:FindFirstChild("Notification")
        }
        
        -- Connecter les événements
        if self.remoteEvents.PlantSeed then
            self.remoteEvents.PlantSeed.OnServerEvent:Connect(function(player, seedId, position)
                self:PlantSeed(player, seedId, position)
            end)
        end
        
        if self.remoteEvents.HarvestCrop then
            self.remoteEvents.HarvestCrop.OnServerEvent:Connect(function(player, cropId)
                self:HarvestCrop(player, cropId)
            end)
        end
    else
        warn("FarmingService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Démarrer la boucle de mise à jour des cultures
    spawn(function()
        while true do
            wait(30)  -- Mettre à jour toutes les 30 secondes
            
            for cropId, _ in pairs(self.plantedCrops) do
                pcall(function()
                    self:UpdateCropGrowth(cropId)
                    -- Vérifier les maladies toutes les 30 secondes
                    self:CheckCropDiseases(cropId)
                    -- Vérifier l'irrigation automatique
                    self:CheckAutoIrrigation(cropId)
                    -- Appliquer les effets saisonniers
                    self:ApplySeasonalEffects(cropId)
                end)
            end
        end
    end)
    
    -- Gérer les déconnexions de joueurs
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    print("FarmingService: Démarré avec succès")
    return self
end

return FarmingService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="42">
          <Properties>
            <string name="Name">InventoryService</string>
            <string name="Source"><![CDATA[-- src/server/services/InventoryService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemTypes = require(Shared.constants.ItemTypes)
local GameSettings = require(Shared.constants.GameSettings)

-- Création du DataStore avec gestion des erreurs
local InventoryDataStore
local success, errorMessage = pcall(function()
    InventoryDataStore = DataStoreService:GetDataStore("PlayerInventories_v1")
end)

if not success then
    warn("InventoryService: Échec d'initialisation du DataStore - " .. tostring(errorMessage))
    InventoryDataStore = nil
end

local InventoryService = {}
InventoryService.__index = InventoryService

-- Créer une instance du service
function InventoryService.new()
    local self = setmetatable({}, InventoryService)
    
    -- Stockage des inventaires de joueurs
    self.playerInventories = {}
    
    -- Constantes
    self.maxInventorySlots = GameSettings.Player.initialInventorySize or 20
    self.defaultMaxStackSize = 64
    
    -- Limites pour les sauvegardes DataStore
    self.saveInterval = 300 -- 5 minutes entre les sauvegardes automatiques
    self.saveRetryLimit = 3 -- Nombre de tentatives pour sauvegarder en cas d'échec
    
    -- Suivi des dernières sauvegardes
    self.lastSaveTime = {}
    
    -- Sauvegardes en attente
    self.pendingSaves = {}
    
    -- État du service
    self.isInitialized = false
    
    -- RemoteEvents
    self.remoteEvents = {}
    
    return self
end

-- Initialiser un inventaire pour un joueur
function InventoryService:InitializePlayerInventory(player)
    if not player or not player:IsA("Player") then
        warn("InventoryService: Tentative d'initialiser l'inventaire d'un joueur invalide")
        return false
    end
    
    local userId = player.UserId
    
    -- Éviter la double initialisation
    if self.playerInventories[userId] then
        return true
    end
    
    -- Essayer de charger les données sauvegardées
    local loadedData = self:LoadPlayerInventory(player)
    
    if loadedData then
        self.playerInventories[userId] = loadedData
        print("InventoryService: Inventaire chargé pour " .. player.Name)
    else
        -- Créer un inventaire vide si pas de données sauvegardées ou erreur
        self.playerInventories[userId] = {
            items = {},
            equipped = {},  -- Objets équipés actuellement
            maxSlots = self.maxInventorySlots
        }
        
        -- Donner les objets de départ à un nouveau joueur
        local startingItems = GameSettings.Player.spawnWithItems or {}
        for itemId, quantity in pairs(startingItems) do
            self:AddItemToInventory(player, itemId, quantity)
        end
        
        print("InventoryService: Nouvel inventaire créé pour " .. player.Name)
    end
    
    -- Envoyer les données d'inventaire au client
    self:UpdateClientInventory(player)
    
    return true
end

-- Charger l'inventaire d'un joueur depuis le DataStore
function InventoryService:LoadPlayerInventory(player)
    if not player or not player:IsA("Player") then return nil end
    
    local userId = player.UserId
    
    -- Vérifier si DataStore est disponible
    if not InventoryDataStore then
        warn("InventoryService: DataStore non disponible pour le chargement")
        return nil
    end
    
    -- Essayer de charger les données
    local success, result = pcall(function()
        return InventoryDataStore:GetAsync("inventory_" .. userId)
    end)
    
    if success and result then
        -- Vérifier l'intégrité des données
        if type(result) ~= "table" or not result.items then
            warn("InventoryService: Données d'inventaire corrompues pour " .. player.Name)
            return nil
        end
        
        -- Vérifier que les objets existent toujours (au cas où ItemTypes aurait changé)
        local validItems = {}
        
        for slot, item in pairs(result.items) do
            if ItemTypes[item.id] then
                validItems[tonumber(slot)] = item
            else
                warn("InventoryService: Objet inconnu ignoré - " .. tostring(item.id))
            end
        end
        
        result.items = validItems
        
        -- Valider les objets équipés
        local validEquipped = {}
        
        for slot, itemSlot in pairs(result.equipped or {}) do
            if type(itemSlot) == "number" and result.items[itemSlot] then
                validEquipped[slot] = itemSlot
            end
        end
        
        result.equipped = validEquipped
        
        -- S'assurer que maxSlots est défini
        result.maxSlots = result.maxSlots or self.maxInventorySlots
        
        return result
    else
        if not success then
            warn("InventoryService: Erreur lors du chargement des données - " .. tostring(result))
        end
        return nil
    end
end

-- Sauvegarder l'inventaire d'un joueur
function InventoryService:SavePlayerInventory(player, forceImmediate)
    local userId = type(player) == "number" and player or (player and player.UserId)
    
    if not userId then
        warn("InventoryService: ID utilisateur invalide pour la sauvegarde")
        return false
    end
    
    -- Vérifier si l'inventaire existe
    if not self.playerInventories[userId] then
        return false
    end
    
    -- Marquer comme en attente de sauvegarde
    self.pendingSaves[userId] = true
    
    -- Si forceImmediate est vrai ou DataStore n'est pas disponible, sauvegarder maintenant
    if forceImmediate or not InventoryDataStore then
        return self:ProcessSave(userId)
    end
    
    -- Sinon, laisser la sauvegarde planifiée s'exécuter
    return true
end

-- Traiter la sauvegarde effective
function InventoryService:ProcessSave(userId)
    -- Vérifier si DataStore est disponible
    if not InventoryDataStore then
        warn("InventoryService: DataStore non disponible pour la sauvegarde")
        return false
    end
    
    -- Vérifier si l'inventaire existe
    if not self.playerInventories[userId] then
        self.pendingSaves[userId] = nil
        return false
    end
    
    -- Créer une copie des données à sauvegarder
    local inventoryData = table.clone(self.playerInventories[userId])
    
    -- Tentatives de sauvegarde avec rétention
    local attempts = 0
    local success = false
    
    while not success and attempts < self.saveRetryLimit do
        attempts = attempts + 1
        
        success, errorMessage = pcall(function()
            InventoryDataStore:SetAsync("inventory_" .. userId, inventoryData)
        end)
        
        if not success then
            warn("InventoryService: Tentative de sauvegarde " .. attempts .. " échouée - " .. tostring(errorMessage))
            wait(1) -- Attendre avant de réessayer
        end
    end
    
    -- Nettoyer le marqueur de sauvegarde en attente
    self.pendingSaves[userId] = nil
    
    -- Mettre à jour le temps de dernière sauvegarde
    if success then
        self.lastSaveTime[userId] = os.time()
        return true
    else
        warn("InventoryService: Échec définitif de la sauvegarde pour l'utilisateur " .. userId .. " après " .. attempts .. " tentatives")
        return false
    end
end

-- Ajouter un objet à l'inventaire
function InventoryService:AddItemToInventory(player, itemId, quantity)
    if not player or not player:IsA("Player") then
        warn("InventoryService: Joueur invalide pour l'ajout d'objet")
        return false
    end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then
        warn("InventoryService: Inventaire non initialisé pour " .. player.Name)
        return false
    end
    
    -- Vérifier si l'objet existe dans ItemTypes
    local itemType = ItemTypes[itemId]
    if not itemType then
        warn("InventoryService: Type d'objet invalide - " .. tostring(itemId))
        return false
    end
    
    -- Valider la quantité
    quantity = math.floor(tonumber(quantity) or 1)
    if quantity <= 0 then return false end
    
    -- Déterminer si l'objet est empilable et la taille max de pile
    local isStackable = itemType.stackable or false
    local maxStack = itemType.maxStack or self.defaultMaxStackSize
    
    -- Stratégie d'ajout
    if isStackable then
        -- Essayer d'abord d'empiler avec des objets existants du même type
        local remainingQuantity = quantity
        
        for slot, item in pairs(inventory.items) do
            if remainingQuantity <= 0 then break end
            
            if item.id == itemId and item.quantity < maxStack then
                local spaceInStack = maxStack - item.quantity
                local amountToAdd = math.min(spaceInStack, remainingQuantity)
                
                inventory.items[slot].quantity = item.quantity + amountToAdd
                remainingQuantity = remainingQuantity - amountToAdd
            end
        end
        
        -- S'il reste des objets à ajouter, chercher des emplacements vides
        while remainingQuantity > 0 do
            local emptySlot = self:FindEmptySlot(inventory)
            
            if not emptySlot then
                -- Inventaire plein, notifier le joueur
                self:SendNotification(player, "Inventaire plein!", "warning")
                
                -- Actualiser l'inventaire pour refléter ce qui a pu être ajouté
                self:UpdateClientInventory(player)
                
                return quantity > remainingQuantity -- True si au moins un objet a été ajouté
            end
            
            -- Ajouter une nouvelle pile
            local amountToAdd = math.min(remainingQuantity, maxStack)
            
            inventory.items[emptySlot] = {
                id = itemId,
                quantity = amountToAdd,
                data = {} -- Données supplémentaires (durabilité, etc.)
            }
            
            -- Si l'objet a une durabilité, l'initialiser
            if itemType.durability then
                inventory.items[emptySlot].data.durability = itemType.durability
            end
            
            remainingQuantity = remainingQuantity - amountToAdd
        end
    else
        -- Objets non empilables - un emplacement par objet
        for i = 1, quantity do
            local emptySlot = self:FindEmptySlot(inventory)
            
            if not emptySlot then
                -- Inventaire plein
                self:SendNotification(player, "Inventaire plein!", "warning")
                
                -- Actualiser l'inventaire pour refléter ce qui a pu être ajouté
                self:UpdateClientInventory(player)
                
                return i > 1 -- True si au moins un objet a été ajouté
            end
            
            -- Ajouter l'objet
            inventory.items[emptySlot] = {
                id = itemId,
                quantity = 1,
                data = {} -- Données supplémentaires
            }
            
            -- Si l'objet a une durabilité, l'initialiser
            if itemType.durability then
                inventory.items[emptySlot].data.durability = itemType.durability
            end
        end
    end
    
    -- Mettre à jour l'inventaire du client
    self:UpdateClientInventory(player)
    
    -- Marquer l'inventaire pour sauvegarde différée
    self:ScheduleInventorySave(userId)
    
    return true
end

-- Trouver un emplacement vide dans l'inventaire
function InventoryService:FindEmptySlot(inventory)
    for i = 1, inventory.maxSlots do
        if not inventory.items[i] then
            return i
        end
    end
    return nil
end

-- Retirer un objet de l'inventaire
function InventoryService:RemoveItemFromInventory(player, itemId, quantity)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then return false end
    
    -- Valider la quantité
    quantity = math.floor(tonumber(quantity) or 1)
    if quantity <= 0 then return false end
    
    local remainingToRemove = quantity
    local removedSlots = {}
    
    -- Parcourir l'inventaire pour trouver des objets correspondants
    for slot, item in pairs(inventory.items) do
        if item.id == itemId and remainingToRemove > 0 then
            if item.quantity > remainingToRemove then
                -- Réduire la quantité
                inventory.items[slot].quantity = item.quantity - remainingToRemove
                remainingToRemove = 0
                break
            else
                -- Mémoriser l'emplacement pour le supprimer après
                remainingToRemove = remainingToRemove - item.quantity
                table.insert(removedSlots, slot)
            end
        end
    end
    
    -- Supprimer les emplacements identifiés
    for _, slot in ipairs(removedSlots) do
        inventory.items[slot] = nil
        
        -- Vérifier si c'était un objet équipé et le déséquiper
        for equipSlot, slotNumber in pairs(inventory.equipped) do
            if slotNumber == slot then
                inventory.equipped[equipSlot] = nil
            end
        end
    end
    
    -- Mise à jour du client seulement si des objets ont été retirés
    if remainingToRemove < quantity then
        self:UpdateClientInventory(player)
        
        -- Marquer l'inventaire pour sauvegarde différée
        self:ScheduleInventorySave(userId)
        
        return true
    end
    
    return false
end

-- Vérifier si un joueur a un certain objet
function InventoryService:HasItemInInventory(player, itemId, quantity)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then return false end
    
    -- Valider la quantité
    quantity = math.floor(tonumber(quantity) or 1)
    if quantity <= 0 then return true end -- 0 requis = toujours vrai
    
    local totalFound = 0
    
    -- Compter tous les objets correspondants
    for _, item in pairs(inventory.items) do
        if item.id == itemId then
            totalFound = totalFound + (item.quantity or 1)
            if totalFound >= quantity then
                return true
            end
        end
    end
    
    return false
end

-- Compter le nombre d'un item donné dans l'inventaire
function InventoryService:CountItemsInInventory(player, itemId)
    if not player or not player:IsA("Player") then return 0 end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then return 0 end
    
    local count = 0
    
    for _, item in pairs(inventory.items) do
        if item.id == itemId then
            count = count + (item.quantity or 1)
        end
    end
    
    return count
end

-- Équiper un objet
function InventoryService:EquipItem(player, slotNumber)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory or not inventory.items[slotNumber] then
        return false
    end
    
    local item = inventory.items[slotNumber]
    local itemType = ItemTypes[item.id]
    
    if not itemType or not itemType.equipable or not itemType.equipSlot then 
        return false 
    end
    
    -- Vérifier si un autre objet est déjà équipé dans cet emplacement
    local currentEquippedSlot = inventory.equipped[itemType.equipSlot]
    if currentEquippedSlot then
        -- Déséquiper l'objet actuel
        inventory.equipped[itemType.equipSlot] = nil
    end
    
    -- Équiper le nouvel objet
    inventory.equipped[itemType.equipSlot] = slotNumber
    
    -- Mettre à jour le client
    self:UpdateClientInventory(player)
    
    -- Marquer l'inventaire pour sauvegarde différée
    self:ScheduleInventorySave(userId)
    
    return true
end

-- Déséquiper un objet
function InventoryService:UnequipItem(player, equipSlot)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory or not inventory.equipped[equipSlot] then
        return false
    end
    
    -- Supprimer la référence d'équipement
    inventory.equipped[equipSlot] = nil
    
    -- Mettre à jour le client
    self:UpdateClientInventory(player)
    
    -- Marquer l'inventaire pour sauvegarde différée
    self:ScheduleInventorySave(userId)
    
    return true
end

-- Déplacer un objet d'un emplacement à un autre
function InventoryService:MoveItem(player, fromSlot, toSlot)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then return false end
    
    -- Vérifier que les emplacements sont valides
    if not fromSlot or not inventory.items[fromSlot] then return false end
    if not toSlot or toSlot < 1 or toSlot > inventory.maxSlots then return false end
    
    local fromItem = inventory.items[fromSlot]
    local toItem = inventory.items[toSlot]
    
    -- Cas 1: destination vide - simplement déplacer
    if not toItem then
        inventory.items[toSlot] = fromItem
        inventory.items[fromSlot] = nil
        
        -- Mettre à jour les références d'équipement
        for equipSlot, slotNumber in pairs(inventory.equipped) do
            if slotNumber == fromSlot then
                inventory.equipped[equipSlot] = toSlot
            end
        end
    
    -- Cas 2: même type d'objet et empilable - combiner si possible
    elseif fromItem.id == toItem.id and ItemTypes[fromItem.id] and ItemTypes[fromItem.id].stackable then
        local maxStack = ItemTypes[fromItem.id].maxStack or self.defaultMaxStackSize
        
        -- Calculer combien peuvent être transférés
        local transferAmount = math.min(fromItem.quantity, maxStack - toItem.quantity)
        
        if transferAmount > 0 then
            toItem.quantity = toItem.quantity + transferAmount
            fromItem.quantity = fromItem.quantity - transferAmount
            
            -- Supprimer l'emplacement source s'il est vide
            if fromItem.quantity <= 0 then
                inventory.items[fromSlot] = nil
                
                -- Mettre à jour les références d'équipement
                for equipSlot, slotNumber in pairs(inventory.equipped) do
                    if slotNumber == fromSlot then
                        inventory.equipped[equipSlot] = nil  -- Déséquiper
                    end
                end
            end
        end
        
    -- Cas 3: objets différents ou non empilables - échanger les positions
    else
        inventory.items[fromSlot] = toItem
        inventory.items[toSlot] = fromItem
        
        -- Mettre à jour les références d'équipement
        for equipSlot, slotNumber in pairs(inventory.equipped) do
            if slotNumber == fromSlot then
                inventory.equipped[equipSlot] = toSlot
            elseif slotNumber == toSlot then
                inventory.equipped[equipSlot] = fromSlot
            end
        end
    end
    
    -- Mettre à jour le client
    self:UpdateClientInventory(player)
    
    -- Marquer l'inventaire pour sauvegarde différée
    self:ScheduleInventorySave(userId)
    
    return true
end

-- Utiliser un objet
function InventoryService:UseItem(player, slotNumber)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory or not inventory.items[slotNumber] then return false end
    
    local item = inventory.items[slotNumber]
    local itemType = ItemTypes[item.id]
    
    if not itemType then return false end
    
    -- Traiter selon le type d'objet
    if itemType.equipable then
        -- Équiper/déséquiper
        return self:EquipItem(player, slotNumber)
    elseif itemType.consumable then
        -- Consommer (nourriture, boisson, etc.)
        local consumed = false
        
        -- Envoyer l'action au serveur
        local events = ReplicatedStorage:FindFirstChild("Events")
        if events then
            local playerActionEvent = events:FindFirstChild("PlayerAction")
            if playerActionEvent then
                -- Déclencher l'action de consommation
                playerActionEvent:FireServer("use_item", slotNumber, item.id)
                consumed = true
            end
        end
        
        -- Si consommé, réduire la quantité ou supprimer l'objet
        -- Note: La consommation effective et la mise à jour seront gérées par le serveur
        return consumed
    elseif itemType.placeable then
        -- Placer dans le monde (bâtiment, meuble, etc.)
        local events = ReplicatedStorage:FindFirstChild("Events")
        if events then
            local playerActionEvent = events:FindFirstChild("PlayerAction")
            if playerActionEvent then
                -- Déclencher l'action de placement
                playerActionEvent:FireServer("use_item", slotNumber, item.id)
                return true
            end
        end
    end
    
    return false
end

-- Augmenter la capacité de l'inventaire
function InventoryService:IncreaseInventoryCapacity(player, additionalSlots)
    if not player or not player:IsA("Player") then return false end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then return false end
    
    -- Vérifier que l'augmentation est positive
    additionalSlots = math.floor(tonumber(additionalSlots) or 0)
    if additionalSlots <= 0 then return false end
    
    -- Mettre à jour la capacité maximale
    inventory.maxSlots = inventory.maxSlots + additionalSlots
    
    -- Mettre à jour le client
    self:UpdateClientInventory(player)
    
    -- Marquer l'inventaire pour sauvegarde différée
    self:ScheduleInventorySave(userId)
    
    return true
end

-- Mettre à jour l'inventaire du client
function InventoryService:UpdateClientInventory(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    local inventory = self.playerInventories[userId]
    
    if not inventory then return end
    
    -- Envoyer les données d'inventaire au client
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events and events:FindFirstChild("UpdateInventory") then
        events.UpdateInventory:FireClient(player, inventory)
    end
end

-- Envoyer une notification au joueur
function InventoryService:SendNotification(player, message, messageType)
    if not player or not player:IsA("Player") then return end
    
    -- Envoyer via RemoteEvent si disponible
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events and events:FindFirstChild("Notification") then
        events.Notification:FireClient(player, message, messageType or "info")
    else
        -- Fallback si le RemoteEvent n'est pas disponible
        print("Notification pour " .. player.Name .. ": " .. message)
    end
end

-- Programmer une sauvegarde différée de l'inventaire
function InventoryService:ScheduleInventorySave(userId)
    self.pendingSaves[userId] = true
end

-- Nettoyer les objets périmés
function InventoryService:CleanupExpiredItems()
    local currentTime = os.time()
    
    for userId, inventory in pairs(self.playerInventories) do
        local player = Players:GetPlayerByUserId(userId)
        if player then
            local itemsChanged = false
            
            -- Vérifier chaque objet pour voir s'il a expiré
            for slot, item in pairs(inventory.items) do
                if item.data and item.data.expiryTime and item.data.expiryTime < currentTime then
                    -- Supprimer l'objet expiré
                    inventory.items[slot] = nil
                    itemsChanged = true
                    
                    -- Vérifier si c'était un objet équipé et le déséquiper
                    for equipSlot, slotNumber in pairs(inventory.equipped) do
                        if slotNumber == slot then
                            inventory.equipped[equipSlot] = nil
                        end
                    end
                    
                    -- Notifier le joueur
                    self:SendNotification(player, "Un objet dans votre inventaire s'est dégradé.", "warning")
                end
            end
            
            -- Mettre à jour l'interface si des objets ont été supprimés
            if itemsChanged then
                self:UpdateClientInventory(player)
                
                -- Marquer l'inventaire pour sauvegarde différée
                self:ScheduleInventorySave(userId)
            end
        end
    end
end

-- Gérer la déconnexion d'un joueur
function InventoryService:HandlePlayerRemoving(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    
    -- Sauvegarder l'inventaire avant la déconnexion (forcer immédiat)
    self:SavePlayerInventory(player, true)
    
    -- Nettoyer les références
    self.playerInventories[userId] = nil
    self.lastSaveTime[userId] = nil
    self.pendingSaves[userId] = nil
    
    print("InventoryService: Données d'inventaire nettoyées pour " .. player.Name)
end

-- Démarrer le service
function InventoryService:Start(services)
    print("InventoryService: Démarrage...")
    
    -- Configurer les RemoteEvents
    self:SetupRemoteEvents()
    
    -- Initialiser les inventaires des joueurs existants
    for _, player in pairs(Players:GetPlayers()) do
        self:InitializePlayerInventory(player)
    end
    
    -- Connecter aux événements de joueur
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerInventory(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    -- Démarrer le nettoyage périodique des objets périmés
    spawn(function()
        while true do
            wait(60) -- Vérifier toutes les minutes
            pcall(function()
                self:CleanupExpiredItems()
            end)
        end
    end)
    
    -- Démarrer la sauvegarde périodique des inventaires en attente
    spawn(function()
        while true do
            wait(30) -- Vérifier toutes les 30 secondes
            
            for userId, isPending in pairs(self.pendingSaves) do
                if isPending then
                    -- Vérifier le dernier temps de sauvegarde
                    local lastSave = self.lastSaveTime[userId] or 0
                    local currentTime = os.time()
                    
                    -- Sauvegarder si l'intervalle s'est écoulé
                    if currentTime - lastSave >= self.saveInterval then
                        pcall(function()
                            self:ProcessSave(userId)
                        end)
                    end
                end
            end
        end
    end)
    
    -- Marquer le service comme initialisé
    self.isInitialized = true
    
    print("InventoryService: Démarré avec succès")
    return self
end

-- Configurer les RemoteEvents
function InventoryService:SetupRemoteEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if not events then
        events = Instance.new("Folder")
        events.Name = "Events"
        events.Parent = ReplicatedStorage
        print("InventoryService: Dossier Events créé dans ReplicatedStorage")
    end
    
    -- Créer les RemoteEvents nécessaires s'ils n'existent pas
    local requiredEvents = {
        "UpdateInventory",
        "Notification",
        "PlayerAction"
    }
    
    for _, eventName in ipairs(requiredEvents) do
        if not events:FindFirstChild(eventName) then
            local event = Instance.new("RemoteEvent")
            event.Name = eventName
            event.Parent = events
            print("InventoryService: RemoteEvent créé - " .. eventName)
        end
    end
    
    -- Stocker les références
    self.remoteEvents = {
        UpdateInventory = events:FindFirstChild("UpdateInventory"),
        Notification = events:FindFirstChild("Notification"),
        PlayerAction = events:FindFirstChild("PlayerAction")
    }
end

return InventoryService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="43">
          <Properties>
            <string name="Name">PlayerService</string>
            <string name="Source">-- src/server/services/PlayerService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)

local PlayerService = {}
PlayerService.__index = PlayerService

-- Créer une instance du service
function PlayerService.new()
    local self = setmetatable({}, PlayerService)
    
    -- Données des joueurs
    self.playerData = {}
    
    -- Constantes
    self.maxAge = 60  -- Âge maximum (en années)
    self.yearInSeconds = 60 * 60  -- 1 heure réelle = 1 an dans le jeu
    self.naturalDeathChance = {
        -- Chances de mort naturelle par an
        [50] = 0.05,  -- 5% de chance de mourir à 50 ans
        [55] = 0.10,  -- 10% de chance à 55 ans
        [60] = 0.25   -- 25% de chance à 60 ans
    }
    
    return self
end

-- Initialiser les données d'un nouveau joueur
function PlayerService:InitializePlayerData(player)
    if self.playerData[player.UserId] then return end
    
    self.playerData[player.UserId] = {
        age = 16,  -- Âge de départ
        ageStartTime = os.time(),  -- Moment où l'âge a commencé
        tribe = nil,  -- Tribu (à implémenter)
        family = {},  -- Famille (parents, enfants)
        isDead = false
    }
    
    -- Mettre à jour le client
    self:UpdateClientPlayerData(player)
    
    -- Démarrer le vieillissement
    self:StartAging(player)
end

-- Gérer le vieillissement d'un joueur
function PlayerService:StartAging(player)
    spawn(function()
        while true do
            wait(10)  -- Vérifier l'âge toutes les 10 secondes
            
            local data = self.playerData[player.UserId]
            if not data or data.isDead then break end
            
            -- Calculer l'âge actuel
            local timeElapsed = os.time() - data.ageStartTime
            local ageInYears = data.age + (timeElapsed / self.yearInSeconds)
            
            -- Mettre à jour l'âge si une année entière est passée
            if math.floor(ageInYears) > data.age then
                data.age = math.floor(ageInYears)
                
                -- Mettre à jour le client
                self:UpdateClientPlayerData(player)
                
                -- Vérifier la mort naturelle
                self:CheckNaturalDeath(player)
            end
        end
    end)
end

-- Vérifier si le joueur meurt de vieillesse
function PlayerService:CheckNaturalDeath(player)
    local data = self.playerData[player.UserId]
    if not data or data.isDead then return end
    
    local currentAge = data.age
    
    -- Parcourir les seuils de probabilité
    for age, chance in pairs(self.naturalDeathChance) do
        if currentAge >= age and math.random() &lt; chance then
            -- Le joueur meurt de vieillesse
            self:HandlePlayerDeath(player, "age")
            return
        end
    end
end

-- Gérer la mort d'un joueur
function PlayerService:HandlePlayerDeath(player, causeOfDeath)
    local data = self.playerData[player.UserId]
    if not data or data.isDead then return end
    
    data.isDead = true
    
    -- Afficher un message de mort
    local deathMessages = {
        ["age"] = "Vous êtes mort de vieillesse à l'âge de " .. data.age .. " ans.",
        ["hunger"] = "Vous êtes mort de faim.",
        ["thirst"] = "Vous êtes mort de soif.",
        ["cold"] = "Vous êtes mort de froid.",
        ["heat"] = "Vous êtes mort de chaleur.",
        ["killed"] = "Vous avez été tué."
    }
    
    local message = deathMessages[causeOfDeath] or "Vous êtes mort."
    
    -- Envoyer le message au joueur (à implémenter avec RemoteEvent)
    print(player.Name .. ": " .. message)
    
    -- Attendre quelques secondes avant la réincarnation
    wait(5)
    
    -- Réincarner le joueur comme enfant d'un autre joueur
    self:ReincarnatePlayer(player)
end

-- Réincarner le joueur comme enfant d'un autre joueur
function PlayerService:ReincarnatePlayer(player)
    -- Trouver un parent potentiel (joueur encore vivant)
    local potentialParents = {}
    
    for userId, data in pairs(self.playerData) do
        if not data.isDead and userId ~= player.UserId then
            table.insert(potentialParents, userId)
        end
    end
    
    -- S'il n'y a pas d'autres joueurs, réinitialiser normalement
    if #potentialParents == 0 then
        self:ResetPlayerData(player)
        return
    end
    
    -- Choisir un parent aléatoire
    local parentUserId = potentialParents[math.random(1, #potentialParents)]
    local parentPlayer = Players:GetPlayerByUserId(parentUserId)
    
    -- Réinitialiser les données du joueur
    self:ResetPlayerData(player, parentUserId)
    
    -- Si le parent est connecté, ajouter ce joueur à sa famille
    if parentPlayer then
        local parentData = self.playerData[parentUserId]
        table.insert(parentData.family, {
            type = "child",
            userId = player.UserId,
            name = player.Name
        })
        
        -- Informer le parent (à implémenter avec RemoteEvent)
        print(parentPlayer.Name .. ": Un nouvel enfant est né et s'appelle " .. player.Name)
    end
    
    -- Informer le joueur de sa nouvelle vie (à implémenter avec RemoteEvent)
    local parentName = parentPlayer and parentPlayer.Name or "un autre joueur"
    print(player.Name .. ": Vous êtes né en tant qu'enfant de " .. parentName)
    
    -- Faire réapparaître le joueur près de son parent
    if parentPlayer and parentPlayer.Character then
        local character = player.Character or player.CharacterAdded:Wait()
        local parentPos = parentPlayer.Character:GetPivot()
        
        -- Positionner le joueur près du parent
        character:PivotTo(parentPos * CFrame.new(0, 0, 3))
    end
end

-- Réinitialiser les données d'un joueur
function PlayerService:ResetPlayerData(player, parentUserId)
    self.playerData[player.UserId] = {
        age = 0,  -- Nouveau-né
        ageStartTime = os.time(),
        tribe = parentUserId and self.playerData[parentUserId].tribe or nil,
        family = parentUserId and {
            {
                type = "parent",
                userId = parentUserId,
                name = Players:GetNameFromUserIdAsync(parentUserId)
            }
        } or {},
        isDead = false
    }
    
    -- Réinitialiser l'aspect du personnage (taille plus petite pour un enfant)
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid:ScaleTo(0.6)  -- 60% de la taille adulte
    end
    
    -- Mettre à jour le client
    self:UpdateClientPlayerData(player)
    
    -- Redémarrer le vieillissement
    self:StartAging(player)
    
    -- Réinitialiser d'autres services (à implémenter)
    -- Inventaire de base pour un nouveau-né, etc.
end

-- Mettre à jour les données du joueur pour le client
function PlayerService:UpdateClientPlayerData(player)
    -- Dans une implémentation réelle, utilisez RemoteEvent pour synchroniser avec le client
    local data = self.playerData[player.UserId]
    if not data then return end
    
    print("Mise à jour des données pour " .. player.Name .. ":")
    print("  Âge: " .. data.age .. " ans")
    print("  Tribu: " .. (data.tribe or "Aucune"))
    print("  Famille: " .. #data.family .. " membres")
end

-- Mettre à jour l'apparence du joueur en fonction de l'âge
function PlayerService:UpdateAppearanceByAge(player)
    local data = self.playerData[player.UserId]
    if not data then return end
    
    local character = player.Character
    if not character or not character:FindFirstChild("Humanoid") then return end
    
    -- Échelle basée sur l'âge (plus petit quand jeune, taille adulte à 16 ans)
    local scale = math.min(1, 0.6 + (data.age / 16) * 0.4)
    
    -- Appliquer l'échelle
    humanoid:ScaleTo(scale)
    
    -- D'autres modifications d'apparence peuvent être ajoutées ici
    -- (cheveux gris pour les personnes âgées, etc.)
end

-- Gérer les événements de caractère
function PlayerService:SetupCharacterEvents(player)
    -- Quand le joueur obtient un nouveau personnage
    player.CharacterAdded:Connect(function(character)
        -- Mettre à jour l'apparence en fonction de l'âge
        self:UpdateAppearanceByAge(player)
        
        -- Gérer d'autres événements liés au personnage
        character.Humanoid.Died:Connect(function()
            -- Si la mort est causée par une réincarnation, ignorer
            local data = self.playerData[player.UserId]
            if data and not data.isDead then
                self:HandlePlayerDeath(player, "killed")
            end
        end)
    end)
end

function PlayerService:Start()
    -- Initialiser les joueurs actuels
    for _, player in pairs(Players:GetPlayers()) do
        self:InitializePlayerData(player)
        self:SetupCharacterEvents(player)
    end
    
    -- Gérer les événements de joueur
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerData(player)
        self:SetupCharacterEvents(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        -- Sauvegarder les données si nécessaire
        -- Dans une implémentation complète, utilisez DataStore
    end)
end

return PlayerService</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="44">
          <Properties>
            <string name="Name">ResourceService</string>
            <string name="Source"><![CDATA[-- src/server/services/ResourceService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)
local ItemTypes = require(Shared.constants.ItemTypes)

local ResourceService = {}
ResourceService.__index = ResourceService

-- Créer une instance du service
function ResourceService.new()
    local self = setmetatable({}, ResourceService)
    
    -- Stockage des ressources
    self.resources = {}
    
    -- Ressources pour test initial
    self.resourceTypes = {
        ["wood"] = {
            name = "Arbre",
            model = "rbxassetid://12345680", -- À remplacer par un ID réel
            harvestTool = "axe",
            minHarvestAmount = GameSettings.Resources.harvestAmount.wood.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.wood.max or 3,
            respawnTime = GameSettings.Resources.respawnTime.wood or 300, -- 5 minutes
            techLevel = "stone"
        },
        ["stone"] = {
            name = "Pierre",
            model = "rbxassetid://12345681", -- À remplacer par un ID réel
            harvestTool = "pickaxe",
            minHarvestAmount = GameSettings.Resources.harvestAmount.stone.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.stone.max or 2,
            respawnTime = GameSettings.Resources.respawnTime.stone or 600, -- 10 minutes
            techLevel = "stone"
        },
        ["fiber"] = {
            name = "Plantes fibreuses",
            model = "rbxassetid://12345682", -- À remplacer par un ID réel
            harvestTool = nil, -- Pas d'outil requis
            minHarvestAmount = GameSettings.Resources.harvestAmount.fiber.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.fiber.max or 4,
            respawnTime = GameSettings.Resources.respawnTime.fiber or 180, -- 3 minutes
            techLevel = "stone"
        },
        ["clay"] = {
            name = "Argile",
            model = "rbxassetid://12345683", -- À remplacer par un ID réel
            harvestTool = nil, -- Pas d'outil requis
            minHarvestAmount = GameSettings.Resources.harvestAmount.clay.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.clay.max or 3,
            respawnTime = GameSettings.Resources.respawnTime.clay or 480, -- 8 minutes
            techLevel = "stone"
        },
        ["berry_bush"] = {
            name = "Buisson de baies",
            model = "rbxassetid://12345684", -- À remplacer par un ID réel
            harvestTool = nil, -- Pas d'outil requis
            minHarvestAmount = GameSettings.Resources.harvestAmount.berries.min or 2,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.berries.max or 5,
            respawnTime = GameSettings.Resources.respawnTime.berry_bush or 240, -- 4 minutes
            techLevel = "stone",
            yieldType = "berries" -- Type d'objet à donner (différent du nom de la ressource)
        },
        ["copper_ore"] = {
            name = "Minerai de cuivre",
            model = "rbxassetid://12345685", -- À remplacer par un ID réel
            harvestTool = "pickaxe",
            minHarvestAmount = GameSettings.Resources.harvestAmount.copper_ore.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.copper_ore.max or 2,
            respawnTime = GameSettings.Resources.respawnTime.copper_ore or 900, -- 15 minutes
            techLevel = "stone"
        },
        ["tin_ore"] = {
            name = "Minerai d'étain",
            model = "rbxassetid://12345686", -- À remplacer par un ID réel
            harvestTool = "pickaxe",
            minHarvestAmount = GameSettings.Resources.harvestAmount.tin_ore.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.tin_ore.max or 2,
            respawnTime = GameSettings.Resources.respawnTime.tin_ore or 900, -- 15 minutes
            techLevel = "stone"
        },
        ["iron_ore"] = {
            name = "Minerai de fer",
            model = "rbxassetid://12345687", -- À remplacer par un ID réel
            harvestTool = "pickaxe",
            minHarvestAmount = GameSettings.Resources.harvestAmount.iron_ore.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.iron_ore.max or 2,
            respawnTime = GameSettings.Resources.respawnTime.iron_ore or 1200, -- 20 minutes
            techLevel = "bronze"
        },
        ["gold_ore"] = {
            name = "Minerai d'or",
            model = "rbxassetid://12345688", -- À remplacer par un ID réel
            harvestTool = "pickaxe",
            minHarvestAmount = GameSettings.Resources.harvestAmount.gold_ore.min or 1,
            maxHarvestAmount = GameSettings.Resources.harvestAmount.gold_ore.max or 1,
            respawnTime = GameSettings.Resources.respawnTime.gold_ore or 1800, -- 30 minutes
            techLevel = "iron"
        }
    }
    
    -- Références aux services
    self.inventoryService = nil
    self.playerService = nil
    
    -- Références aux RemoteEvents
    self.remoteEvents = {}
    
    return self
end

-- Générer des ressources dans le monde
function ResourceService:GenerateResources()
    -- Obtenir le dossier des ressources dans l'espace de travail
    local resourcesFolder = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Resources")
    
    if not resourcesFolder then
        resourcesFolder = Instance.new("Folder")
        resourcesFolder.Name = "Resources"
        
        if Workspace:FindFirstChild("Map") then
            resourcesFolder.Parent = Workspace.Map
        else
            local mapFolder = Instance.new("Folder")
            mapFolder.Name = "Map"
            mapFolder.Parent = Workspace
            resourcesFolder.Parent = mapFolder
        end
    end
    
    -- Créer des dossiers pour chaque type de ressource
    for resourceType, _ in pairs(self.resourceTypes) do
        if not resourcesFolder:FindFirstChild(resourceType) then
            local typeFolder = Instance.new("Folder")
            typeFolder.Name = resourceType
            typeFolder.Parent = resourcesFolder
        end
    end
    
    -- Générer des ressources de test
    self:GenerateTestResources(resourcesFolder)
    
    print("ResourceService: Ressources générées dans le monde")
end

-- Générer des ressources de test pour le développement
function ResourceService:GenerateTestResources(resourcesFolder)
    -- Configuration pour la génération de test
    local testResourceCounts = {
        ["wood"] = 50,        -- 50 arbres
        ["stone"] = 80,       -- 80 pierres
        ["fiber"] = 60,       -- 60 plantes fibreuses
        ["clay"] = 30,        -- 30 dépôts d'argile
        ["berry_bush"] = 40,  -- 40 buissons de baies
        ["copper_ore"] = 20,  -- 20 minerais de cuivre
        ["tin_ore"] = 15,     -- 15 minerais d'étain
        ["iron_ore"] = 10,    -- 10 minerais de fer
        ["gold_ore"] = 5      -- 5 minerais d'or
    }
    
    -- Dimensions de la zone de jeu pour la génération aléatoire
    local minX, maxX = -500, 500
    local minZ, maxZ = -500, 500
    
    -- Générer chaque type de ressource
    for resourceType, count in pairs(testResourceCounts) do
        local typeFolder = resourcesFolder:FindFirstChild(resourceType)
        
        -- Nettoyer le dossier existant
        typeFolder:ClearAllChildren()
        
        -- Générer les ressources avec retry si position invalide
        local attempts = 0
        local maxAttempts = count * 3  -- Permettre 3x plus de tentatives
        local generated = 0
        
        while generated < count and attempts < maxAttempts do
            attempts = attempts + 1
            
            local position = Vector3.new(
                math.random(minX, maxX),
                0, -- La hauteur sera ajustée par RayCast
                math.random(minZ, maxZ)
            )
            
            local resource = self:CreateResourceInstance(resourceType, typeFolder, position)
            if resource then
                generated = generated + 1
            end
        end
        
        if generated < count then
            warn(string.format("ResourceService: Seulement %d/%d %s générés (certaines positions étaient occupées)", 
                generated, count, resourceType))
        end
    end
end

-- Vérifier si une position est valide pour spawner une ressource
function ResourceService:IsValidResourcePosition(position, resourceType)
    -- Vérifier qu'il n'y a pas de construction à cet endroit
    local structuresFolder = Workspace:FindFirstChild("Structures")
    if structuresFolder then
        -- Vérifier la distance avec toutes les structures
        for _, structure in ipairs(structuresFolder:GetDescendants()) do
            if structure:IsA("BasePart") then
                local distance = (structure.Position - position).Magnitude
                -- Exiger une distance minimale de 8 studs des structures
                if distance < 8 then
                    return false
                end
            end
        end
    end
    
    -- Vérifier qu'il n'y a pas déjà une autre ressource trop proche
    local resourcesFolder = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Resources")
    if resourcesFolder then
        for _, typeFolder in ipairs(resourcesFolder:GetChildren()) do
            for _, existingResource in ipairs(typeFolder:GetChildren()) do
                if existingResource:IsA("Model") and existingResource.PrimaryPart then
                    local distance = (existingResource.PrimaryPart.Position - position).Magnitude
                    -- Distance minimale entre ressources : 5 studs
                    if distance < 5 then
                        return false
                    end
                end
            end
        end
    end
    
    return true
end

-- Créer une instance de ressource dans le monde
function ResourceService:CreateResourceInstance(resourceType, parent, position)
    local resourceInfo = self.resourceTypes[resourceType]
    if not resourceInfo then return end
    
    -- Vérifier que la position est valide (pas sur une construction)
    if not self:IsValidResourcePosition(position, resourceType) then
        return nil
    end
    
    -- Créer un modèle de base pour la ressource
    local resource = Instance.new("Model")
    resource.Name = resourceInfo.name
    
    -- Ajouter une part principale
    local primaryPart = Instance.new("Part")
    primaryPart.Name = "PrimaryPart"
    primaryPart.Anchored = true
    primaryPart.CanCollide = true
    
    -- Définir la taille en fonction du type de ressource
    if resourceType == "wood" then
        primaryPart.Size = Vector3.new(2, 10, 2)
        primaryPart.Color = Color3.fromRGB(121, 85, 58) -- Couleur bois
        primaryPart.Material = Enum.Material.Wood
    elseif resourceType == "stone" or resourceType:find("_ore") then
        primaryPart.Size = Vector3.new(4, 3, 4)
        primaryPart.Color = Color3.fromRGB(150, 150, 150) -- Couleur pierre
        primaryPart.Material = Enum.Material.Rock
        
        -- Couleurs spécifiques pour les minerais
        if resourceType == "copper_ore" then
            primaryPart.Color = Color3.fromRGB(184, 115, 51) -- Couleur cuivre
        elseif resourceType == "tin_ore" then
            primaryPart.Color = Color3.fromRGB(200, 200, 200) -- Couleur étain
        elseif resourceType == "iron_ore" then
            primaryPart.Color = Color3.fromRGB(165, 150, 140) -- Couleur fer
        elseif resourceType == "gold_ore" then
            primaryPart.Color = Color3.fromRGB(212, 175, 55) -- Couleur or
        end
    elseif resourceType == "berry_bush" then
        primaryPart.Size = Vector3.new(2, 2, 2)
        primaryPart.Color = Color3.fromRGB(30, 100, 30) -- Couleur buisson
        primaryPart.Material = Enum.Material.Grass
        
        -- Ajouter des baies visibles
        local berries = Instance.new("Part")
        berries.Name = "Berries"
        berries.Size = Vector3.new(1, 1, 1)
        berries.Position = primaryPart.Position + Vector3.new(0, 0.5, 0)
        berries.Anchored = true
        berries.CanCollide = false
        berries.Color = Color3.fromRGB(200, 30, 30) -- Couleur baies rouges
        berries.Material = Enum.Material.Plastic
        berries.Shape = Enum.PartType.Ball
        berries.Transparency = 0
        berries.Parent = resource
        
        -- Weld pour les baies
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = primaryPart
        weld.Part1 = berries
        weld.Parent = resource
    elseif resourceType == "fiber" then
        primaryPart.Size = Vector3.new(2, 1, 2)
        primaryPart.Color = Color3.fromRGB(120, 190, 80) -- Couleur plante
        primaryPart.Material = Enum.Material.Grass
    elseif resourceType == "clay" then
        primaryPart.Size = Vector3.new(3, 1, 3)
        primaryPart.Color = Color3.fromRGB(180, 150, 130) -- Couleur argile
        primaryPart.Material = Enum.Material.Sand
    else
        primaryPart.Size = Vector3.new(2, 2, 2)
        primaryPart.Material = Enum.Material.Plastic
    end
    
    -- Effectuer un RayCast pour placer la ressource sur le sol
    local rayStart = position + Vector3.new(0, 100, 0)
    local rayDirection = Vector3.new(0, -200, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {resource}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = Workspace:Raycast(rayStart, rayDirection, raycastParams)
    local hitPart, hitPoint, hitNormal
    if raycastResult then
        hitPart = raycastResult.Instance
        hitPoint = raycastResult.Position
        hitNormal = raycastResult.Normal
    end
    
    if hitPart then
        -- Placer la ressource sur le sol
        local height = primaryPart.Size.Y / 2
        primaryPart.Position = hitPoint + Vector3.new(0, height, 0)
    else
        -- Position par défaut si le RayCast échoue
        primaryPart.Position = position
    end
    
    primaryPart.Parent = resource
    resource.PrimaryPart = primaryPart
    
    -- Ajouter un attribut pour identifier le type de ressource
    resource:SetAttribute("ResourceType", resourceType)
    
    -- Ajouter un ClickDetector pour l'interaction
    local clickDetector = Instance.new("ClickDetector")
    clickDetector.MaxActivationDistance = 10
    clickDetector.Parent = primaryPart
    
    -- Connecter l'événement de clic
    clickDetector.MouseClick:Connect(function(player)
        self:HandleResourceClick(player, resource)
    end)
    
    -- Générer un ID unique pour cette ressource
    local resourceId = resourceType .. "_" .. tostring(resource.Name) .. "_" .. tostring(resource:GetDebugId())
    
    -- Ajouter l'instance au parent
    resource.Parent = parent
    
    -- Stocker la référence pour une utilisation ultérieure
    self.resources[resourceId] = {
        instance = resource,
        type = resourceType,
        harvestable = true,
        respawnTime = resourceInfo.respawnTime,
        position = primaryPart.Position
    }
    
    return resource
end

-- Gérer le clic sur une ressource
function ResourceService:HandleResourceClick(player, resourceInstance)
    local resourceType = resourceInstance:GetAttribute("ResourceType")
    if not resourceType then return end
    
    local resourceId = resourceType .. "_" .. tostring(resourceInstance.Name) .. "_" .. tostring(resourceInstance:GetDebugId())
    local resourceData = self.resources[resourceId]
    
    if not resourceData or not resourceData.harvestable then
        -- La ressource n'est pas récoltable (peut-être en cours de réapparition)
        self:SendNotification(player, "Cette ressource n'est pas disponible actuellement", "info")
        return
    end
    
    -- Vérifier si le joueur a l'outil approprié
    local canHarvest, toolMultiplier = self:CheckHarvestRequirements(player, resourceType)
    
    if canHarvest then
        -- Récolter la ressource
        self:HarvestResource(player, resourceId, toolMultiplier)
    else
        -- Informer le joueur qu'il a besoin de l'outil approprié
        local toolRequired = self.resourceTypes[resourceType].harvestTool
        if toolRequired then
            self:SendNotification(player, "Vous avez besoin d'un(e) " .. toolRequired .. " pour récolter cette ressource", "warning")
        else
            -- Tenter quand même de récolter mais avec un multiplicateur de 1
            self:HarvestResource(player, resourceId, 1)
        end
    end
end

-- Vérifier si le joueur peut récolter une ressource
function ResourceService:CheckHarvestRequirements(player, resourceType)
    local resourceInfo = self.resourceTypes[resourceType]
    if not resourceInfo then return false, 1 end
    
    -- Si aucun outil n'est requis, permettre la récolte directe
    if not resourceInfo.harvestTool then
        return true, 1
    end
    
    -- Vérifier le niveau technologique requis
    if self.playerService and resourceInfo.techLevel then
        local playerTechLevel = self:GetPlayerTechLevel(player)
        
        -- Vérifier si le joueur a le niveau technologique requis
        local techLevels = {
            ["stone"] = 1,
            ["bronze"] = 2,
            ["iron"] = 3,
            ["gold"] = 4
        }
        
        local requiredLevel = techLevels[resourceInfo.techLevel] or 1
        local playerLevel = techLevels[playerTechLevel] or 1
        
        if playerLevel < requiredLevel then
            self:SendNotification(player, "Vous n'avez pas le niveau technologique requis pour cette ressource", "error")
            return false, 1
        end
    end
    
    -- Vérifier si le joueur a l'outil approprié équipé
    if not self.inventoryService then
        return true, 1  -- Si InventoryService n'est pas disponible, autoriser par défaut
    end
    
    local inventory = self.inventoryService.playerInventories[player.UserId]
    if not inventory or not inventory.equipped then return false, 1 end
    
    -- Obtenir l'outil équipé
    local equippedToolSlot = inventory.equipped["tool"]
    if not equippedToolSlot or not inventory.items[equippedToolSlot] then return false, 1 end
    
    local equippedTool = inventory.items[equippedToolSlot]
    local toolType = ItemTypes[equippedTool.id]
    
    if not toolType or not toolType.toolType then return false, 1 end
    
    -- Vérifier si le type d'outil correspond
    if toolType.toolType == resourceInfo.harvestTool then
        -- L'outil est du bon type, retourner le multiplicateur de récolte
        local multiplier = 1
        if toolType.gatherMultiplier and toolType.gatherMultiplier[resourceType] then
            multiplier = toolType.gatherMultiplier[resourceType]
        end
        return true, multiplier
    end
    
    return false, 1
end

-- Obtenir le niveau technologique d'un joueur
function ResourceService:GetPlayerTechLevel(player)
    if self.playerService and self.playerService.playerData and self.playerService.playerData[player.UserId] then
        return self.playerService.playerData[player.UserId].techLevel or "stone"
    end
    
    -- Par défaut, retourner le niveau de base
    return "stone"
end

-- Récolter une ressource
function ResourceService:HarvestResource(player, resourceId, toolMultiplier)
    local resourceData = self.resources[resourceId]
    if not resourceData or not resourceData.harvestable then return end
    
    local resourceType = resourceData.type
    local resourceInfo = self.resourceTypes[resourceType]
    
    -- Marquer la ressource comme non récoltable
    resourceData.harvestable = false
    
    -- Déterminer la quantité récoltée
    local baseAmount = math.random(resourceInfo.minHarvestAmount, resourceInfo.maxHarvestAmount)
    local amount = math.floor(baseAmount * toolMultiplier)
    
    -- Déterminer le type d'objet à donner (peut être différent du type de ressource)
    local itemType = resourceInfo.yieldType or resourceType
    
    -- Ajouter les objets à l'inventaire du joueur
    local success = false
    if self.inventoryService then
        success = self.inventoryService:AddItemToInventory(player, itemType, amount)
    else
        -- Si InventoryService n'est pas disponible, considérer comme réussi
        success = true
    end
    
    if success then
        -- Informer le joueur
        self:SendNotification(player, "Vous avez récolté " .. amount .. " " .. (ItemTypes[itemType] and ItemTypes[itemType].name or itemType), "success")
        
        -- Envoyer un événement au client pour les effets visuels et les animations
        if self.remoteEvents.ResourceHarvest then
            self.remoteEvents.ResourceHarvest:FireClient(player, itemType, amount)
        end
        
        -- Cacher temporairement la ressource (apparence de "récolté")
        local resourceInstance = resourceData.instance
        if resourceInstance and resourceInstance.Parent then
            -- Réduire la transparence pour indiquer que la ressource a été récoltée
            for _, part in pairs(resourceInstance:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Transparency = 0.8
                end
            end
            
            -- Désactiver le ClickDetector
            local clickDetector = resourceInstance.PrimaryPart:FindFirstChild("ClickDetector")
            if clickDetector then
                clickDetector.MaxActivationDistance = 0
            end
        end
        
        -- Programmer la réapparition de la ressource
        self:ScheduleResourceRespawn(resourceId)
    else
        -- L'inventaire est plein ou autre problème
        resourceData.harvestable = true -- Remettre la ressource comme récoltable
        self:SendNotification(player, "Votre inventaire est plein", "error")
    end
    
    return success, amount
end

-- Programmer la réapparition d'une ressource
function ResourceService:ScheduleResourceRespawn(resourceId)
    local resourceData = self.resources[resourceId]
    if not resourceData then return end
    
    -- Utiliser la fonction delay pour programmer la réapparition
    delay(resourceData.respawnTime, function()
        self:RespawnResource(resourceId)
    end)
end

-- Faire réapparaître une ressource
function ResourceService:RespawnResource(resourceId)
    local resourceData = self.resources[resourceId]
    if not resourceData then return end
    
    -- Vérifier si la position est toujours valide (pas de construction construite entre temps)
    if not self:IsValidResourcePosition(resourceData.position, resourceData.type) then
        warn("ResourceService: Impossible de faire réapparaître " .. resourceId .. " - position occupée par une construction")
        
        -- Détruire complètement cette ressource et ne pas la faire réapparaître
        if resourceData.instance then
            resourceData.instance:Destroy()
        end
        self.resources[resourceId] = nil
        return
    end
    
    -- Restaurer l'apparence de la ressource
    local resourceInstance = resourceData.instance
    if resourceInstance and resourceInstance.Parent then
        -- Restaurer la transparence
        for _, part in pairs(resourceInstance:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 0
            end
        end
        
        -- Réactiver le ClickDetector
        local clickDetector = resourceInstance.PrimaryPart:FindFirstChild("ClickDetector")
        if clickDetector then
            clickDetector.MaxActivationDistance = 10
        end
    end
    
    -- Marquer la ressource comme récoltable à nouveau
    resourceData.harvestable = true
    
    print("ResourceService: Ressource " .. resourceId .. " réapparue")
end

-- Envoi d'une notification au joueur
function ResourceService:SendNotification(player, message, messageType)
    if self.remoteEvents.Notification then
        self.remoteEvents.Notification:FireClient(player, message, messageType or "info")
    else
        -- Fallback si RemoteEvent n'est pas disponible
        print("Notification pour " .. player.Name .. ": " .. message)
    end
end

-- Démarrer le service
function ResourceService:Start(services)
    print("ResourceService: Démarrage...")
    
    -- Récupérer les références aux autres services
    self.inventoryService = services.InventoryService
    self.playerService = services.PlayerService
    
    -- Récupérer les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            ResourceHarvest = Events:FindFirstChild("ResourceHarvest"),
            Notification = Events:FindFirstChild("Notification")
        }
    else
        warn("ResourceService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Générer les ressources initiales
    self:GenerateResources()
    
    print("ResourceService: Démarré avec succès")
    return self
end

return ResourceService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="45">
          <Properties>
            <string name="Name">SurvivalService</string>
            <string name="Source"><![CDATA[-- src/server/services/SurvivalService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)

local SurvivalService = {}
SurvivalService.__index = SurvivalService

-- Créer une instance du service
function SurvivalService.new()
    local self = setmetatable({}, SurvivalService)
    
    -- Données de survie des joueurs
    self.playerSurvivalData = {}
    
    -- Constantes - Utilisation des valeurs de GameSettings avec fallbacks
    self.maxHunger = GameSettings.Survival.maxHunger or 100
    self.maxThirst = GameSettings.Survival.maxThirst or 100
    self.maxTemperature = 100 -- Valeur fixe car pas dans GameSettings
    self.maxEnergy = GameSettings.Survival.maxEnergy or 100
    
    -- Taux de décroissance (par seconde)
    self.hungerDecayRate = GameSettings.Survival.hungerDecayRate or 0.05
    self.thirstDecayRate = GameSettings.Survival.thirstDecayRate or 0.08
    self.energyDecayRate = GameSettings.Survival.energyDecayRate or 0.03
    self.energyRecoveryRate = GameSettings.Survival.energyRecoveryRate or 0.1
    
    -- Seuils critiques
    self.criticalHunger = GameSettings.Survival.criticalHungerThreshold or 15
    self.criticalThirst = GameSettings.Survival.criticalThirstThreshold or 10
    self.criticalEnergy = GameSettings.Survival.criticalEnergyThreshold or 10
    self.criticalColdTemperature = GameSettings.Survival.criticalColdThreshold or 20
    self.criticalHotTemperature = GameSettings.Survival.criticalHeatThreshold or 80
    
    -- Intervalles de temps
    self.updateInterval = 1  -- Intervalle de mise à jour en secondes
    self.notificationInterval = 60 -- Intervalle pour les notifications en secondes
    
    -- Gestion des timeouts et intervalles
    self.lastNotificationTimes = {} -- [userId][type] = timestamp
    
    -- Références aux services (seront injectés dans Start)
    self.playerService = nil
    self.inventoryService = nil
    
    -- Events RemoteEvent
    self.remoteEvents = {}
    
    return self
end

-- Initialiser les données de survie pour un joueur
function SurvivalService:InitializePlayerSurvival(player)
    if not player or not player:IsA("Player") then
        warn("SurvivalService:InitializePlayerSurvival - player argument invalide")
        return
    end
    
    local userId = player.UserId
    
    -- Vérifier si les données existent déjà
    if self.playerSurvivalData[userId] then 
        return 
    end
    
    -- Initialiser les données avec des valeurs par défaut
    self.playerSurvivalData[userId] = {
        hunger = self.maxHunger,       -- 100 = rassasié, 0 = affamé
        thirst = self.maxThirst,       -- 100 = hydraté, 0 = assoiffé
        temperature = 50,              -- 0 = gelé, 100 = brûlant, 50 = idéal
        energy = self.maxEnergy,       -- 100 = plein d'énergie, 0 = épuisé
        isSleeping = false,            -- Si le joueur est en train de dormir
        lastUpdateTime = os.time(),    -- Dernière mise à jour des stats
        effects = {},                  -- Effets temporaires (maladies, etc.)
        sleepingLocation = nil         -- Endroit où le joueur dort (pour bonus)
    }
    
    -- Initialiser le suivi des notifications
    self.lastNotificationTimes[userId] = {
        hunger = 0,
        thirst = 0,
        energy = 0,
        temperature = 0
    }
    
    -- Mettre à jour le client avec les données initiales
    self:UpdateClientSurvivalData(player)
    
    print("SurvivalService: Données de survie initialisées pour " .. player.Name)
end

-- Mettre à jour périodiquement les données de survie
function SurvivalService:UpdateSurvivalData(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then 
        return 
    end
    
    local currentTime = os.time()
    local timeDelta = currentTime - data.lastUpdateTime
    
    -- Si le délai est anormalement long (plus de 5 minutes), limiter pour éviter une chute drastique
    if timeDelta > 300 then
        timeDelta = 300
        print("SurvivalService: Délai anormalement long pour " .. player.Name .. " - limité à 5 minutes")
    end
    
    -- Mettre à jour la faim - seulement si le joueur n'est pas endormi
    if not data.isSleeping then
        data.hunger = math.max(0, data.hunger - (self.hungerDecayRate * timeDelta))
    else
        -- Pendant le sommeil, la faim décroit plus lentement
        data.hunger = math.max(0, data.hunger - (self.hungerDecayRate * 0.5 * timeDelta))
    end
    
    -- Mettre à jour la soif - toujours active même pendant le sommeil
    data.thirst = math.max(0, data.thirst - (self.thirstDecayRate * timeDelta))
    
    -- Mettre à jour l'énergie
    if not data.isSleeping then
        -- Pendant l'éveil, l'énergie diminue
        data.energy = math.max(0, data.energy - (self.energyDecayRate * timeDelta))
    else
        -- Pendant le sommeil, l'énergie récupère
        -- Appliquer un bonus selon l'endroit où le joueur dort
        local recoveryMultiplier = 1
        
        if data.sleepingLocation == "wooden_bed" then
            recoveryMultiplier = 1.5
        elseif data.sleepingLocation == "comfortable_bed" then
            recoveryMultiplier = 2
        end
        
        data.energy = math.min(self.maxEnergy, data.energy + (self.energyRecoveryRate * recoveryMultiplier * timeDelta))
        
        -- Si l'énergie est complètement récupérée, réveiller automatiquement le joueur
        if data.energy >= self.maxEnergy then
            self:StopSleeping(player)
            self:SendNotification(player, "Vous vous êtes réveillé, complètement reposé!", "info")
        end
    end
    
    -- Mettre à jour la température en fonction de l'environnement
    local newTemperature = self:CalculateEnvironmentTemperature(player)
    data.temperature = data.temperature + (newTemperature - data.temperature) * 0.1 * timeDelta -- Changement progressif
    
    -- Appliquer les effets de l'environnement
    self:ApplyEnvironmentalEffects(player)
    
    -- Vérifier les conditions critiques
    self:CheckCriticalConditions(player)
    
    -- Mettre à jour le temps de dernière mise à jour
    data.lastUpdateTime = currentTime
    
    -- Mettre à jour le client
    self:UpdateClientSurvivalData(player)
end

-- Vérifier les conditions critiques de survie
function SurvivalService:CheckCriticalConditions(player)
    if not player or not player:IsA("Player") then return end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    local currentTime = os.time()
    local isNotificationTimeoutExpired = function(type)
        return (currentTime - (self.lastNotificationTimes[userId][type] or 0)) >= self.notificationInterval
    end
    
    -- Réinitialiser la vitesse de marche à chaque vérification
    local baseWalkSpeed = humanoid.WalkSpeed
    local speedMultiplier = 1
    
    -- Vérifier la faim
    if data.hunger <= 0 then
        -- Le joueur meurt de faim
        if humanoid.Health > 0 then
            humanoid.Health = 0
            if self.playerService then
                self.playerService:HandlePlayerDeath(player, "hunger")
            end
        end
        return
    elseif data.hunger <= self.criticalHunger then
        -- Faim critique - appliquer des effets (ralentissement)
        speedMultiplier = speedMultiplier * 0.7
        
        -- Envoyer une notification périodique au joueur
        if isNotificationTimeoutExpired("hunger") then
            self:SendNotification(player, "Vous êtes affamé! Trouvez de la nourriture rapidement.", "warning")
            self.lastNotificationTimes[userId]["hunger"] = currentTime
        end
    end
    
    -- Vérifier la soif
    if data.thirst <= 0 then
        -- Le joueur meurt de soif
        if humanoid.Health > 0 then
            humanoid.Health = 0
            if self.playerService then
                self.playerService:HandlePlayerDeath(player, "thirst")
            end
        end
        return
    elseif data.thirst <= self.criticalThirst then
        -- Soif critique - appliquer des effets
        speedMultiplier = speedMultiplier * 0.7
        
        -- Envoyer une notification périodique au joueur
        if isNotificationTimeoutExpired("thirst") then
            self:SendNotification(player, "Vous êtes déshydraté! Trouvez de l'eau rapidement.", "warning")
            self.lastNotificationTimes[userId]["thirst"] = currentTime
        end
    end
    
    -- Vérifier l'énergie
    if data.energy <= self.criticalEnergy then
        -- Fatigue critique - appliquer des effets
        speedMultiplier = speedMultiplier * 0.8
        
        -- Envoyer une notification périodique au joueur
        if isNotificationTimeoutExpired("energy") then
            self:SendNotification(player, "Vous êtes épuisé! Trouvez un endroit pour dormir.", "warning")
            self.lastNotificationTimes[userId]["energy"] = currentTime
        end
    end
    
    -- Vérifier la température
    local tempDamage = GameSettings.Survival.temperatureDamageAmount or 1
    local tempDamageApplied = false
    
    if data.temperature <= self.criticalColdTemperature then
        -- Trop froid - appliquer des dégâts progressifs
        humanoid.Health = math.max(0, humanoid.Health - tempDamage)
        tempDamageApplied = true
        
        -- Envoyer une notification périodique au joueur
        if isNotificationTimeoutExpired("temperature") then
            self:SendNotification(player, "Vous avez froid! Cherchez un feu ou un abri.", "warning")
            self.lastNotificationTimes[userId]["temperature"] = currentTime
        end
        
        -- Si la santé atteint 0, gérer la mort par le froid
        if humanoid.Health <= 0 and self.playerService then
            self.playerService:HandlePlayerDeath(player, "cold")
            return
        end
    elseif data.temperature >= self.criticalHotTemperature then
        -- Trop chaud - appliquer des dégâts progressifs
        humanoid.Health = math.max(0, humanoid.Health - tempDamage)
        tempDamageApplied = true
        
        -- Envoyer une notification périodique au joueur
        if isNotificationTimeoutExpired("temperature") then
            self:SendNotification(player, "Vous avez trop chaud! Trouvez de l'ombre.", "warning")
            self.lastNotificationTimes[userId]["temperature"] = currentTime
        end
        
        -- Si la santé atteint 0, gérer la mort par la chaleur
        if humanoid.Health <= 0 and self.playerService then
            self.playerService:HandlePlayerDeath(player, "heat")
            return
        end
    end
    
    -- Appliquer le modificateur de vitesse
    humanoid.WalkSpeed = baseWalkSpeed * speedMultiplier
end

-- Calculer la température environnementale pour un joueur
function SurvivalService:CalculateEnvironmentTemperature(player)
    if not player or not player:IsA("Player") then 
        return 50 -- Valeur par défaut
    end
    
    local character = player.Character
    if not character then 
        return 50 
    end
    
    local position = character:GetPrimaryPartCFrame().Position
    
    -- Vérifier si le joueur est à l'intérieur d'un bâtiment (ou abri)
    local isIndoors = self:IsPlayerIndoors(player)
    
    -- Vérifier la proximité avec des sources de chaleur
    local nearHeatSource, heatSourceIntensity = self:IsNearHeatSource(player)
    
    -- Obtenir le temps actuel (heure de la journée)
    local isNight = self:IsNightTime()
    
    -- Température de base selon l'heure
    local baseTemperature = isNight and 35 or 50 -- Plus froid la nuit
    
    -- Adapter la température en fonction de l'environnement
    if isIndoors then
        baseTemperature = baseTemperature + 10 -- Plus chaud à l'intérieur
    end
    
    if nearHeatSource then
        baseTemperature = baseTemperature + heatSourceIntensity
    end
    
    -- Vérifier aussi l'équipement du joueur
    baseTemperature = baseTemperature + self:GetTemperatureModifierFromEquipment(player)
    
    -- Limiter la température entre 0 et 100
    return math.clamp(baseTemperature, 0, 100)
end

-- Vérifier si le joueur est à l'intérieur d'un bâtiment
function SurvivalService:IsPlayerIndoors(player)
    if not player or not player:IsA("Player") then 
        return false 
    end
    
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then 
        return false 
    end
    
    local position = character.HumanoidRootPart.Position
    
    -- Lancer un rayon vers le haut pour vérifier s'il y a un toit
    local rayOrigin = position
    local rayDirection = Vector3.new(0, 20, 0) -- Vers le haut
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    local hitPart = raycastResult and raycastResult.Instance
    
    -- Si un toit est détecté, le joueur est probablement à l'intérieur
    return hitPart ~= nil
end

-- Vérifier si le joueur est près d'une source de chaleur
function SurvivalService:IsNearHeatSource(player)
    if not player or not player:IsA("Player") then 
        return false, 0 
    end
    
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then 
        return false, 0 
    end
    
    local position = character.HumanoidRootPart.Position
    
    -- Obtenir toutes les sources de chaleur (feux de camp, fours, etc.)
    local heatSources = workspace:FindFirstChild("Structures")
    if not heatSources then
        return false, 0
    end
    
    -- Parcourir toutes les structures pour trouver des sources de chaleur
    for _, structure in ipairs(heatSources:GetChildren()) do
        -- Vérifier si c'est une source de chaleur
        if structure:GetAttribute("HeatSource") and structure:FindFirstChild("PrimaryPart") then
            local heatPosition = structure.PrimaryPart.Position
            local distance = (position - heatPosition).Magnitude
            
            -- Obtenir le rayon et l'intensité
            local heatRadius = structure:GetAttribute("HeatRadius") or 10
            local heatIntensity = structure:GetAttribute("HeatIntensity") or 15
            
            -- Calculer l'intensité en fonction de la distance
            if distance <= heatRadius then
                local distanceFactor = 1 - (distance / heatRadius)
                return true, heatIntensity * distanceFactor
            end
        end
    end
    
    return false, 0
end

-- Vérifier s'il fait nuit
function SurvivalService:IsNightTime()
    -- Dans une implémentation complète, vérifier avec TimeService
    local currentTime = game:GetService("Lighting").ClockTime
    
    -- Considérer la nuit de 19h à 6h
    return currentTime >= 19 or currentTime < 6
end

-- Obtenir les modificateurs de température des équipements
function SurvivalService:GetTemperatureModifierFromEquipment(player)
    if not player or not player:IsA("Player") then 
        return 0 
    end
    
    local modifier = 0
    
    -- Vérifier les vêtements équipés
    if self.inventoryService then
        local userId = player.UserId
        local inventory = self.inventoryService.playerInventories[userId]
        
        if inventory and inventory.equipped then
            local ItemTypes = require(Shared.constants.ItemTypes)
            
            -- Vérifier chaque type d'équipement
            for itemId, slotNumber in pairs(inventory.equipped) do
                local item = inventory.items[slotNumber]
                if item then
                    local itemType = ItemTypes[item.id]
                    if itemType and itemType.temperatureModifier then
                        modifier = modifier + itemType.temperatureModifier
                    end
                end
            end
        end
    end
    
    return modifier
end

-- Appliquer les effets de l'environnement sur le joueur
function SurvivalService:ApplyEnvironmentalEffects(player)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    -- Fonction pour gérer les effets d'environnement supplémentaires
    -- Par exemple: pluie, tempêtes, désert chaud, etc.
    
    -- Pour l'instant, ces effets sont pris en compte dans CalculateEnvironmentTemperature
    -- Cette méthode pourrait être étendue pour d'autres effets comme:
    -- - Malus de vision dans le brouillard ou la tempête
    -- - Effets de statut comme "Trempé" ou "Gelé"
    -- - Effets visuels comme le givre à l'écran quand il fait très froid
end

-- Manger un aliment
function SurvivalService:ConsumeFood(player, foodItemId)
    if not player or not player:IsA("Player") then 
        return false 
    end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then 
        return false 
    end
    
    -- Vérifier que le joueur a l'aliment dans son inventaire
    if self.inventoryService and not self.inventoryService:HasItemInInventory(player, foodItemId, 1) then
        self:SendNotification(player, "Vous n'avez pas cet aliment dans votre inventaire", "error")
        return false
    end
    
    -- Récupérer les valeurs nutritives de l'aliment
    local ItemTypes = require(Shared.constants.ItemTypes)
    local foodItem = ItemTypes[foodItemId]
    
    if not foodItem then 
        return false 
    end
    
    local foodValue = foodItem.foodValue or 25  -- Valeur par défaut
    
    -- Augmenter la faim
    data.hunger = math.min(self.maxHunger, data.hunger + foodValue)
    
    -- Si l'aliment fournit également de l'hydratation (comme les fruits)
    if foodItem.drinkValue then
        data.thirst = math.min(self.maxThirst, data.thirst + foodItem.drinkValue)
    end
    
    -- Retirer l'aliment de l'inventaire
    if self.inventoryService then
        self.inventoryService:RemoveItemFromInventory(player, foodItemId, 1)
    end
    
    -- Mettre à jour le client
    self:UpdateClientSurvivalData(player)
    
    -- Envoyer une notification
    self:SendNotification(player, "Vous avez mangé " .. foodItem.name, "success")
    
    -- Jouer l'animation de manger (côté client)
    self:PlayClientAnimation(player, "eat")
    
    return true
end

-- Boire
function SurvivalService:ConsumeDrink(player, drinkItemId)
    if not player or not player:IsA("Player") then 
        return false 
    end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then 
        return false 
    end
    
    -- Vérifier que le joueur a la boisson dans son inventaire
    if self.inventoryService and not self.inventoryService:HasItemInInventory(player, drinkItemId, 1) then
        self:SendNotification(player, "Vous n'avez pas cette boisson dans votre inventaire", "error")
        return false
    end
    
    -- Récupérer les valeurs de la boisson
    local ItemTypes = require(Shared.constants.ItemTypes)
    local drinkItem = ItemTypes[drinkItemId]
    
    if not drinkItem then 
        return false 
    end
    
    local drinkValue = drinkItem.drinkValue or 30  -- Valeur par défaut
    
    -- Augmenter l'hydratation
    data.thirst = math.min(self.maxThirst, data.thirst + drinkValue)
    
    -- Retirer la boisson de l'inventaire
    if self.inventoryService then
        self.inventoryService:RemoveItemFromInventory(player, drinkItemId, 1)
    end
    
    -- Mettre à jour le client
    self:UpdateClientSurvivalData(player)
    
    -- Envoyer une notification
    self:SendNotification(player, "Vous avez bu " .. drinkItem.name, "success")
    
    -- Jouer l'animation de boire (côté client)
    self:PlayClientAnimation(player, "drink")
    
    return true
end

-- Commencer à dormir
function SurvivalService:StartSleeping(player, structureId)
    if not player or not player:IsA("Player") then 
        return false 
    end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then 
        return false 
    end
    
    -- Vérifier si le joueur est déjà en train de dormir
    if data.isSleeping then 
        return true 
    end
    
    -- Marquer comme dormant
    data.isSleeping = true
    
    -- Si un structureId est fourni, stocker l'emplacement de sommeil
    if structureId then
        local sleepingLocation = nil
        
        -- Déterminer le type de lit/endroit où le joueur dort
        if workspace:FindFirstChild("Structures") then
            local structure = workspace.Structures:FindFirstChild(structureId)
            if structure then
                sleepingLocation = structure:GetAttribute("BuildingType")
            end
        end
        
        data.sleepingLocation = sleepingLocation
    else
        data.sleepingLocation = nil -- Dormir sur le sol
    end
    
    -- Obtenir le personnage
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        -- Assis = état de sommeil basique
        character.Humanoid.Sit = true
        
        -- Positionner le joueur en position couchée
        -- Ceci est mieux réalisé côté client avec une animation
        self:PlayClientAnimation(player, "sleep")
    end
    
    -- Envoyer une notification
    self:SendNotification(player, "Vous vous êtes endormi", "info")
    
    -- Faire en sorte que le joueur ne puisse pas se déplacer
    -- Ceci est également mieux géré côté client
    if self.remoteEvents.Sleep then
        self.remoteEvents.Sleep:FireClient(player, true)
    end
    
    -- Mettre à jour les données côté client
    self:UpdateClientSurvivalData(player)
    
    return true
end

-- Arrêter de dormir
function SurvivalService:StopSleeping(player)
    if not player or not player:IsA("Player") then 
        return false 
    end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then 
        return false 
    end
    
    -- Vérifier si le joueur est en train de dormir
    if not data.isSleeping then 
        return true 
    end
    
    -- Marquer comme ne dormant plus
    data.isSleeping = false
    data.sleepingLocation = nil
    
    -- Obtenir le personnage
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        -- Annuler l'état assis
        character.Humanoid.Sit = false
        
        -- Arrêter l'animation de sommeil
        self:PlayClientAnimation(player, "wake_up")
    end
    
    -- Envoyer une notification
    self:SendNotification(player, "Vous vous êtes réveillé", "info")
    
    -- Permettre au joueur de se déplacer à nouveau
    if self.remoteEvents.Sleep then
        self.remoteEvents.Sleep:FireClient(player, false)
    end
    
    -- Mettre à jour les données côté client
    self:UpdateClientSurvivalData(player)
    
    return true
end

-- Mettre à jour les données de survie pour le client
function SurvivalService:UpdateClientSurvivalData(player)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    local userId = player.UserId
    local data = self.playerSurvivalData[userId]
    
    if not data then 
        return 
    end
    
    -- Préparer les données à envoyer
    local statsData = {
        hunger = data.hunger,
        thirst = data.thirst,
        energy = data.energy,
        temperature = data.temperature,
        isSleeping = data.isSleeping,
        sleepingLocation = data.sleepingLocation
    }
    
    -- Envoyer les données au client
    if self.remoteEvents.UpdateStats then
        self.remoteEvents.UpdateStats:FireClient(player, statsData)
    end
end

-- Gérer la déconnexion d'un joueur
function SurvivalService:HandlePlayerRemoving(player)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    local userId = player.UserId
    
    -- Sauvegarder l'état et libérer les ressources
    if self.playerSurvivalData[userId] then
        -- Ici, on pourrait implémenter une sauvegarde dans DataStore
        -- pour le moment, on se contente de nettoyer la mémoire
        self.playerSurvivalData[userId] = nil
        self.lastNotificationTimes[userId] = nil
    end
    
    print("SurvivalService: Données de survie nettoyées pour " .. player.Name)
end

-- Gérer la mort d'un joueur
function SurvivalService:HandlePlayerDeath(player, cause)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    -- Cette fonction est un complément à PlayerService:HandlePlayerDeath
    -- Elle effectue les opérations spécifiques à la survie lors d'une mort
    
    local userId = player.UserId
    
    -- Réinitialiser certaines données de survie
    -- Lors de la réincarnation, le joueur aura des valeurs plus favorables
    if self.playerSurvivalData[userId] then
        -- Arrêter de dormir si le joueur était endormi
        if self.playerSurvivalData[userId].isSleeping then
            self.playerSurvivalData[userId].isSleeping = false
            self.playerSurvivalData[userId].sleepingLocation = nil
        end
    end
    
    -- Note: La réinitialisation complète des données se fait dans PlayerService
    -- après la réincarnation du joueur
end

-- Réinitialiser les données de survie (après réincarnation)
function SurvivalService:ResetPlayerSurvival(player)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    local userId = player.UserId
    
    -- Créer des données fraîches avec des valeurs de départ favorables
    self.playerSurvivalData[userId] = {
        hunger = self.maxHunger * 0.7,      -- 70% de nourriture
        thirst = self.maxThirst * 0.8,      -- 80% d'eau
        temperature = 50,                   -- Température idéale
        energy = self.maxEnergy * 0.9,      -- 90% d'énergie
        isSleeping = false,                 -- Pas endormi au départ
        lastUpdateTime = os.time(),         -- Nouvelle référence temporelle
        effects = {},                       -- Aucun effet actif
        sleepingLocation = nil              -- Pas d'emplacement de sommeil
    }
    
    -- Réinitialiser les timers de notification
    self.lastNotificationTimes[userId] = {
        hunger = 0,
        thirst = 0,
        energy = 0,
        temperature = 0
    }
    
    -- Mettre à jour le client
    self:UpdateClientSurvivalData(player)
    
    print("SurvivalService: Données de survie réinitialisées pour " .. player.Name)
end

-- Envoyer une notification au joueur
function SurvivalService:SendNotification(player, message, messageType)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    if self.remoteEvents.Notification then
        self.remoteEvents.Notification:FireClient(player, message, messageType or "info")
    else
        -- Fallback si l'événement n'est pas disponible
        print("Notification pour " .. player.Name .. ": " .. message)
    end
end

-- Jouer une animation côté client
function SurvivalService:PlayClientAnimation(player, animationType)
    if not player or not player:IsA("Player") then 
        return 
    end
    
    if self.remoteEvents.PlayAnimation then
        self.remoteEvents.PlayAnimation:FireClient(player, animationType)
    end
end

-- Démarrer le service
function SurvivalService:Start(services)
    print("SurvivalService: Démarrage...")
    
    -- Récupérer les références aux autres services
    self.playerService = services.PlayerService
    self.inventoryService = services.InventoryService
    
    -- Vérifier si les services requis sont disponibles
    if not self.playerService then
        warn("SurvivalService: PlayerService non disponible - certaines fonctionnalités seront limitées")
    end
    
    if not self.inventoryService then
        warn("SurvivalService: InventoryService non disponible - certaines fonctionnalités seront limitées")
    end
    
    -- Obtenir les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            UpdateStats = Events:FindFirstChild("UpdateStats"),
            Notification = Events:FindFirstChild("Notification"),
            PlayAnimation = Events:FindFirstChild("PlayAnimation"),
            Sleep = Events:FindFirstChild("Sleep")
        }
        
        -- Vérifier si tous les RemoteEvents requis sont disponibles
        local missingEvents = {}
        if not self.remoteEvents.UpdateStats then table.insert(missingEvents, "UpdateStats") end
        if not self.remoteEvents.Notification then table.insert(missingEvents, "Notification") end
        if not self.remoteEvents.PlayAnimation then table.insert(missingEvents, "PlayAnimation") end
        if not self.remoteEvents.Sleep then table.insert(missingEvents, "Sleep") end
        
        if #missingEvents > 0 then
            warn("SurvivalService: RemoteEvents manquants - " .. table.concat(missingEvents, ", "))
        end
    else
        warn("SurvivalService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Initialiser les joueurs actuels
    for _, player in pairs(Players:GetPlayers()) do
        self:InitializePlayerSurvival(player)
    end
    
    -- Gérer les nouveaux joueurs
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerSurvival(player)
    end)
    
    -- Gérer les joueurs qui quittent
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    -- Démarrer la boucle de mise à jour
    spawn(function()
        while true do
            -- Utilisation de wait() avec actualisation du délai pour éviter les problèmes
            -- si le serveur est surchargé
            local startTime = tick()
            
            -- Mettre à jour les données de survie pour tous les joueurs
            for _, player in pairs(Players:GetPlayers()) do
                if self.playerSurvivalData[player.UserId] then
                    pcall(function()
                        self:UpdateSurvivalData(player)
                    end)
                end
            end
            
            -- Calculer le temps restant pour atteindre self.updateInterval
            local elapsed = tick() - startTime
            local waitTime = math.max(0.1, self.updateInterval - elapsed)
            wait(waitTime)
        end
    end)
    
    print("SurvivalService: Démarré avec succès")
    return self
end

return SurvivalService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="46">
          <Properties>
            <string name="Name">TimeService</string>
            <string name="Source"><![CDATA[-- src/server/services/TimeService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Shared = ReplicatedStorage:FindFirstChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)

local TimeService = {}
TimeService.__index = TimeService

-- Créer une instance du service
function TimeService.new()
    local self = setmetatable({}, TimeService)
    
    -- Constantes de temps
    self.dayLength = GameSettings.Time.dayLength             -- Durée du jour en secondes
    self.nightLength = GameSettings.Time.nightLength         -- Durée de la nuit en secondes
    self.dawnDuskLength = GameSettings.Time.dawnDuskLength   -- Durée de l'aube/crépuscule en secondes
    self.dayNightCycle = GameSettings.Time.dayNightCycle     -- Durée totale du cycle jour/nuit
    self.yearInSeconds = GameSettings.Time.yearInSeconds     -- Durée d'une année dans le jeu
    
    -- État du temps
    self.gameTime = 0           -- Temps total écoulé depuis le début (en secondes)
    self.currentDay = 1         -- Jour actuel
    self.currentYear = 1        -- Année actuelle
    self.isDaytime = true       -- Si c'est actuellement le jour
    self.isDawnOrDusk = false   -- Si c'est l'aube ou le crépuscule
    self.timeString = "06:00"   -- Heure actuelle (format HH:MM)
    self.clockTime = 6          -- Heure actuelle (format 0-24)
    
    -- Références aux RemoteEvents
    self.remoteEvents = {}
    
    -- Références aux services
    self.playerService = nil
    
    return self
end

-- Initialiser le service
function TimeService:Start(services)
    print("TimeService: Démarrage...")
    
    -- Récupérer les références aux autres services
    self.playerService = services.PlayerService
    
    -- Récupérer les références aux RemoteEvents
    local Events = ReplicatedStorage:FindFirstChild("Events")
    if Events then
        self.remoteEvents = {
            TimeUpdate = Events:FindFirstChild("TimeUpdate")
        }
    else
        warn("TimeService: Dossier Events non trouvé dans ReplicatedStorage")
    end
    
    -- Configurer l'éclairage initial
    self:SetInitialLighting()
    
    -- Démarrer la boucle de mise à jour du temps
    self:StartTimeLoop()
    
    -- Démarrer la boucle pour le vieillissement des joueurs
    self:StartAgingLoop()
    
    print("TimeService: Démarré avec succès")
    return self
end

-- Configurer l'éclairage initial
function TimeService:SetInitialLighting()
    -- Régler le temps initial à 6h du matin (aube)
    Lighting.ClockTime = 6
    Lighting.TimeOfDay = "06:00:00"
    
    -- Configurer les propriétés d'éclairage de base
    Lighting.Ambient = Color3.fromRGB(70, 70, 70)
    Lighting.OutdoorAmbient = Color3.fromRGB(70, 70, 70)
    Lighting.Brightness = 2
    Lighting.GlobalShadows = true
    Lighting.Technology = Enum.Technology.ShadowMap
    Lighting.ExposureCompensation = 0.2
    
    -- Créer un effet de brouillard pour l'aube/crépuscule
    local atmosphere = Instance.new("Atmosphere")
    atmosphere.Density = 0.3
    atmosphere.Offset = 0
    atmosphere.Color = Color3.fromRGB(200, 170, 150)
    atmosphere.Decay = Color3.fromRGB(100, 100, 100)
    atmosphere.Glare = 0
    atmosphere.Haze = 0
    atmosphere.Parent = Lighting
    
    -- Effets de ciel
    local sky = Instance.new("Sky")
    sky.SkyboxBk = "rbxassetid://1012890"
    sky.SkyboxDn = "rbxassetid://1012895"
    sky.SkyboxFt = "rbxassetid://1012887"
    sky.SkyboxLf = "rbxassetid://1012889"
    sky.SkyboxRt = "rbxassetid://1012888"
    sky.SkyboxUp = "rbxassetid://1014435"
    sky.CelestialBodiesShown = true
    sky.StarCount = 3000
    sky.SunTextureId = "rbxassetid://1084351190"
    sky.SunAngularSize = 21
    sky.MoonTextureId = "rbxassetid://1088195518"
    sky.MoonAngularSize = 11
    sky.Parent = Lighting
end

-- Démarrer la boucle de mise à jour du temps
function TimeService:StartTimeLoop()
    -- Utiliser RunService.Heartbeat pour une mise à jour fluide
    local lastUpdateTime = os.clock()
    
    RunService.Heartbeat:Connect(function()
        local currentTime = os.clock()
        local deltaTime = currentTime - lastUpdateTime
        lastUpdateTime = currentTime
        
        -- Mettre à jour le temps du jeu
        self:UpdateGameTime(deltaTime)
        
        -- Mettre à jour l'éclairage du jeu
        self:UpdateLighting()
        
        -- Notifier les clients du changement d'heure toutes les 5 secondes
        if math.floor(self.gameTime) % 5 == 0 then
            self:NotifyClientsOfTimeChange()
        end
    end)
    
    print("TimeService: Boucle de temps démarrée")
end

-- Mettre à jour le temps du jeu
function TimeService:UpdateGameTime(deltaTime)
    -- Incrémenter le temps total
    self.gameTime = self.gameTime + deltaTime
    
    -- Calculer la position dans le cycle jour/nuit (0 à 1)
    local cycleProgress = (self.gameTime % self.dayNightCycle) / self.dayNightCycle
    
    -- Convertir en heures (0 à 24)
    self.clockTime = cycleProgress * 24
    
    -- Déterminer si c'est le jour ou la nuit
    local dayStart = self.dawnDuskLength / self.dayNightCycle
    local dayEnd = (self.dawnDuskLength + self.dayLength) / self.dayNightCycle
    local nightStart = (2 * self.dawnDuskLength + self.dayLength) / self.dayNightCycle
    
    -- Vérifier si c'est l'aube ou le crépuscule
    self.isDawnOrDusk = (cycleProgress < dayStart) or 
                        (cycleProgress > dayEnd and cycleProgress < nightStart)
    
    -- Vérifier si c'est le jour
    self.isDaytime = cycleProgress >= dayStart and cycleProgress <= nightStart
    
    -- Mettre à jour l'heure au format HH:MM
    local hours = math.floor(self.clockTime)
    local minutes = math.floor((self.clockTime - hours) * 60)
    self.timeString = string.format("%02d:%02d", hours, minutes)
    
    -- Mettre à jour le jour et l'année
    local totalDays = math.floor(self.gameTime / self.dayNightCycle)
    if totalDays + 1 ~= self.currentDay then
        self.currentDay = totalDays + 1
        print("TimeService: Nouveau jour - " .. self.currentDay)
    end
    
    local totalYears = math.floor(self.gameTime / self.yearInSeconds)
    if totalYears + 1 ~= self.currentYear then
        self.currentYear = totalYears + 1
        print("TimeService: Nouvelle année - " .. self.currentYear)
    end
end

-- Mettre à jour l'éclairage du monde
function TimeService:UpdateLighting()
    -- Mettre à jour l'heure dans Lighting
    Lighting.ClockTime = self.clockTime
    
    -- Heures formatées pour TimeOfDay (HH:MM:SS)
    local hours = math.floor(self.clockTime)
    local minutes = math.floor((self.clockTime - hours) * 60)
    local seconds = math.floor(((self.clockTime - hours) * 60 - minutes) * 60)
    Lighting.TimeOfDay = string.format("%02d:%02d:%02d", hours, minutes, seconds)
    
    -- Ajuster l'atmosphère en fonction du moment de la journée
    local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
    if atmosphere then
        if self.isDawnOrDusk then
            -- Aube/crépuscule: brouillard orangé
            atmosphere.Density = 0.35
            atmosphere.Color = Color3.fromRGB(255, 180, 150)
        elseif self.isDaytime then
            -- Jour: atmosphère claire
            atmosphere.Density = 0.2
            atmosphere.Color = Color3.fromRGB(200, 200, 220)
        else
            -- Nuit: brouillard bleuté
            atmosphere.Density = 0.4
            atmosphere.Color = Color3.fromRGB(150, 170, 255)
        end
    end
    
    -- Ajuster la luminosité globale
    if self.isDaytime and not self.isDawnOrDusk then
        Lighting.Brightness = 2.0
        Lighting.ExposureCompensation = 0.2
        Lighting.Ambient = Color3.fromRGB(70, 70, 70)
        Lighting.OutdoorAmbient = Color3.fromRGB(110, 110, 110)
    elseif self.isDawnOrDusk then
        Lighting.Brightness = 1.5
        Lighting.ExposureCompensation = 0.1
        Lighting.Ambient = Color3.fromRGB(90, 70, 60)
        Lighting.OutdoorAmbient = Color3.fromRGB(120, 90, 80)
    else
        Lighting.Brightness = 0.8
        Lighting.ExposureCompensation = 0.05
        Lighting.Ambient = Color3.fromRGB(40, 40, 60)
        Lighting.OutdoorAmbient = Color3.fromRGB(50, 50, 80)
    end
end

-- Notifier les clients du changement d'heure
function TimeService:NotifyClientsOfTimeChange()
    if not self.remoteEvents.TimeUpdate then return end
    
    -- Préparer les informations de temps à envoyer
    local timeInfo = {
        gameTime = self.gameTime,
        clockTime = self.clockTime,
        timeString = self.timeString,
        isDaytime = self.isDaytime,
        isDawnOrDusk = self.isDawnOrDusk,
        gameDay = self.currentDay,
        gameYear = self.currentYear
    }
    
    -- Envoyer à tous les joueurs
    for _, player in ipairs(Players:GetPlayers()) do
        self.remoteEvents.TimeUpdate:FireClient(player, timeInfo)
    end
end

-- Démarrer la boucle pour le vieillissement des joueurs
function TimeService:StartAgingLoop()
    -- Cette boucle s'exécute toutes les minutes pour mettre à jour l'âge des joueurs
    local agingInterval = 60 -- Vérifier toutes les minutes
    
    spawn(function()
        while true do
            wait(agingInterval)
            self:UpdatePlayerAges()
        end
    end)
    
    print("TimeService: Boucle de vieillissement démarrée")
end

-- Mettre à jour l'âge des joueurs
function TimeService:UpdatePlayerAges()
    -- Si le service de joueur n'est pas disponible, ne rien faire
    if not self.playerService then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        -- Calculer l'âge du joueur basé sur le temps dans le jeu
        if self.playerService.playerData and self.playerService.playerData[player.UserId] then
            local playerData = self.playerService.playerData[player.UserId]
            
            -- Si le joueur est vivant, mettre à jour son âge
            if not playerData.isDead then
                -- Calculer l'âge basé sur le temps écoulé depuis le début de l'âge
                local timeElapsed = self.gameTime - playerData.ageStartTime
                local ageInYears = playerData.age + (timeElapsed / self.yearInSeconds)
                
                -- Mettre à jour l'âge si une année entière est passée
                local newAge = math.floor(ageInYears)
                if newAge > playerData.age then
                    playerData.age = newAge
                    self.playerService:UpdateClientPlayerData(player)
                    print("TimeService: Joueur " .. player.Name .. " atteint l'âge de " .. newAge .. " ans")
                    
                    -- Vérifier si le joueur peut mourir de vieillesse
                    self.playerService:CheckNaturalDeath(player)
                end
            end
        end
    end
end

-- Obtenir l'heure actuelle du jeu
function TimeService:GetCurrentTime()
    return {
        gameTime = self.gameTime,
        clockTime = self.clockTime,
        timeString = self.timeString,
        isDaytime = self.isDaytime,
        isDawnOrDusk = self.isDawnOrDusk,
        gameDay = self.currentDay,
        gameYear = self.currentYear
    }
end

-- Forcer une mise à jour du temps pour un joueur spécifique
function TimeService:ForceTimeUpdateForPlayer(player)
    if not player or not self.remoteEvents.TimeUpdate then return end
    
    local timeInfo = self:GetCurrentTime()
    self.remoteEvents.TimeUpdate:FireClient(player, timeInfo)
end

-- Gérer un nouveau joueur qui se connecte
function TimeService:HandlePlayerAdded(player)
    -- Forcer une mise à jour du temps pour le nouveau joueur
    self:ForceTimeUpdateForPlayer(player)
end

return TimeService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="47">
          <Properties>
            <string name="Name">TribeService</string>
            <string name="Source"><![CDATA[-- src/server/services/TribeService.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)

-- Services
local Server = ServerScriptService:WaitForChild("Server")
local Services = Server:WaitForChild("services")
local PlayerService -- Sera initialisé dans Start()
local InventoryService -- Sera initialisé dans Start()

-- DataStore pour sauvegarder les données des tribus
local TribesDataStore = DataStoreService:GetDataStore("Tribes_v1")

local TribeService = {}
TribeService.__index = TribeService

-- Définir les rôles dans une tribu
local TRIBE_ROLES = {
    LEADER = "leader",      -- Fondateur, peut tout faire
    ELDER = "elder",        -- Peut ajouter/retirer des membres, construire
    MEMBER = "member",      -- Peut construire dans le territoire
    NOVICE = "novice"       -- Nouveau membre, accès limité
}

function TribeService.new()
    local self = setmetatable({}, TribeService)
    
    -- Liste des tribus
    self.tribes = {}
    
    -- Associations joueur-tribu
    self.playerTribes = {}  -- [userId] = tribeId
    
    -- Constantes
    self.maxTribesPerPlayer = 1  -- Un joueur ne peut créer/diriger qu'une tribu
    self.maxMembersPerTribe = GameSettings.Tribe.maxMembers or 20
    self.minTribeName = 3
    self.maxTribeName = 20
    self.territoryRadius = 100  -- Rayon du territoire d'une tribu en unités
    
    return self
end

-- Rétrograder un membre de la tribu
function TribeService:DemoteMember(player, targetUserId)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "demote_member", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        self:SendTribeActionResponse(player, "demote_member", false, "Votre tribu est introuvable")
        return
    end
    
    -- Vérifier si le joueur est le chef de la tribu
    local isLeader = false
    for _, member in ipairs(tribe.members) do
        if member.userId == userId and member.role == TRIBE_ROLES.LEADER then
            isLeader = true
            break
        end
    end
    
    if not isLeader then
        self:SendTribeActionResponse(player, "demote_member", false, "Seul le chef de la tribu peut rétrograder des membres")
        return
    end
    
    -- Vérifier si la cible est membre de la tribu
    local targetMemberIndex = nil
    local targetMemberRole = nil
    local targetMemberName = nil
    for i, member in ipairs(tribe.members) do
        if member.userId == targetUserId then
            targetMemberIndex = i
            targetMemberRole = member.role
            targetMemberName = member.name
            break
        end
    end
    
    if not targetMemberIndex then
        self:SendTribeActionResponse(player, "demote_member", false, "Ce joueur n'est pas membre de votre tribu")
        return
    end
    
    -- Ne pas pouvoir rétrograder le chef (soi-même)
    if targetMemberRole == TRIBE_ROLES.LEADER then
        self:SendTribeActionResponse(player, "demote_member", false, "Vous ne pouvez pas rétrograder le chef de la tribu")
        return
    end
    
    -- Gérer la rétrogradation selon le rôle actuel
    if targetMemberRole == TRIBE_ROLES.ELDER then
        -- Rétrograder d'ancien à membre
        tribe.members[targetMemberIndex].role = TRIBE_ROLES.MEMBER
        
        -- Ajouter un événement au journal
        table.insert(tribe.log, {
            type = "member_demoted",
            time = os.time(),
            demoter = userId,
            target = targetUserId,
            fromRole = TRIBE_ROLES.ELDER,
            toRole = TRIBE_ROLES.MEMBER,
            description = player.Name .. " a rétrogradé " .. targetMemberName .. " au rang de Membre"
        })
        
    elseif targetMemberRole == TRIBE_ROLES.MEMBER then
        -- Rétrograder de membre à novice
        tribe.members[targetMemberIndex].role = TRIBE_ROLES.NOVICE
        
        -- Ajouter un événement au journal
        table.insert(tribe.log, {
            type = "member_demoted",
            time = os.time(),
            demoter = userId,
            target = targetUserId,
            fromRole = TRIBE_ROLES.MEMBER,
            toRole = TRIBE_ROLES.NOVICE,
            description = player.Name .. " a rétrogradé " .. targetMemberName .. " au rang de Novice"
        })
        
    elseif targetMemberRole == TRIBE_ROLES.NOVICE then
        -- Ne peut pas rétrograder davantage un novice
        self:SendTribeActionResponse(player, "demote_member", false, "Ce membre est déjà un Novice et ne peut pas être rétrogradé davantage")
        return
    end
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "demote_member", true, "Vous avez rétrogradé " .. targetMemberName)
    
    -- Notifier le joueur cible s'il est en ligne
    local targetPlayer = Players:GetPlayerByUserId(targetUserId)
    if targetPlayer then
        self:SendTribeActionResponse(targetPlayer, "demoted", true, "Vous avez été rétrogradé dans votre tribu")
    end
    
    -- Notifier tous les membres de la tribu
    self:NotifyTribeUpdate(tribeId)
    
    print("TribeService: " .. player.Name .. " a rétrogradé " .. targetMemberName)
end

-- Modifier la description de la tribu
function TribeService:SetTribeDescription(player, newDescription)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "set_tribe_description", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        self:SendTribeActionResponse(player, "set_tribe_description", false, "Votre tribu est introuvable")
        return
    end
    
    -- Vérifier si le joueur a les permissions (chef ou ancien)
    local hasPermission = false
    for _, member in ipairs(tribe.members) do
        if member.userId == userId and (member.role == TRIBE_ROLES.LEADER or member.role == TRIBE_ROLES.ELDER) then
            hasPermission = true
            break
        end
    end
    
    if not hasPermission then
        self:SendTribeActionResponse(player, "set_tribe_description", false, "Vous n'avez pas la permission de modifier la description de la tribu")
        return
    end
    
    -- Nettoyer et valider la description
    newDescription = newDescription or ""
    if type(newDescription) ~= "string" then
        newDescription = ""
    end
    
    -- Limiter la taille de la description
    if #newDescription > 500 then
        newDescription = string.sub(newDescription, 1, 500)
    end
    
    -- Sauvegarder l'ancienne description pour le journal
    local oldDescription = tribe.description
    
    -- Mettre à jour la description
    tribe.description = newDescription
    
    -- Ajouter un événement au journal
    table.insert(tribe.log, {
        type = "description_changed",
        time = os.time(),
        userId = userId,
        description = player.Name .. " a modifié la description de la tribu"
    })
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "set_tribe_description", true, "Description de la tribu mise à jour")
    
    -- Notifier tous les membres de la tribu
    self:NotifyTribeUpdate(tribeId)
    
    print("TribeService: " .. player.Name .. " a modifié la description de la tribu " .. tribe.name)
end

-- Définir le territoire de la tribu
function TribeService:SetTribeTerritory(player, centerPosition)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "set_tribe_territory", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        self:SendTribeActionResponse(player, "set_tribe_territory", false, "Votre tribu est introuvable")
        return
    end
    
    -- Vérifier si le joueur est le chef de la tribu
    local isLeader = false
    for _, member in ipairs(tribe.members) do
        if member.userId == userId and member.role == TRIBE_ROLES.LEADER then
            isLeader = true
            break
        end
    end
    
    if not isLeader then
        self:SendTribeActionResponse(player, "set_tribe_territory", false, "Seul le chef de la tribu peut définir le territoire")
        return
    end
    
    -- Vérifier si la position est valide
    if typeof(centerPosition) ~= "Vector3" then
        self:SendTribeActionResponse(player, "set_tribe_territory", false, "Position invalide")
        return
    end
    
    -- Vérifier si le joueur est proche de la position
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        self:SendTribeActionResponse(player, "set_tribe_territory", false, "Impossible de déterminer votre position")
        return
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local distance = (rootPart.Position - centerPosition).Magnitude
    
    if distance > 10 then  -- Le joueur doit être à moins de 10 unités de la position
        self:SendTribeActionResponse(player, "set_tribe_territory", false, "Vous devez être proche de l'emplacement choisi")
        return
    end
    
    -- Vérifier si le territoire n'est pas trop proche d'un autre territoire de tribu
    local minDistanceBetweenTerritories = 200  -- 200 unités de distance minimale
    
    for otherTribeId, otherTribe in pairs(self.tribes) do
        if otherTribeId ~= tribeId and otherTribe.territory and otherTribe.territory.center then
            local otherCenter = otherTribe.territory.center
            local distanceBetweenTerritories = (Vector3.new(otherCenter.x, otherCenter.y, otherCenter.z) - centerPosition).Magnitude
            
            if distanceBetweenTerritories < minDistanceBetweenTerritories then
                self:SendTribeActionResponse(player, "set_tribe_territory", false, "Cet emplacement est trop proche du territoire d'une autre tribu")
                return
            end
        end
    end
    
    -- Mettre à jour le territoire de la tribu
    tribe.territory.center = {
        x = centerPosition.X,
        y = centerPosition.Y,
        z = centerPosition.Z
    }
    
    -- Ajouter un événement au journal
    table.insert(tribe.log, {
        type = "territory_set",
        time = os.time(),
        userId = userId,
        description = player.Name .. " a défini le territoire de la tribu"
    })
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "set_tribe_territory", true, "Territoire de la tribu défini")
    
    -- Notifier tous les membres de la tribu
    self:NotifyTribeUpdate(tribeId)
    
    print("TribeService: " .. player.Name .. " a défini le territoire de la tribu " .. tribe.name)
end

-- Obtenir les données d'une tribu
function TribeService:GetTribeData(tribeId)
    return self.tribes[tribeId]
end

-- Obtenir l'ID de la tribu d'un joueur
function TribeService:GetPlayerTribeId(player)
    local userId = typeof(player) == "number" and player or player.UserId
    return self.playerTribes[userId]
end

-- Obtenir le rôle d'un joueur dans sa tribu
function TribeService:GetPlayerRole(player)
    local userId = typeof(player) == "number" and player or player.UserId
    local tribeId = self.playerTribes[userId]
    
    if not tribeId or not self.tribes[tribeId] then
        return nil
    end
    
    for _, member in ipairs(self.tribes[tribeId].members) do
        if member.userId == userId then
            return member.role
        end
    end
    
    return nil
end

-- Vérifier si un joueur est dans la même tribu qu'un autre
function TribeService:ArePlayersInSameTribe(player1, player2)
    local userId1 = typeof(player1) == "number" and player1 or player1.UserId
    local userId2 = typeof(player2) == "number" and player2 or player2.UserId
    
    local tribeId1 = self.playerTribes[userId1]
    local tribeId2 = self.playerTribes[userId2]
    
    return tribeId1 and tribeId2 and tribeId1 == tribeId2
end

-- Notifier un joueur des informations de sa tribu
function TribeService:NotifyPlayerTribeUpdate(player)
    local userId = player.UserId
    local tribeId = self.playerTribes[userId]
    
    local events = ReplicatedStorage:FindFirstChild("Events")
    if not events then return end
    
    local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
    if not tribeUpdateEvent then return end
    
    -- Préparer les données à envoyer
    local updateData = nil
    
    if tribeId and self.tribes[tribeId] then
        -- Le joueur est dans une tribu, envoyer les infos basiques
        updateData = {
            inTribe = true,
            tribeId = tribeId,
            tribeName = self.tribes[tribeId].name,
            tribeDescription = self.tribes[tribeId].description,
            memberCount = #self.tribes[tribeId].members,
            role = self:GetPlayerRole(player)
        }
    else
        -- Le joueur n'est pas dans une tribu
        updateData = {
            inTribe = false
        }
    end
    
    -- Envoyer les données au client
    tribeUpdateEvent:FireClient(player, "player_tribe_update", updateData)
end

-- Notifier tous les membres d'une tribu
function TribeService:NotifyTribeUpdate(tribeId)
    local tribe = self.tribes[tribeId]
    if not tribe then return end
    
    local events = ReplicatedStorage:FindFirstChild("Events")
    if not events then return end
    
    local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
    if not tribeUpdateEvent then return end
    
    -- Préparer les données détaillées
    local detailedData = {
        id = tribeId,
        name = tribe.name,
        description = tribe.description,
        founder = tribe.founder,
        creationTime = tribe.creationTime,
        territory = tribe.territory,
        members = {},
        log = tribe.log
    }
    
    -- N'inclure que les informations pertinentes sur les membres
    for _, member in ipairs(tribe.members) do
        table.insert(detailedData.members, {
            userId = member.userId,
            name = member.name,
            role = member.role,
            joinTime = member.joinTime,
            online = member.online
        })
    end
    
    -- Envoyer les données à tous les membres
    for _, member in ipairs(tribe.members) do
        local memberPlayer = Players:GetPlayerByUserId(member.userId)
        if memberPlayer then
            -- Informations basiques pour tous les membres
            self:NotifyPlayerTribeUpdate(memberPlayer)
            
            -- Informations détaillées
            tribeUpdateEvent:FireClient(memberPlayer, "tribe_details_update", detailedData)
        end
    end
end

-- Envoyer une invitation de tribu à un joueur
function TribeService:SendTribeInvitation(player, tribe, inviterName)
    local events = ReplicatedStorage:FindFirstChild("Events")
    if not events then return end
    
    local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
    if not tribeUpdateEvent then return end
    
    -- Préparer les données d'invitation
    local invitationData = {
        tribeId = tribe.id,
        tribeName = tribe.name,
        inviter = inviterName,
        expires = os.time() + 300  -- 5 minutes
    }
    
    -- Envoyer l'invitation
    tribeUpdateEvent:FireClient(player, "invitation", invitationData)
    
    -- Envoyer également une notification
    local notificationEvent = events:FindFirstChild("Notification")
    if notificationEvent then
        notificationEvent:FireClient(player, inviterName .. " vous a invité à rejoindre la tribu " .. tribe.name, "info")
    end
end

-- Envoyer une réponse d'action de tribu à un joueur
function TribeService:SendTribeActionResponse(player, action, success, message, data)
    local events = ReplicatedStorage:FindFirstChild("Events")
    if not events then return end
    
    local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
    if not tribeUpdateEvent then return end
    
    -- Préparer la réponse
    local response = {
        action = action,
        success = success,
        message = message,
        data = data
    }
    
    -- Envoyer la réponse
    tribeUpdateEvent:FireClient(player, "action_response", response)
    
    -- Envoyer également une notification
    local notificationEvent = events:FindFirstChild("Notification")
    if notificationEvent then
        notificationEvent:FireClient(player, message, success and "success" or "error")
    end
end

-- Gérer un joueur qui se déconnecte
function TribeService:HandlePlayerRemoving(player)
    local userId = player.UserId
    local tribeId = self.playerTribes[userId]
    
    if not tribeId or not self.tribes[tribeId] then return end
    
    -- Mettre à jour le statut en ligne du membre
    for i, member in ipairs(self.tribes[tribeId].members) do
        if member.userId == userId then
            member.online = false
            break
        end
    end
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    
    -- Notifier les autres membres de la tribu
    self:NotifyTribeUpdate(tribeId)
end

return TribeService

-- Initialiser le service
function TribeService:Start(services)
    print("TribeService: Démarrage...")
    
    -- Récupérer les références aux autres services
    PlayerService = services.PlayerService
    InventoryService = services.InventoryService
    
    -- Configurer les événements RemoteEvent pour les tribus
    self:SetupRemoteEvents()
    
    -- Écouter les événements de joueur
    Players.PlayerAdded:Connect(function(player)
        self:LoadPlayerTribeData(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    print("TribeService: Démarré avec succès")
    return self
end

-- Configurer les événements RemoteEvent pour les tribus
function TribeService:SetupRemoteEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if not events then
        events = Instance.new("Folder")
        events.Name = "Events"
        events.Parent = ReplicatedStorage
    end
    
    -- Créer l'événement pour les actions de tribu
    local tribeActionEvent = events:FindFirstChild("TribeAction")
    if not tribeActionEvent then
        tribeActionEvent = Instance.new("RemoteEvent")
        tribeActionEvent.Name = "TribeAction"
        tribeActionEvent.Parent = events
    end
    
    -- Connecter l'événement aux fonctions de traitement
    tribeActionEvent.OnServerEvent:Connect(function(player, action, ...)
        self:HandleTribeAction(player, action, ...)
    end)
    
    -- Créer l'événement pour notifier les clients des changements de tribu
    local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
    if not tribeUpdateEvent then
        tribeUpdateEvent = Instance.new("RemoteEvent")
        tribeUpdateEvent.Name = "TribeUpdate"
        tribeUpdateEvent.Parent = events
    end
end

-- Charger les données de tribu pour un joueur
function TribeService:LoadPlayerTribeData(player)
    local userId = player.UserId
    
    -- Vérifier si le joueur est déjà dans une tribu
    spawn(function()
        local success, tribeId = pcall(function()
            return TribesDataStore:GetAsync("Player_" .. userId)
        end)
        
        if success and tribeId then
            -- Vérifier si la tribu existe dans la mémoire
            if not self.tribes[tribeId] then
                -- Charger les données de la tribu
                self:LoadTribeData(tribeId)
            end
            
            -- Associer le joueur à sa tribu
            self.playerTribes[userId] = tribeId
            
            -- Mettre à jour le statut "en ligne" du membre
            if self.tribes[tribeId] then
                for i, member in ipairs(self.tribes[tribeId].members) do
                    if member.userId == userId then
                        member.online = true
                        break
                    end
                end
                
                -- Notifier tous les membres de la tribu
                self:NotifyTribeUpdate(tribeId)
            end
        end
    end)
end

-- Charger les données d'une tribu
function TribeService:LoadTribeData(tribeId)
    spawn(function()
        local success, tribeData = pcall(function()
            return TribesDataStore:GetAsync("Tribe_" .. tribeId)
        end)
        
        if success and tribeData then
            -- Créer la structure de données de la tribu en mémoire
            self.tribes[tribeId] = tribeData
            
            -- Mettre à jour le statut en ligne des membres
            for i, member in ipairs(tribeData.members) do
                local memberPlayer = Players:GetPlayerByUserId(member.userId)
                member.online = memberPlayer ~= nil
            end
            
            print("TribeService: Tribu chargée - " .. tribeData.name)
        else
            warn("TribeService: Échec du chargement de la tribu " .. tribeId)
        end
    end)
end

-- Sauvegarder les données d'une tribu
function TribeService:SaveTribeData(tribeId)
    local tribeData = self.tribes[tribeId]
    if not tribeData then return end
    
    spawn(function()
        local success, err = pcall(function()
            TribesDataStore:SetAsync("Tribe_" .. tribeId, tribeData)
        end)
        
        if not success then
            warn("TribeService: Échec de la sauvegarde de la tribu " .. tribeId .. " - " .. tostring(err))
        end
    end)
end

-- Sauvegarder l'association joueur-tribu
function TribeService:SavePlayerTribeAssociation(userId, tribeId)
    spawn(function()
        local success, err = pcall(function()
            if tribeId then
                TribesDataStore:SetAsync("Player_" .. userId, tribeId)
            else
                TribesDataStore:RemoveAsync("Player_" .. userId)
            end
        end)
        
        if not success then
            warn("TribeService: Échec de la sauvegarde de l'association joueur-tribu pour " .. userId .. " - " .. tostring(err))
        end
    end)
end

-- Gérer les actions de tribu
function TribeService:HandleTribeAction(player, action, ...)
    local args = {...}
    
    if action == "create_tribe" then
        self:CreateTribe(player, args[1], args[2])  -- Nom, description
    elseif action == "join_tribe" then
        self:JoinTribe(player, args[1])  -- ID de la tribu
    elseif action == "leave_tribe" then
        self:LeaveTribe(player)
    elseif action == "invite_player" then
        self:InvitePlayerToTribe(player, args[1])  -- UserId du joueur à inviter
    elseif action == "kick_member" then
        self:KickMemberFromTribe(player, args[1])  -- UserId du membre à expulser
    elseif action == "promote_member" then
        self:PromoteMember(player, args[1])  -- UserId du membre à promouvoir
    elseif action == "demote_member" then
        self:DemoteMember(player, args[1])  -- UserId du membre à rétrograder
    elseif action == "set_tribe_description" then
        self:SetTribeDescription(player, args[1])  -- Nouvelle description
    elseif action == "set_tribe_territory" then
        self:SetTribeTerritory(player, args[1])  -- Position du centre du territoire
    end
end

-- Créer une nouvelle tribu
function TribeService:CreateTribe(player, tribeName, description)
    local userId = player.UserId
    
    -- Vérifier si le joueur est déjà dans une tribu
    if self.playerTribes[userId] then
        self:SendTribeActionResponse(player, "create_tribe", false, "Vous êtes déjà membre d'une tribu")
        return
    end
    
    -- Vérifier le nom de la tribu
    if not tribeName or type(tribeName) ~= "string" then
        self:SendTribeActionResponse(player, "create_tribe", false, "Nom de tribu invalide")
        return
    end
    
    tribeName = string.gsub(tribeName, "^%s*(.-)%s*$", "%1")  -- Trim
    
    if #tribeName < self.minTribeName or #tribeName > self.maxTribeName then
        self:SendTribeActionResponse(player, "create_tribe", false, "Le nom de la tribu doit contenir entre " .. self.minTribeName .. " et " .. self.maxTribeName .. " caractères")
        return
    end
    
    -- Vérifier la description
    description = description or ""
    if type(description) ~= "string" then
        description = ""
    end
    
    -- Vérifier si le joueur a les ressources nécessaires pour créer une tribu
    local creationCost = GameSettings.Tribe.creationCost
    if creationCost then
        for itemId, quantity in pairs(creationCost) do
            if not InventoryService:HasItemInInventory(player, itemId, quantity) then
                self:SendTribeActionResponse(player, "create_tribe", false, "Ressources insuffisantes pour créer une tribu")
                return
            end
        end
        
        -- Retirer les ressources
        for itemId, quantity in pairs(creationCost) do
            InventoryService:RemoveItemFromInventory(player, itemId, quantity)
        end
    end
    
    -- Créer un ID unique pour la tribu
    local tribeId = "tribe_" .. game:GetService("HttpService"):GenerateGUID(false)
    
    -- Créer la tribu
    local newTribe = {
        id = tribeId,
        name = tribeName,
        description = description,
        founder = userId,
        creationTime = os.time(),
        members = {
            {
                userId = userId,
                name = player.Name,
                role = TRIBE_ROLES.LEADER,
                joinTime = os.time(),
                online = true
            }
        },
        territory = {
            center = nil,  -- Sera défini plus tard
            radius = self.territoryRadius
        },
        buildings = {},  -- Liste des bâtiments de la tribu
        log = {  -- Journal des événements de la tribu
            {
                type = "creation",
                time = os.time(),
                description = "Tribu créée par " .. player.Name
            }
        },
        invites = {}  -- Liste des invitations envoyées
    }
    
    -- Ajouter la tribu à la liste
    self.tribes[tribeId] = newTribe
    
    -- Associer le joueur à la tribu
    self.playerTribes[userId] = tribeId
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    self:SavePlayerTribeAssociation(userId, tribeId)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "create_tribe", true, "Tribu créée avec succès", {
        tribeId = tribeId,
        tribeName = tribeName
    })
    
    print("TribeService: Nouvelle tribu créée - " .. tribeName .. " (" .. tribeId .. ")")
    
    -- Notifier le joueur du changement de tribu
    self:NotifyPlayerTribeUpdate(player)
    
    return tribeId
end

-- Rejoindre une tribu (sur invitation)
function TribeService:JoinTribe(player, tribeId)
    local userId = player.UserId
    
    -- Vérifier si le joueur est déjà dans une tribu
    if self.playerTribes[userId] then
        self:SendTribeActionResponse(player, "join_tribe", false, "Vous êtes déjà membre d'une tribu")
        return
    end
    
    -- Vérifier si la tribu existe
    if not self.tribes[tribeId] then
        self:SendTribeActionResponse(player, "join_tribe", false, "Tribu introuvable")
        return
    end
    
    local tribe = self.tribes[tribeId]
    
    -- Vérifier si le joueur est invité
    local isInvited = false
    for i, invite in ipairs(tribe.invites or {}) do
        if invite.userId == userId and invite.expires > os.time() then
            isInvited = true
            table.remove(tribe.invites, i)
            break
        end
    end
    
    if not isInvited then
        self:SendTribeActionResponse(player, "join_tribe", false, "Vous n'avez pas été invité à rejoindre cette tribu")
        return
    end
    
    -- Vérifier si la tribu n'est pas pleine
    if #tribe.members >= self.maxMembersPerTribe then
        self:SendTribeActionResponse(player, "join_tribe", false, "La tribu a atteint son nombre maximum de membres")
        return
    end
    
    -- Ajouter le joueur à la tribu
    table.insert(tribe.members, {
        userId = userId,
        name = player.Name,
        role = TRIBE_ROLES.NOVICE,
        joinTime = os.time(),
        online = true
    })
    
    -- Ajouter un événement au journal
    table.insert(tribe.log, {
        type = "member_join",
        time = os.time(),
        userId = userId,
        description = player.Name .. " a rejoint la tribu"
    })
    
    -- Associer le joueur à la tribu
    self.playerTribes[userId] = tribeId
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    self:SavePlayerTribeAssociation(userId, tribeId)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "join_tribe", true, "Vous avez rejoint la tribu " .. tribe.name)
    
    -- Notifier tous les membres de la tribu
    self:NotifyTribeUpdate(tribeId)
    
    print("TribeService: " .. player.Name .. " a rejoint la tribu " .. tribe.name)
end

-- Quitter une tribu
function TribeService:LeaveTribe(player)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "leave_tribe", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        -- Tribu introuvable, nettoyer l'association
        self.playerTribes[userId] = nil
        self:SavePlayerTribeAssociation(userId, nil)
        self:SendTribeActionResponse(player, "leave_tribe", true, "Vous avez quitté la tribu")
        return
    end
    
    -- Vérifier si le joueur est le fondateur
    local isFounder = (tribe.founder == userId)
    
    -- Trouver l'index du membre
    local memberIndex = nil
    for i, member in ipairs(tribe.members) do
        if member.userId == userId then
            memberIndex = i
            break
        end
    end
    
    if not memberIndex then
        -- Le joueur n'est pas membre, nettoyer l'association
        self.playerTribes[userId] = nil
        self:SavePlayerTribeAssociation(userId, nil)
        self:SendTribeActionResponse(player, "leave_tribe", true, "Vous avez quitté la tribu")
        return
    end
    
    -- Si le joueur est le fondateur et qu'il est le seul membre, dissoudre la tribu
    if isFounder and #tribe.members == 1 then
        -- Dissoudre la tribu
        self:DissolveTribe(tribeId)
        self:SendTribeActionResponse(player, "leave_tribe", true, "Vous avez dissout la tribu " .. tribe.name)
        return
    end
    
    -- Si le joueur est le fondateur, transférer le leadership
    if isFounder then
        -- Trouver le membre ayant le rôle le plus élevé et l'ancienneté la plus grande
        local nextLeaderIndex = nil
        local highestRoleValue = 0
        local longestTime = 0
        
        for i, member in ipairs(tribe.members) do
            if i ~= memberIndex then
                local roleValue = 0
                if member.role == TRIBE_ROLES.ELDER then
                    roleValue = 2
                elseif member.role == TRIBE_ROLES.MEMBER then
                    roleValue = 1
                end
                
                if roleValue > highestRoleValue or (roleValue == highestRoleValue and member.joinTime < longestTime) then
                    highestRoleValue = roleValue
                    longestTime = member.joinTime
                    nextLeaderIndex = i
                end
            end
        end
        
        if nextLeaderIndex then
            -- Transférer le leadership
            tribe.members[nextLeaderIndex].role = TRIBE_ROLES.LEADER
            tribe.founder = tribe.members[nextLeaderIndex].userId
            
            -- Ajouter un événement au journal
            table.insert(tribe.log, {
                type = "leadership_transfer",
                time = os.time(),
                from = userId,
                to = tribe.members[nextLeaderIndex].userId,
                description = player.Name .. " a transféré le leadership à " .. tribe.members[nextLeaderIndex].name
            })
        end
    end
    
    -- Retirer le membre de la tribu
    table.remove(tribe.members, memberIndex)
    
    -- Ajouter un événement au journal
    table.insert(tribe.log, {
        type = "member_leave",
        time = os.time(),
        userId = userId,
        description = player.Name .. " a quitté la tribu"
    })
    
    -- Supprimer l'association du joueur
    self.playerTribes[userId] = nil
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    self:SavePlayerTribeAssociation(userId, nil)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "leave_tribe", true, "Vous avez quitté la tribu " .. tribe.name)
    
    -- Notifier tous les membres de la tribu
    self:NotifyTribeUpdate(tribeId)
    
    -- Notifier le joueur qu'il n'a plus de tribu
    self:NotifyPlayerTribeUpdate(player)
    
    print("TribeService: " .. player.Name .. " a quitté la tribu " .. tribe.name)
end

-- Dissoudre une tribu complètement
function TribeService:DissolveTribe(tribeId)
    local tribe = self.tribes[tribeId]
    if not tribe then return end
    
    -- Retirer tous les membres
    for _, member in ipairs(tribe.members) do
        -- Supprimer l'association du joueur
        self.playerTribes[member.userId] = nil
        
        -- Sauvegarder l'association (ou plutôt la supprimer)
        self:SavePlayerTribeAssociation(member.userId, nil)
        
        -- Notifier le joueur s'il est en ligne
        local memberPlayer = Players:GetPlayerByUserId(member.userId)
        if memberPlayer then
            self:NotifyPlayerTribeUpdate(memberPlayer)
            self:SendTribeActionResponse(memberPlayer, "tribe_dissolved", true, "La tribu " .. tribe.name .. " a été dissoute")
        end
    end
    
    -- Supprimer les données de la tribu
    self.tribes[tribeId] = nil
    
    -- Supprimer du DataStore
    spawn(function()
        pcall(function()
            TribesDataStore:RemoveAsync("Tribe_" .. tribeId)
        end)
    end)
    
    print("TribeService: La tribu " .. tribe.name .. " a été dissoute")
end

-- Inviter un joueur à rejoindre la tribu
function TribeService:InvitePlayerToTribe(player, targetUserId)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "invite_player", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        self:SendTribeActionResponse(player, "invite_player", false, "Votre tribu est introuvable")
        return
    end
    
    -- Vérifier si le joueur a le droit d'inviter
    local hasPermission = false
    for _, member in ipairs(tribe.members) do
        if member.userId == userId and (member.role == TRIBE_ROLES.LEADER or member.role == TRIBE_ROLES.ELDER) then
            hasPermission = true
            break
        end
    end
    
    if not hasPermission then
        self:SendTribeActionResponse(player, "invite_player", false, "Vous n'avez pas la permission d'inviter des joueurs")
        return
    end
    
    -- Vérifier si la tribu n'est pas pleine
    if #tribe.members >= self.maxMembersPerTribe then
        self:SendTribeActionResponse(player, "invite_player", false, "La tribu a atteint son nombre maximum de membres")
        return
    end
    
    -- Vérifier si la cible est déjà dans une tribu
    if self.playerTribes[targetUserId] then
        self:SendTribeActionResponse(player, "invite_player", false, "Ce joueur est déjà membre d'une tribu")
        return
    end
    
    -- Vérifier si le joueur cible est en ligne
    local targetPlayer = Players:GetPlayerByUserId(targetUserId)
    if not targetPlayer then
        self:SendTribeActionResponse(player, "invite_player", false, "Le joueur cible n'est pas en ligne")
        return
    end
    
    -- Créer l'invitation
    if not tribe.invites then
        tribe.invites = {}
    end
    
    -- Vérifier si une invitation existe déjà
    for i, invite in ipairs(tribe.invites) do
        if invite.userId == targetUserId then
            -- Mettre à jour l'expiration
            invite.expires = os.time() + 300  -- 5 minutes
            invite.inviter = userId
            
            -- Sauvegarder les données
            self:SaveTribeData(tribeId)
            
            -- Envoyer une notification au joueur cible
            self:SendTribeInvitation(targetPlayer, tribe, player.Name)
            
            -- Envoyer une réponse au joueur
            self:SendTribeActionResponse(player, "invite_player", true, "Invitation envoyée à " .. targetPlayer.Name)
            return
        end
    end
    
    -- Ajouter une nouvelle invitation
    table.insert(tribe.invites, {
        userId = targetUserId,
        inviter = userId,
        time = os.time(),
        expires = os.time() + 300  -- 5 minutes
    })
    
    -- Ajouter un événement au journal
    table.insert(tribe.log, {
        type = "player_invited",
        time = os.time(),
        inviter = userId,
        target = targetUserId,
        description = player.Name .. " a invité " .. targetPlayer.Name .. " à rejoindre la tribu"
    })
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    
    -- Envoyer une notification au joueur cible
    self:SendTribeInvitation(targetPlayer, tribe, player.Name)
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "invite_player", true, "Invitation envoyée à " .. targetPlayer.Name)
    
    print("TribeService: " .. player.Name .. " a invité " .. targetPlayer.Name .. " à rejoindre la tribu " .. tribe.name)
end

-- Expulser un membre de la tribu
function TribeService:KickMemberFromTribe(player, targetUserId)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "kick_member", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        self:SendTribeActionResponse(player, "kick_member", false, "Votre tribu est introuvable")
        return
    end
    
    -- Vérifier si le joueur a le droit d'expulser
    local hasPermission = false
    local playerRole = nil
    for _, member in ipairs(tribe.members) do
        if member.userId == userId then
            playerRole = member.role
            if member.role == TRIBE_ROLES.LEADER or member.role == TRIBE_ROLES.ELDER then
                hasPermission = true
            end
            break
        end
    end
    
    if not hasPermission then
        self:SendTribeActionResponse(player, "kick_member", false, "Vous n'avez pas la permission d'expulser des membres")
        return
    end
    
    -- Vérifier si la cible est membre de la tribu
    local targetMemberIndex = nil
    local targetMemberRole = nil
    local targetMemberName = nil
    for i, member in ipairs(tribe.members) do
        if member.userId == targetUserId then
            targetMemberIndex = i
            targetMemberRole = member.role
            targetMemberName = member.name
            break
        end
    end
    
    if not targetMemberIndex then
        self:SendTribeActionResponse(player, "kick_member", false, "Ce joueur n'est pas membre de votre tribu")
        return
    end
    
    -- Vérifier la hiérarchie
    if playerRole == TRIBE_ROLES.ELDER and (targetMemberRole == TRIBE_ROLES.LEADER or targetMemberRole == TRIBE_ROLES.ELDER) then
        self:SendTribeActionResponse(player, "kick_member", false, "Vous ne pouvez pas expulser un membre de rang égal ou supérieur")
        return
    end
    
    -- Ne pas pouvoir s'expulser soi-même
    if targetUserId == userId then
        self:SendTribeActionResponse(player, "kick_member", false, "Vous ne pouvez pas vous expulser vous-même")
        return
    end
    
    -- Retirer le membre de la tribu
    table.remove(tribe.members, targetMemberIndex)
    
    -- Ajouter un événement au journal
    table.insert(tribe.log, {
        type = "member_kicked",
        time = os.time(),
        kicker = userId,
        target = targetUserId,
        description = player.Name .. " a expulsé " .. targetMemberName .. " de la tribu"
    })
    
    -- Supprimer l'association du joueur cible
    self.playerTribes[targetUserId] = nil
    
    -- Sauvegarder les données
    self:SaveTribeData(tribeId)
    self:SavePlayerTribeAssociation(targetUserId, nil)
    
    -- Notifier le joueur cible s'il est en ligne
    local targetPlayer = Players:GetPlayerByUserId(targetUserId)
    if targetPlayer then
        self:NotifyPlayerTribeUpdate(targetPlayer)
        self:SendTribeActionResponse(targetPlayer, "kicked_from_tribe", true, "Vous avez été expulsé de la tribu " .. tribe.name)
    end
    
    -- Envoyer une réponse au joueur
    self:SendTribeActionResponse(player, "kick_member", true, "Vous avez expulsé " .. targetMemberName .. " de la tribu")
    
    -- Notifier tous les membres de la tribu
    self:NotifyTribeUpdate(tribeId)
    
    print("TribeService: " .. player.Name .. " a expulsé " .. targetMemberName .. " de la tribu " .. tribe.name)
end

-- Promouvoir un membre de la tribu
function TribeService:PromoteMember(player, targetUserId)
    local userId = player.UserId
    
    -- Vérifier si le joueur est dans une tribu
    local tribeId = self.playerTribes[userId]
    if not tribeId then
        self:SendTribeActionResponse(player, "promote_member", false, "Vous n'êtes pas membre d'une tribu")
        return
    end
    
    local tribe = self.tribes[tribeId]
    if not tribe then
        self:SendTribeActionResponse(player, "promote_member", false, "Votre tribu est introuvable")
        return
    end
    
    -- Vérifier si le joueur est le chef de la tribu
    local isLeader = false
    for _, member in ipairs(tribe.members) do
        if member.userId == userId and member.role == TRIBE_ROLES.LEADER then
            isLeader = true
            break
        end
    end
    
    if not isLeader then
        self:SendTribeActionResponse(player, "promote_member", false, "Seul le chef de la tribu peut promouvoir des membres")
        return
    end
    
    -- Vérifier si la cible est membre de la tribu
    local targetMemberIndex = nil
    local targetMemberRole = nil
    local targetMemberName = nil
    for i, member in ipairs(tribe.members) do
        if member.userId == targetUserId then
            targetMemberIndex = i
            targetMemberRole = member.role
            targetMemberName = member.name
            break
        end
    end
    
    if not targetMemberIndex then
        self:SendTribeActionResponse(player, "promote_member", false, "Ce joueur n'est pas membre de votre tribu")
        return
    end
    
    -- Gérer la promotion selon le rôle actuel
    if targetMemberRole == TRIBE_ROLES.NOVICE then
        -- Promouvoir de novice à membre
        tribe.members[targetMemberIndex].role = TRIBE_ROLES.MEMBER
        
        -- Ajouter un événement au journal
        table.insert(tribe.log, {
            type = "member_promoted",
            time = os.time(),
            promoter = userId,
            target = targetUserId,
            fromRole = TRIBE_ROLES.NOVICE,
            toRole = TRIBE_ROLES.MEMBER,
            description = player.Name .. " a promu " .. targetMemberName .. " au rang de Membre"
        })
        
        -- Sauvegarder les données
        self:SaveTribeData(tribeId)
        
        -- Envoyer une réponse au joueur
        self:SendTribeActionResponse(player, "promote_member", true, "Vous avez promu " .. targetMemberName .. " au rang de Membre")
        
        -- Notifier le joueur cible s'il est en ligne
        local targetPlayer = Players:GetPlayerByUserId(targetUserId)
        if targetPlayer then
            self:SendTribeActionResponse(targetPlayer, "promoted", true, "Vous avez été promu au rang de Membre dans votre tribu")
        end
        
        -- Notifier tous les membres de la tribu
        self:NotifyTribeUpdate(tribeId)
        
        print("TribeService: " .. player.Name .. " a promu " .. targetMemberName .. " au rang de Membre")
        
    elseif targetMemberRole == TRIBE_ROLES.MEMBER then
        -- Promouvoir de membre à ancien
        tribe.members[targetMemberIndex].role = TRIBE_ROLES.ELDER
        
        -- Ajouter un événement au journal
        table.insert(tribe.log, {
            type = "member_promoted",
            time = os.time(),
            promoter = userId,
            target = targetUserId,
            fromRole = TRIBE_ROLES.MEMBER,
            toRole = TRIBE_ROLES.ELDER,
            description = player.Name .. " a promu " .. targetMemberName .. " au rang d'Ancien"
        })
        
        -- Sauvegarder les données
        self:SaveTribeData(tribeId)
        
        -- Envoyer une réponse au joueur
        self:SendTribeActionResponse(player, "promote_member", true, "Vous avez promu " .. targetMemberName .. " au rang d'Ancien")
        
        -- Notifier le joueur cible s'il est en ligne
        local targetPlayer = Players:GetPlayerByUserId(targetUserId)
        if targetPlayer then
            self:SendTribeActionResponse(targetPlayer, "promoted", true, "Vous avez été promu au rang d'Ancien dans votre tribu")
        end
        
        -- Notifier tous les membres de la tribu
        self:NotifyTribeUpdate(tribeId)
        
        print("TribeService: " .. player.Name .. " a promu " .. targetMemberName .. " au rang d'Ancien")
        
    elseif targetMemberRole == TRIBE_ROLES.ELDER then
        -- Ne peut pas promouvoir un ancien plus haut
        self:SendTribeActionResponse(player, "promote_member", false, "Ce membre est déjà un Ancien et ne peut pas être promu davantage")
        
    elseif targetMemberRole == TRIBE_ROLES.LEADER then
        -- Ne peut pas promouvoir le chef
        self:SendTribeActionResponse(player, "promote_member", false, "Vous ne pouvez pas promouvoir le chef de la tribu")
    end
end

-- Initialiser le service
function TribeService:Start(services)
    print("TribeService: Démarrage...")
    
    -- Récupérer les références aux autres services
    PlayerService = services.PlayerService
    InventoryService = services.InventoryService
    
    -- Configurer les événements RemoteEvent pour les tribus
    self:SetupRemoteEvents()
    
    -- Écouter les événements de joueur
    Players.PlayerAdded:Connect(function(player)
        self:LoadPlayerTribeData(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:HandlePlayerRemoving(player)
    end)
    
    print("TribeService: Démarré avec succès")
    return self
end

-- Configurer les événements RemoteEvent pour les tribus
function TribeService:SetupRemoteEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if not events then
        events = Instance.new("Folder")
        events.Name = "Events"
        events.Parent = ReplicatedStorage
    end
    
    -- Créer l'événement pour les actions de tribu
    local tribeActionEvent = events:FindFirstChild("TribeAction")
    if not tribeActionEvent then
        tribeActionEvent = Instance.new("RemoteEvent")
        tribeActionEvent.Name = "TribeAction"
        tribeActionEvent.Parent = events
    end
    
    -- Connecter l'événement aux fonctions de traitement
    tribeActionEvent.OnServerEvent:Connect(function(player, action, ...)
        self:HandleTribeAction(player, action, ...)
    end)
    
    -- Créer l'événement pour notifier les clients des changements de tribu
    local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
    if not tribeUpdateEvent then
        tribeUpdateEvent = Instance.new("RemoteEvent")
        tribeUpdateEvent.Name = "TribeUpdate"
        tribeUpdateEvent.Parent = events
    end
end

-- Charger les données de tribu pour un joueur
function TribeService:LoadPlayerTribeData(player)
    local userId = player.UserId
    
    -- Vérifier si le joueur est déjà dans une tribu
    spawn(function()
        local success, tribeId = pcall(function()
            return TribesDataStore:GetAsync("Player_" .. userId)
        end)
        
        if success and tribeId then
            -- Vérifier si la tribu existe dans la mémoire
            if not self.tribes[tribeId] then
                -- Charger les données de la tribu
                self:LoadTribeData(tribeId)
            end
            
            -- Associer le joueur à sa tribu
            self.playerTribes[userId] = tribeId
            
            -- Mettre à jour le statut "en ligne" du membre
            if self.tribes[tribeId] then
                for i, member in ipairs(self.tribes[tribeId].members) do
                    if member.userId == userId then
                        member.online = true
                        break
                    end
                end
                
                -- Notifier tous les membres de la tribu
                self:NotifyTribeUpdate(tribeId)
            end
        end
    end)
end

-- Charger les données d'une tribu
function TribeService:LoadTribeData(tribeId)
    spawn(function()
        local success, tribeData = pcall(function()
            return TribesDataStore:GetAsync("Tribe_" .. tribeId)
        end)
        
        if success and tribeData then
            -- Créer la structure de données de la tribu en mémoire
            self.tribes[tribeId] = tribeData
            
            -- Mettre à jour le statut en ligne des membres
            for i, member in ipairs(tribeData.members) do
                local memberPlayer = Players:GetPlayerByUserId(member.userId)
                member.online = memberPlayer ~= nil
            end
            
            print("TribeService: Tribu chargée - " .. tribeData.name)
        else
            warn("TribeService: Échec du chargement de la tribu " .. tribeId)
        end
    end)
end

-- Sauvegarder les données d'une tribu
function TribeService:SaveTribeData(tribeId)
    local tribeData = self.tribes[tribeId]
    if not tribeData then return end
    
    spawn(function()
        local success, err = pcall(function()
            TribesDataStore:SetAsync("Tribe_" .. tribeId, tribeData)
        end)
        
        if not success then
            warn("TribeService: Échec de la sauvegarde de la tribu " .. tribeId .. " - " .. tostring(err))
        end
    end)
end

-- Sauvegarder l'association joueur-tribu
function TribeService:SavePlayerTribeAssociation(userId, tribeId)
    spawn(function()
        local success, err = pcall(function()
            if tribeId then
                TribesDataStore:SetAsync("Player_" .. userId, tribeId)
            else
                TribesDataStore:RemoveAsync("Player_" .. userId)
            end
        end)
        
        if not success then
            warn("TribeService: Échec de la sauvegarde de l'association joueur-tribu pour " .. userId .. " - " .. tostring(err))
        end
    end)
end

-- Gérer les actions de tribu
function TribeService:HandleTribeAction(player, action, ...)
    local args = {...}
    
    if action == "create_tribe" then
        self:CreateTribe(player, args[1], args[2])  -- Nom, description
    elseif action == "join_tribe" then
        self:JoinTribe(player, args[1])  -- ID de la tribu
    elseif action == "leave_tribe" then
        self:LeaveTribe(player)
    elseif action == "invite_player" then
        self:InvitePlayerToTribe(player, args[1])  -- UserId du joueur à inviter
    elseif action == "kick_member" then
        self:KickMemberFromTribe(player, args[1])  -- UserId du membre à expulser
    elseif action == "promote_member" then
        self:PromoteMember(player, args[1])  -- UserId du membre à promouvoir
    elseif action == "demote_member" then
        self:DemoteMember(player, args[1])  -- UserId du membre à rétrograder
    elseif action == "set_tribe_description" then
        self:SetTribeDescription(player, args[1])  -- Nouvelle description
    elseif action == "set_tribe_territory" then
        self:SetTribeTerritory(player, args[1])  -- Position du centre du territoire
    end
end

return TribeService
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="48">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="Folder" referent="49">
      <Properties>
        <string name="Name">GameData</string>
      </Properties>
    </Item>
  </Item>
  <Item class="SoundService" referent="50">
    <Properties>
      <string name="Name">SoundService</string>
      <token name="AmbientReverb">16</token>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="51">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterCharacterScripts" referent="52">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
      <Item class="Folder" referent="53">
        <Properties>
          <string name="Name">CharacterScripts</string>
        </Properties>
      </Item>
    </Item>
    <Item class="StarterPlayerScripts" referent="54">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="55">
        <Properties>
          <string name="Name">Client</string>
          <string name="Source">-- src/client/init.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer

-- Importer les contrôleurs
local controllers = {}
controllers.PlayerController = require(script.controllers.PlayerController)
controllers.UIController = require(script.controllers.UIController)
controllers.CameraController = require(script.controllers.CameraController)

-- Importer les modules UI
local ui = {}
ui.StatsUI = require(script.ui.StatsUI)
ui.InventoryUI = require(script.ui.InventoryUI)
ui.CraftingUI = require(script.ui.CraftingUI)
ui.AgeUI = require(script.ui.AgeUI)
ui.NotificationUI = require(script.ui.NotificationUI)

local Client = {}

-- Initialiser les contrôleurs
function Client:InitializeControllers()
    -- Créer et initialiser les contrôleurs
    self.controllers = {}

    -- Initialiser le contrôleur d'interface utilisateur en premier
    self.controllers.UIController = controllers.UIController.new()
    self.controllers.UIController:Initialize(ui)

    -- Initialiser le contrôleur de caméra
    self.controllers.CameraController = controllers.CameraController.new()
    self.controllers.CameraController:Initialize()

    -- Initialiser le contrôleur de joueur avec accès au contrôleur UI et Camera
    self.controllers.PlayerController = controllers.PlayerController.new()
    self.controllers.PlayerController:Initialize(self.controllers.UIController, {
        CameraController = self.controllers.CameraController
    })

    print("Client: Contrôleurs initialisés")
end

-- Connecter aux événements du serveur
function Client:ConnectToServerEvents()
    -- Dans une implémentation réelle, vous utiliseriez RemoteEvent/RemoteFunction
    -- Ces connexions sont maintenant gérées dans les contrôleurs individuels
    -- Ajout de vérifications pour s'assurer que les contrôleurs gèrent les connexions
    if self.controllers.PlayerController and self.controllers.PlayerController.ConnectToServerEvents then
        self.controllers.PlayerController:ConnectToServerEvents()
    end

    if self.controllers.UIController and self.controllers.UIController.ConnectToServerEvents then
        self.controllers.UIController:ConnectToServerEvents()
    end

    if self.controllers.CameraController and self.controllers.CameraController.ConnectToServerEvents then
        self.controllers.CameraController:ConnectToServerEvents()
    end

    print("Client: Connexion aux événements serveur établie")
end

-- Configurer le chargement des assets
function Client:PreloadAssets()
    -- Précharger les assets pour éviter les lags pendant le jeu
    -- Cela peut inclure des images, des sons, des animations, etc.

    local assetIds = {
        -- Icônes d'interface
        "rbxassetid://6031071053", -- Info icon
        "rbxassetid://6031068420", -- Success icon
        "rbxassetid://6031071057", -- Warning icon
        "rbxassetid://6031071054", -- Error icon

        -- Animations
        "rbxassetid://507768375", -- Animation par défaut pour la récolte

        -- Autres assets
    }

    -- Précharger en arrière-plan avec gestion des erreurs
    spawn(function()
        for _, assetId in ipairs(assetIds) do
            local success, errorMessage = pcall(function()
                game:GetService("ContentProvider"):PreloadAsync({assetId})
            end)
            if not success then
                warn("Erreur lors du préchargement de l'asset : " .. assetId .. " - " .. errorMessage)
            end
            wait() -- Petit délai pour ne pas surcharger
        end
        print("Client: Préchargement des assets terminé")
    end)
end

-- Démarrer le client
function Client:Start()
    print("Client: Démarrage...")

    -- Attendre que le personnage soit chargé
    if not player.Character then
        player.CharacterAdded:Wait()
    end

    -- Précharger les assets
    self:PreloadAssets()

    -- Initialiser les contrôleurs
    self:InitializeControllers()

    -- Connecter aux événements du serveur
    self:ConnectToServerEvents()

    -- Afficher un message de démarrage via le contrôleur UI
    if self.controllers.UIController and self.controllers.UIController.interfaces and self.controllers.UIController.interfaces.notificationUI then
        self.controllers.UIController:DisplayMessage("Bienvenue dans The Beginning", "info", 8)
    end

    print("Client: Démarré avec succès")
end

Client:Start()

return Client</string>
        </Properties>
        <Item class="Folder" referent="56">
          <Properties>
            <string name="Name">controllers</string>
          </Properties>
          <Item class="ModuleScript" referent="57">
            <Properties>
              <string name="Name">AnimationController</string>
              <string name="Source">-- src/client/controllers/AnimationController.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local MiningAnimation = require(Shared.animations.MiningAnimation)

local AnimationController = {}
AnimationController.__index = AnimationController

function AnimationController.new()
    local self = setmetatable({}, AnimationController)
    
    -- Référence au joueur local
    self.player = Players.LocalPlayer
    
    -- Stockage des animations pré-chargées
    self.loadedAnimations = {}
    
    -- Animation en cours
    self.currentAnimation = nil
    
    return self
end

function AnimationController:Initialize()
    print("AnimationController: Initialisation...")
    
    -- Attendre que le personnage du joueur soit chargé
    if not self.player.Character then
        self.player.CharacterAdded:Wait()
    end
    
    -- Charger les animations de base
    self:PreloadAnimations()
    
    -- Configurer les événements
    self:SetupEvents()
    
    print("AnimationController: Initialisé avec succès")
end

-- Préchargement des animations courantes
function AnimationController:PreloadAnimations()
    local character = self.player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end
    
    -- Créer une animation de minage
    local miningAnimation = Instance.new("Animation")
    
    -- Note: Dans une implémentation réelle, vous utiliseriez un AnimationId d'une animation préenregistrée
    -- Pour cet exemple, nous utiliserons un ID fictif
    miningAnimation.AnimationId = "rbxassetid://156466309" -- Remplacer par un ID réel
    
    -- Charger l'animation
    self.loadedAnimations.mining = animator:LoadAnimation(miningAnimation)
    
    -- Configurer les propriétés
    self.loadedAnimations.mining.Priority = Enum.AnimationPriority.Action
    self.loadedAnimations.mining.Looped = false
    
    print("AnimationController: Animations préchargées")
end

-- Configurer les événements pour réagir aux actions du joueur
function AnimationController:SetupEvents()
    -- Se reconnecter quand le joueur change de personnage
    self.player.CharacterAdded:Connect(function(character)
        self:OnCharacterAdded(character)
    end)
    
    -- Écouter les événements liés aux outils
    local character = self.player.Character
    if character then
        character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                self:SetupToolAnimations(child)
            end
        end)
    end
    
    -- Écouter les événements d'action du joueur envoyés par le serveur
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local animEvent = events:FindFirstChild("PlayAnimation")
        if animEvent then
            animEvent.OnClientEvent:Connect(function(animationType, options)
                self:PlayAnimation(animationType, options)
            end)
        end
    end
end

-- Gérer un nouveau personnage
function AnimationController:OnCharacterAdded(character)
    -- Réinitialiser les animations stockées
    self.loadedAnimations = {}
    
    -- Recharger les animations de base
    wait(1) -- Attendre que le personnage soit complètement chargé
    self:PreloadAnimations()
    
    -- Configurer les événements des outils
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            self:SetupToolAnimations(child)
        end
    end)
end

-- Configurer les animations pour un outil spécifique
function AnimationController:SetupToolAnimations(tool)
    -- Vérifier si l'outil a déjà un script d'animation
    if tool:FindFirstChild("MiningAnimationController") then return end
    
    -- Vérifier le type d'outil
    local toolType = tool:GetAttribute("ToolType")
    
    if toolType == "pickaxe" then
        -- Utiliser l'animation de minage pour les pioches
        MiningAnimation.SetupToolAnimation(tool)
    elseif toolType == "axe" then
        -- On pourrait avoir une animation similaire ou différente pour la hache
        MiningAnimation.SetupToolAnimation(tool)
    end
end

-- Jouer une animation par son type
function AnimationController:PlayAnimation(animationType, options)
    options = options or {}
    
    -- Arrêter l'animation courante si nécessaire
    if self.currentAnimation and self.currentAnimation.IsPlaying then
        if options.forceStop or not options.blendAnimation then
            self.currentAnimation:Stop()
        end
    end
    
    -- Sélectionner l'animation à jouer
    local animation = self.loadedAnimations[animationType]
    
    if animation then
        -- Configurer les options de l'animation
        if options.speed then
            animation:AdjustSpeed(options.speed)
        else
            animation:AdjustSpeed(1) -- Vitesse normale par défaut
        end
        
        if options.fadeTime then
            animation:Play(options.fadeTime)
        else
            animation:Play()
        end
        
        -- Stocker l'animation courante
        self.currentAnimation = animation
        
        -- Connecter l'événement de fin si une fonction de rappel est fournie
        if options.onFinished then
            local connection
            connection = animation.Stopped:Connect(function()
                options.onFinished()
                connection:Disconnect()
            end)
        end
        
        return animation
    else
        warn("AnimationController: Animation non trouvée -", animationType)
        return nil
    end
end

-- Jouer directement l'animation de minage
function AnimationController:PlayMiningAnimation()
    local character = self.player.Character
    if not character then return nil end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return nil end
    
    -- Créer et jouer l'animation programmatiquement
    return MiningAnimation.Play(humanoid)
end

-- Arrêter toutes les animations
function AnimationController:StopAllAnimations()
    for _, animation in pairs(self.loadedAnimations) do
        if animation.IsPlaying then
            animation:Stop()
        end
    end
    
    self.currentAnimation = nil
end

return AnimationController</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="58">
            <Properties>
              <string name="Name">CameraController</string>
              <string name="Source"><![CDATA[-- src/client/controllers/CameraController.lua
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ContextActionService = game:GetService("ContextActionService")

local CameraController = {}
CameraController.__index = CameraController

-- Définition des modes de caméra
local CAMERA_MODES = {
    FOLLOW = "follow",     -- Caméra qui suit le joueur (standard)
    FIRST_PERSON = "first", -- Vue à la première personne
    BUILDING = "building", -- Mode construction (plus éloigné et plus haut)
    ORBIT = "orbit"        -- Mode orbite pour les menus et interfaces
}

function CameraController.new()
    local self = setmetatable({}, CameraController)
    
    -- Référence au joueur et à la caméra
    self.player = Players.LocalPlayer
    self.camera = workspace.CurrentCamera
    
    -- Paramètres de la caméra
    self.mode = CAMERA_MODES.FOLLOW
    self.previousMode = nil       -- Pour retourner au mode précédent
    self.distance = 12            -- Distance standard en mode suivi
    self.height = 2               -- Hauteur standard en mode suivi
    self.angle = 0                -- Angle horizontal de la caméra
    self.verticalAngle = 0.3      -- Angle vertical (en radians)
    self.sensitivity = 0.005      -- Sensibilité de rotation de la caméra
    self.smoothness = 0.2         -- Facteur de lissage des mouvements
    self.isRotating = false       -- Si la caméra est en rotation (clic droit)
    self.zoomSpeed = 1            -- Vitesse de zoom avec la molette
    self.minZoomDistance = 2      -- Distance minimale de zoom
    self.maxZoomDistance = 30     -- Distance maximale de zoom
    self.isControlEnabled = true  -- Si les contrôles de caméra sont activés
    
    -- Paramètres d'orbite
    self.orbitTarget = nil        -- Cible pour le mode orbite (Vector3)
    self.orbitDistance = 20       -- Distance en mode orbite
    self.orbitAngle = 0           -- Angle horizontal en mode orbite
    self.orbitVerticalAngle = 0.5 -- Angle vertical en mode orbite
    
    -- Paramètres de collision
    self.checkCollisions = true   -- Vérifier les collisions avec les objets
    self.collisionOffset = 0.5    -- Décalage pour éviter les problèmes de collision
    
    -- Différentes configurations par mode
    self.modeSettings = {
        [CAMERA_MODES.FOLLOW] = {
            distance = 12,
            height = 2,
            verticalAngle = 0.3,
            minZoomDistance = 2,
            maxZoomDistance = 30
        },
        [CAMERA_MODES.FIRST_PERSON] = {
            distance = 0,
            height = 1.6,
            verticalAngle = 0,
            minZoomDistance = 0,
            maxZoomDistance = 0
        },
        [CAMERA_MODES.BUILDING] = {
            distance = 20,
            height = 10,
            verticalAngle = 0.6,
            minZoomDistance = 5,
            maxZoomDistance = 40
        },
        [CAMERA_MODES.ORBIT] = {
            distance = 20,
            height = 5,
            verticalAngle = 0.5,
            minZoomDistance = 5,
            maxZoomDistance = 50
        }
    }
    
    -- État des touches
    self.keyStates = {}
    
    -- Référence au controller d'UI pour synchroniser les états
    self.uiController = nil
    
    return self
end

function CameraController:Initialize(uiController)
    -- Stocker la référence au contrôleur d'interface utilisateur
    self.uiController = uiController
    
    -- Définir le type de caméra
    self.camera.CameraType = Enum.CameraType.Scriptable
    
    -- Initialiser la position et rotation de la caméra
    local character = self.player.Character or self.player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart", 5)
    
    if rootPart then
        -- Position initiale basée sur le personnage
        self.angle = rootPart.Orientation.Y * math.pi / 180
    end
    
    -- Connecter les événements
    self:ConnectEvents()
    
    -- Démarrer la boucle de mise à jour
    self:StartUpdateLoop()
    
    print("CameraController: Initialisé")
end

function CameraController:ConnectEvents()
    -- Gérer les événements de Character
    self.player.CharacterAdded:Connect(function(character)
        -- Attendre que le personnage soit prêt
        local humanoid = character:WaitForChild("Humanoid", 5)
        local rootPart = character:WaitForChild("HumanoidRootPart", 5)
        
        if humanoid and rootPart then
            -- Réinitialiser certains paramètres lorsqu'un nouveau personnage apparaît
            if self.mode == CAMERA_MODES.FIRST_PERSON then
                -- Rendre le personnage transparent en mode première personne
                self:SetCharacterTransparency(0.7)
            elseif self.mode == CAMERA_MODES.FOLLOW then
                -- Initialiser l'angle pour qu'il corresponde à la direction du personnage
                self.angle = rootPart.Orientation.Y * math.pi / 180
            end
        end
    end)
    
    -- Rotation avec clic droit
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not self.isControlEnabled then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            self.isRotating = true
        elseif input.KeyCode == Enum.KeyCode.Tab then
            -- Changer de mode de caméra avec Tab
            self:CycleCamera()
        end
        
        -- Mémoriser l'état des touches
        if input.UserInputType == Enum.UserInputType.Keyboard then
            self.keyStates[input.KeyCode] = true
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            self.isRotating = false
        end
        
        -- Mémoriser l'état des touches
        if input.UserInputType == Enum.UserInputType.Keyboard then
            self.keyStates[input.KeyCode] = false
        end
    end)
    
    -- Rotation de la caméra avec le mouvement de la souris
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if gameProcessed or not self.isControlEnabled then return end
        
        if self.isRotating and input.UserInputType == Enum.UserInputType.MouseMovement then
            -- Calculer la nouvelle rotation
            self.angle = self.angle - input.Delta.X * self.sensitivity
            
            -- Limiter l'angle vertical pour éviter les rotations complètes
            local newVertAngle = self.verticalAngle - input.Delta.Y * self.sensitivity
            self.verticalAngle = math.clamp(newVertAngle, -1.2, 1.2)
        end
    end)
    
    -- Zoom avec la molette de la souris
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if gameProcessed or not self.isControlEnabled then return end
        
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            local modeSettings = self.modeSettings[self.mode]
            local delta = input.Position.Z * self.zoomSpeed
            
            if self.mode ~= CAMERA_MODES.FIRST_PERSON then
                local newDistance = self.distance - delta
                self.distance = math.clamp(newDistance, modeSettings.minZoomDistance, modeSettings.maxZoomDistance)
            end
        end
    end)
    
    -- Gérer les touches de fonction pour les raccourcis caméra
    -- Raccourci pour la vue première personne (F1)
    ContextActionService:BindAction("ToggleFirstPerson", function(_, state)
        if state == Enum.UserInputState.Begin then
            if self.mode == CAMERA_MODES.FIRST_PERSON then
                self:SetMode(CAMERA_MODES.FOLLOW)
            else
                self:SetMode(CAMERA_MODES.FIRST_PERSON)
            end
        end
    end, false, Enum.KeyCode.F1)
    
    -- Raccourci pour la vue construction (F2)
    ContextActionService:BindAction("ToggleBuildingView", function(_, state)
        if state == Enum.UserInputState.Begin then
            if self.mode == CAMERA_MODES.BUILDING then
                self:SetMode(CAMERA_MODES.FOLLOW)
            else
                self:SetMode(CAMERA_MODES.BUILDING)
            end
        end
    end, false, Enum.KeyCode.F2)
    
    -- Raccourci pour reset la caméra (R)
    ContextActionService:BindAction("ResetCamera", function(_, state)
        if state == Enum.UserInputState.Begin then
            self:ResetCamera()
        end
    end, false, Enum.KeyCode.R)
end

function CameraController:StartUpdateLoop()
    -- Mettre à jour la caméra à chaque frame
    RunService:BindToRenderStep("CameraUpdate", Enum.RenderPriority.Camera.Value + 1, function(dt)
        self:Update(dt)
    end)
end

function CameraController:Update(dt)
    -- Vérifier si le personnage et le HumanoidRootPart existent
    local character = self.player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Gérer différents modes de caméra
    if self.mode == CAMERA_MODES.FOLLOW then
        self:UpdateFollowCamera(rootPart, dt)
    elseif self.mode == CAMERA_MODES.FIRST_PERSON then
        self:UpdateFirstPersonCamera(rootPart, humanoid, dt)
    elseif self.mode == CAMERA_MODES.BUILDING then
        self:UpdateBuildingCamera(rootPart, dt)
    elseif self.mode == CAMERA_MODES.ORBIT then
        self:UpdateOrbitCamera(dt)
    end
end

function CameraController:UpdateFollowCamera(rootPart, dt)
    -- Calculer la position idéale de la caméra (derrière le joueur)
    local targetPosition = rootPart.Position +
                          Vector3.new(0, self.height, 0) -
                          (CFrame.Angles(0, self.angle, 0).LookVector * self.distance * math.cos(self.verticalAngle)) +
                          Vector3.new(0, self.distance * math.sin(self.verticalAngle), 0)
    
    -- Vérifier les collisions avec l'environnement
    if self.checkCollisions then
        targetPosition = self:AdjustCameraForCollisions(rootPart.Position + Vector3.new(0, self.height, 0), targetPosition)
    end
    
    -- Calculer la position de visée (la tête du joueur)
    local lookPosition = rootPart.Position + Vector3.new(0, self.height, 0)
    
    -- Appliquer un lissage aux mouvements de la caméra
    self.camera.CFrame = self.camera.CFrame:Lerp(CFrame.new(targetPosition, lookPosition), self.smoothness)
end

function CameraController:UpdateFirstPersonCamera(rootPart, humanoid, dt)
    -- Position de la tête du joueur
    local headPosition = rootPart.Position + Vector3.new(0, self.modeSettings[self.mode].height, 0)
    
    -- Direction de regard
    local lookDirection = CFrame.Angles(0, self.angle, 0) * CFrame.Angles(self.verticalAngle, 0, 0)
    
    -- Définir la caméra
    self.camera.CFrame = CFrame.new(headPosition) * lookDirection
    
    -- En mode première personne, la direction du regard influence la direction du personnage
    if humanoid and humanoid.MoveDirection.Magnitude > 0 then
        humanoid.AutoRotate = false
        rootPart.CFrame = CFrame.new(rootPart.Position) * CFrame.Angles(0, self.angle, 0)
    else
        humanoid.AutoRotate = true
    end
end

function CameraController:UpdateBuildingCamera(rootPart, dt)
    -- En mode construction, la caméra est plus haute et plus éloignée
    local targetPosition = rootPart.Position +
                          Vector3.new(0, self.height, 0) -
                          (CFrame.Angles(0, self.angle, 0).LookVector * self.distance * math.cos(self.verticalAngle)) +
                          Vector3.new(0, self.distance * math.sin(self.verticalAngle), 0)
    
    -- Vérifier les collisions avec l'environnement
    if self.checkCollisions then
        targetPosition = self:AdjustCameraForCollisions(rootPart.Position + Vector3.new(0, self.height, 0), targetPosition)
    end
    
    -- La caméra regarde vers le sol devant le joueur
    local lookPosition = rootPart.Position + CFrame.Angles(0, self.angle, 0).LookVector * 10
    
    -- Appliquer un lissage aux mouvements de la caméra
    self.camera.CFrame = self.camera.CFrame:Lerp(CFrame.new(targetPosition, lookPosition), self.smoothness)
end

function CameraController:UpdateOrbitCamera(dt)
    -- En mode orbite, la caméra tourne autour d'un point fixe
    if not self.orbitTarget then
        -- Si aucune cible n'est définie, utiliser la position du joueur
        local character = self.player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            self.orbitTarget = character.HumanoidRootPart.Position
        else
            self.orbitTarget = Vector3.new(0, 0, 0)
        end
    end
    
    -- Calculer la position de la caméra
    local targetPosition = self.orbitTarget +
                          (CFrame.Angles(0, self.orbitAngle, 0).LookVector * -self.orbitDistance * math.cos(self.orbitVerticalAngle)) +
                          Vector3.new(0, self.orbitDistance * math.sin(self.orbitVerticalAngle), 0)
    
    -- La caméra regarde vers la cible
    local lookPosition = self.orbitTarget
    
    -- Appliquer un lissage aux mouvements de la caméra
    self.camera.CFrame = self.camera.CFrame:Lerp(CFrame.new(targetPosition, lookPosition), self.smoothness)
    
    -- Faire tourner lentement la caméra autour de la cible (effet ambiance)
    self.orbitAngle = self.orbitAngle + 0.0005
end

-- Ajuster la position de la caméra pour éviter les collisions
function CameraController:AdjustCameraForCollisions(origin, desiredCameraPos)
    local direction = (desiredCameraPos - origin).Unit
    local distance = (desiredCameraPos - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {self.player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(origin, direction * distance, raycastParams)
    
    if raycastResult then
        -- Ajouter un petit décalage pour éviter les problèmes de clipping
        return raycastResult.Position + (origin - raycastResult.Position).Unit * self.collisionOffset
    end
    
    return desiredCameraPos
end

function CameraController:SetMode(mode)
    if not self.modeSettings[mode] then
        warn("CameraController: Mode de caméra invalide - " .. tostring(mode))
        return
    end
    
    -- Sauvegarder le mode précédent
    self.previousMode = self.mode
    
    -- Mettre à jour le mode
    self.mode = mode
    
    -- Appliquer les paramètres du mode
    local settings = self.modeSettings[mode]
    self.distance = settings.distance
    self.height = settings.height
    self.verticalAngle = settings.verticalAngle
    
    -- Réinitialiser certains paramètres selon le mode
    if mode == CAMERA_MODES.FIRST_PERSON then
        -- Rendre le personnage transparent en première personne
        self:SetCharacterTransparency(0.7)
    else
        -- Restaurer la visibilité du personnage
        self:SetCharacterTransparency(0)
    end
    
    print("CameraController: Mode changé pour " .. mode)
end

-- Modifier la transparence du personnage (utile en mode première personne)
function CameraController:SetCharacterTransparency(transparency)
    local character = self.player.Character
    if not character then return end
    
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            -- Utiliser LocalTransparencyModifier au lieu de Transparency 
            -- car il n'affecte que le client local
            part.LocalTransparencyModifier = transparency
        end
    end
end

-- Passer au mode de caméra suivant
function CameraController:CycleCamera()
    local modes = {
        CAMERA_MODES.FOLLOW,
        CAMERA_MODES.FIRST_PERSON,
        CAMERA_MODES.BUILDING
    }
    
    local currentIndex = table.find(modes, self.mode) or 1
    local nextIndex = (currentIndex % #modes) + 1
    
    self:SetMode(modes[nextIndex])
end

-- Réinitialiser la caméra à sa position par défaut
function CameraController:ResetCamera()
    local character = self.player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    -- Réinitialiser l'angle pour qu'il corresponde à la direction du personnage
    self.angle = rootPart.Orientation.Y * math.pi / 180
    
    -- Réinitialiser l'angle vertical
    self.verticalAngle = self.modeSettings[self.mode].verticalAngle
    
    -- Réinitialiser la distance
    self.distance = self.modeSettings[self.mode].distance
    
    print("CameraController: Caméra réinitialisée")
end

-- Passer temporairement en mode construction
function CameraController:EnterBuildingMode()
    if self.mode ~= CAMERA_MODES.BUILDING then
        self.previousMode = self.mode
        self:SetMode(CAMERA_MODES.BUILDING)
    end
end

-- Quitter le mode construction
function CameraController:ExitBuildingMode()
    if self.mode == CAMERA_MODES.BUILDING and self.previousMode then
        self:SetMode(self.previousMode)
    end
end

-- Entrer en mode orbite (pour les menus et interfaces)
function CameraController:EnterOrbitMode(target)
    if self.mode ~= CAMERA_MODES.ORBIT then
        self.previousMode = self.mode
        
        -- Si une cible est spécifiée, l'utiliser
        if target then
            self.orbitTarget = target
        else
            -- Sinon, utiliser la position du joueur
            local character = self.player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                self.orbitTarget = character.HumanoidRootPart.Position
            end
        end
        
        self:SetMode(CAMERA_MODES.ORBIT)
    end
end

-- Quitter le mode orbite
function CameraController:ExitOrbitMode()
    if self.mode == CAMERA_MODES.ORBIT and self.previousMode then
        self:SetMode(self.previousMode)
    end
end

-- Activer/désactiver les contrôles de caméra
function CameraController:SetControlsEnabled(enabled)
    self.isControlEnabled = enabled
end

-- Verrouiller la caméra sur une cible
function CameraController:LockOnTarget(target)
    if not target then return end
    
    -- Sauvegarder les paramètres actuels
    local origSmoothness = self.smoothness
    self.smoothness = 0.1 -- Plus lisse pour le mouvement vers la cible
    
    -- Déplacer la caméra vers la cible
    local targetPosition = target.Position
    local character = self.player.Character
    
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPosition = character.HumanoidRootPart.Position
        
        -- Calculer l'angle pour faire face à la cible
        local direction = (targetPosition - rootPosition).Unit
        self.angle = math.atan2(-direction.X, -direction.Z)
        
        -- Forcer une mise à jour immédiate
        self:Update(0)
    end
    
    -- Restaurer les paramètres originaux
    self.smoothness = origSmoothness
end

return CameraController
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="59">
            <Properties>
              <string name="Name">PlayerController</string>
              <string name="Source">-- src/client/controllers/PlayerController.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)
local ItemTypes = require(Shared.constants.ItemTypes)

local PlayerController = {}
PlayerController.__index = PlayerController

function PlayerController.new()
    local self = setmetatable({}, PlayerController)

    -- Référence au joueur local
    self.player = Players.LocalPlayer

    -- Référence au contrôleur UI (sera initialisé dans Initialize)
    self.uiController = nil

    -- État actuel du personnage
    self.characterState = {
        isWalking = false,
        isRunning = false,
        isSleeping = false,
        isBuilding = false,
        isHarvesting = false,
        targetResource = nil,
        buildingPreview = nil,
        equippedTool = nil
    }

    -- Constantes
    self.walkSpeed = GameSettings.Player.walkSpeed
    self.runSpeed = GameSettings.Player.runSpeed
    self.interactionDistance = GameSettings.Player.interactionDistance

    return self
end

function PlayerController:Initialize(uiController)
    self.uiController = uiController

    -- Attendre que le personnage soit chargé
    if not self.player.Character then
        self.player.CharacterAdded:Wait()
    end

    -- Configurer les actions et contrôles
    self:SetupControls()

    -- Configurer les événements du personnage
    self:SetupCharacterEvents()

    -- Configurer les événements du serveur
    self:SetupServerEvents()

    print("PlayerController: Initialisé")
end

-- Configurer les contrôles du joueur
function PlayerController:SetupControls()
    -- Course (Shift)
    ContextActionService:BindAction("Sprint", function(actionName, inputState, inputObject)
        if inputState == Enum.UserInputState.Begin then
            self:StartSprinting()
        elseif inputState == Enum.UserInputState.End then
            self:StopSprinting()
        end
    end, false, Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift)

    -- Interaction (F)
    ContextActionService:BindAction("Interact", function(actionName, inputState, inputObject)
        if inputState == Enum.UserInputState.Begin then
            self:TryInteract()
        end
    end, false, Enum.KeyCode.F)

    -- Inventaire (E)
    ContextActionService:BindAction("Inventory", function(actionName, inputState, inputObject)
        if inputState == Enum.UserInputState.Begin then
            if self.uiController then
                self.uiController:ToggleInventory()
            end
        end
    end, false, Enum.KeyCode.E)

    -- Artisanat (C)
    ContextActionService:BindAction("Crafting", function(actionName, inputState, inputObject)
        if inputState == Enum.UserInputState.Begin then
            if self.uiController then
                self.uiController:ToggleCrafting()
            end
        end
    end, false, Enum.KeyCode.C)

    -- Touche d'annulation (Échap) - Pour annuler la construction, etc.
    ContextActionService:BindAction("Cancel", function(actionName, inputState, inputObject)
        if inputState == Enum.UserInputState.Begin then
            self:CancelCurrentAction()
        end
    end, false, Enum.KeyCode.Escape)

    -- Touches d'action rapide pour outils (1-5)
    for i = 1, 5 do
        local keyCode = Enum.KeyCode["Number" .. i]
        ContextActionService:BindAction("QuickSlot" .. i, function(actionName, inputState, inputObject)
            if inputState == Enum.UserInputState.Begin then
                self:SelectQuickSlot(i)
            end
        end, false, keyCode)
    end

    -- Clic pour attaquer ou placer un bâtiment
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end

        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            if self.characterState.isBuilding then
                self:TryPlaceBuilding()
            else
                self:TryAttackOrHarvest()
            end
        end

        -- Clic droit pour rotation lors de construction
        if input.UserInputType == Enum.UserInputType.MouseButton2 and self.characterState.isBuilding then
            self:RotateBuildingPreview()
        end
    end)

    -- Mouvement de souris pour mettre à jour la position du prévisualisation de construction
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if self.characterState.isBuilding and self.characterState.buildingPreview then
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                self:UpdateBuildingPreviewPosition()
            end
        end
    end)

    print("PlayerController: Contrôles configurés")
end

-- Configurer les événements liés au personnage
function PlayerController:SetupCharacterEvents()
    -- Gérer les personnages existants et futurs
    if self.player.Character then
        self:SetupCharacter(self.player.Character)
    end

    self.player.CharacterAdded:Connect(function(character)
        self:SetupCharacter(character)
    end)

    print("PlayerController: Événements du personnage configurés")
end

-- Configurer un personnage spécifique
function PlayerController:SetupCharacter(character)
    -- Référence à l'humanoid
    local humanoid = character:WaitForChild("Humanoid")

    -- Configurer la vitesse initiale
    humanoid.WalkSpeed = self.walkSpeed

    -- Réinitialiser l'état du personnage
    self.characterState = {
        isWalking = false,
        isRunning = false,
        isSleeping = false,
        isBuilding = false,
        isHarvesting = false,
        targetResource = nil,
        buildingPreview = nil,
        equippedTool = nil
    }

    -- Événement de mouvement
    humanoid.Running:Connect(function(speed)
        self.characterState.isWalking = speed > 0.1
    end)

    -- Événement de mort
    humanoid.Died:Connect(function()
        self:HandleCharacterDied()
    end)

    -- Événement de changement d'état
    humanoid.StateChanged:Connect(function(oldState, newState)
        self:HandleStateChanged(oldState, newState)
    end)
end

-- Configurer les événements du serveur
function PlayerController:SetupServerEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")

    if events then
        -- Mise à jour de l'inventaire
        local updateInventoryEvent = events:FindFirstChild("UpdateInventory")
        if updateInventoryEvent then
            updateInventoryEvent.OnClientEvent:Connect(function(inventoryData)
                self:HandleInventoryUpdate(inventoryData)
            end)
        end

        -- Notification de début de construction
        local buildingStartEvent = events:FindFirstChild("BuildingStart")
        if buildingStartEvent then
            buildingStartEvent.OnClientEvent:Connect(function(itemId, previewInstance)
                self:StartBuilding(itemId, previewInstance)
            end)
        end

        -- Notification de sommeil
        local sleepEvent = events:FindFirstChild("Sleep")
        if sleepEvent then
            sleepEvent.OnClientEvent:Connect(function(isSleeping)
                self:SetSleepingState(isSleeping)
            end)
        end

        -- Notification générale
        local notificationEvent = events:FindFirstChild("Notification")
        if notificationEvent then
            notificationEvent.OnClientEvent:Connect(function(message, messageType, duration)
                if self.uiController then
                    self.uiController:DisplayMessage(message, messageType, duration)
                end
            end)
        end

        -- Notification de mort
        local deathEvent = events:FindFirstChild("Death")
        if deathEvent then
            deathEvent.OnClientEvent:Connect(function(causeOfDeath)
                if self.uiController then
                    self.uiController:DisplayDeathMessage(causeOfDeath)
                end
            end)
        end

        -- Notification de naissance/réapparition
        local birthEvent = events:FindFirstChild("Birth")
        if birthEvent then
            birthEvent.OnClientEvent:Connect(function(parentName)
                if self.uiController then
                    self.uiController:DisplayBirthMessage(parentName)
                end
            end)
        end
    end

    print("PlayerController: Événements du serveur configurés")
end

-- Gérer la mise à jour de l'inventaire
function PlayerController:HandleInventoryUpdate(inventoryData)
    -- Mettre à jour l'interface d'inventaire
    if self.uiController then
        self.uiController:UpdateInventory(inventoryData)
    end

    -- Mettre à jour l'outil équipé
    if inventoryData.equipped and inventoryData.equipped.tool then
        local slotNumber = inventoryData.equipped.tool
        local item = inventoryData.items[slotNumber]

        if item then
            self.characterState.equippedTool = {
                id = item.id,
                type = ItemTypes[item.id] and ItemTypes[item.id].toolType or nil
            }
        else
            self.characterState.equippedTool = nil
        end
    else
        self.characterState.equippedTool = nil
    end
end

-- Commencer à sprinter
function PlayerController:StartSprinting()
    local character = self.player.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character.Humanoid
    humanoid.WalkSpeed = self.runSpeed
    self.characterState.isRunning = true

    -- Dans une implémentation réelle, envoyer un événement au serveur
    -- pour augmenter la consommation d'énergie pendant la course
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            playerActionEvent:FireServer("sprint_start")
        end
    end

    print("PlayerController: Début du sprint")
end

-- Arrêter de sprinter
function PlayerController:StopSprinting()
    local character = self.player.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character.Humanoid
    humanoid.WalkSpeed = self.walkSpeed
    self.characterState.isRunning = false

    -- Dans une implémentation réelle, envoyer un événement au serveur
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            playerActionEvent:FireServer("sprint_stop")
        end
    end

    print("PlayerController: Fin du sprint")
end

-- Essayer d'interagir avec un objet dans le monde
function PlayerController:TryInteract()
    -- Si le joueur est en train de dormir, l'arrêter
    if self.characterState.isSleeping then
        self:SetSleepingState(false)
        return
    end

    local character = self.player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local rootPart = character.HumanoidRootPart

    -- Lancer un rayon à partir de la caméra
    local mouse = self.player:GetMouse()
    local camera = workspace.CurrentCamera

    local rayOrigin = camera.CFrame.Position
    local rayDirection = (mouse.Hit.Position - rayOrigin).Unit * self.interactionDistance

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    local hitPart = raycastResult and raycastResult.Instance
    local hitPosition = raycastResult and raycastResult.Position

    if hitPart then
        local model = hitPart:FindFirstAncestorOfClass("Model")

        if model then
            -- Vérifier le type de modèle pour déterminer l'interaction
            local resourceType = model:GetAttribute("ResourceType")
            local buildingType = model:GetAttribute("BuildingType")

            if resourceType then
                -- Interagir avec une ressource
                self:InteractWithResource(model, resourceType)
            elseif buildingType then
                -- Interagir avec un bâtiment
                self:InteractWithBuilding(model, buildingType)
            else
                print("PlayerController: Interaction avec un objet inconnu")
            end
        end
    end
end

-- Interagir avec une ressource
function PlayerController:InteractWithResource(resourceModel, resourceType)
    -- Dans une implémentation réelle, envoyer un événement au serveur
    local events = ReplicatedStorage:FindFirstChild("Events")

    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            self:PlayHarvestAnimation(resourceType)

            playerActionEvent:FireServer("gather_resource", resourceType, resourceModel)

            -- Mettre à jour l'état du personnage
            self.characterState.isHarvesting = true
            self.characterState.targetResource = resourceModel

            -- Après un délai, remettre l'état à normal
            delay(2, function()
                self.characterState.isHarvesting = false
                self.characterState.targetResource = nil
            end)

            print("PlayerController: Récolte de ressource - " .. resourceType)
        end
    end
end

-- Jouer une animation de récolte selon le type de ressource
function PlayerController:PlayHarvestAnimation(resourceType)
    local character = self.player.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character.Humanoid
    local animator = humanoid:FindFirstChildOfClass("Animator")

    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end

    -- Animation selon le type d'outil nécessaire
    local animationId = "rbxassetid://507768375" -- Animation par défaut

    -- Dans une implémentation réelle, charger les animations appropriées
    if resourceType == "wood" then
        animationId = "rbxassetid://12345720" -- Animation de hache
    elseif resourceType == "stone" or resourceType:find("_ore") then
        animationId = "rbxassetid://12345721" -- Animation de pioche
    elseif resourceType == "berry_bush" or resourceType == "fiber" then
        animationId = "rbxassetid://12345722" -- Animation de cueillette
    end

    -- Dans ce prototype, utiliser une animation de remplacement
    local animation = Instance.new("Animation")
    animation.AnimationId = animationId

    local animTrack = animator:LoadAnimation(animation)
    animTrack:Play()

    -- Auto-destruction de l'objet Animation après lecture
    animTrack.Stopped:Connect(function()
        animation:Destroy()
    end)
end

-- Interagir avec un bâtiment
function PlayerController:InteractWithBuilding(buildingModel, buildingType)
    -- Dans une implémentation réelle, envoyer un événement au serveur
    local events = ReplicatedStorage:FindFirstChild("Events")

    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            local structureId = buildingModel:GetAttribute("StructureId")

            if structureId then
                playerActionEvent:FireServer("interact_building", structureId, "use")

                print("PlayerController: Utilisation du bâtiment - " .. buildingType)

                -- Cas spéciaux pour certains types de bâtiments
                if buildingType == "wooden_bed" then
                    self:SetSleepingState(true)
                end
            end
        end
    end
end

-- Définir l'état de sommeil
function PlayerController:SetSleepingState(isSleeping)
    local character = self.player.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character.Humanoid

    self.characterState.isSleeping = isSleeping

    if isSleeping then
        -- Mettre le joueur en position allongée
        humanoid.Sit = true
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0

        -- Envoyer un événement au serveur
        local events = ReplicatedStorage:FindFirstChild("Events")
        if events then
            local playerActionEvent = events:FindFirstChild("PlayerAction")
            if playerActionEvent then
                playerActionEvent:FireServer("sleep")
            end
        end

        print("PlayerController: Début du sommeil")
    else
        -- Remettre le joueur debout
        humanoid.Sit = false
        humanoid.WalkSpeed = self.walkSpeed
        humanoid.JumpPower = 50

        -- Envoyer un événement au serveur
        local events = ReplicatedStorage:FindFirstChild("Events")
        if events then
            local playerActionEvent = events:FindFirstChild("PlayerAction")
            if playerActionEvent then
                playerActionEvent:FireServer("wake_up")
            end
        end

        print("PlayerController: Fin du sommeil")
    end
end

-- Commencer la construction
function PlayerController:StartBuilding(itemId, previewInstance)
    self.characterState.isBuilding = true
    self.characterState.buildingPreview = previewInstance

    -- Dans une implémentation réelle, le prévisualisation serait créé ici
    if not previewInstance then
        -- Code pour créer le prévisualisation côté client
        -- Cet exemple est simplifié; une implémentation complète créerait
        -- un modèle basé sur itemId et le positionnerait devant le joueur
        self.characterState.buildingPreview = Instance.new("Part")
        self.characterState.buildingPreview.Name = "BuildingPreview"
        self.characterState.buildingPreview.Transparency = 0.5
        self.characterState.buildingPreview.CanCollide = false
        self.characterState.buildingPreview.Anchored = true
        self.characterState.buildingPreview.Material = Enum.Material.Plastic

        -- Définir la taille en fonction du type d'objet
        if itemId == "wooden_wall" then
            self.characterState.buildingPreview.Size = Vector3.new(0.2, 3, 4)
        elseif itemId == "wooden_floor" then
            self.characterState.buildingPreview.Size = Vector3.new(4, 0.2, 4)
        elseif itemId == "wooden_door" then
            self.characterState.buildingPreview.Size = Vector3.new(0.2, 3, 1.5)
        elseif itemId == "wooden_bed" then
            self.characterState.buildingPreview.Size = Vector3.new(2, 0.5, 4)
        elseif itemId == "wooden_table" then
            self.characterState.buildingPreview.Size = Vector3.new(3, 1, 1.5)
        elseif itemId == "wooden_chair" then
            self.characterState.buildingPreview.Size = Vector3.new(1, 1.5, 1)
        elseif itemId == "campfire" or itemId == "furnace" then
            self.characterState.buildingPreview.Size = Vector3.new(2, 1, 2)
        elseif itemId == "anvil" then
            self.characterState.buildingPreview.Size = Vector3.new(1, 1, 2)
        else
            self.characterState.buildingPreview.Size = Vector3.new(1, 1, 1)
        end

        self.characterState.buildingPreview.Parent = workspace
    end

    -- Mettre à jour la position du prévisualisation
    self:UpdateBuildingPreviewPosition()

    print("PlayerController: Début de la construction - " .. itemId)
end

-- Mettre à jour la position du prévisualisation de construction
function PlayerController:UpdateBuildingPreviewPosition()
    if not self.characterState.isBuilding or not self.characterState.buildingPreview then return end

    local character = self.player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local rootPart = character.HumanoidRootPart

    -- Obtenir la position à partir du raycast de la souris
    local mouse = self.player:GetMouse()
    local hitPosition = mouse.Hit.Position

    -- Ajuster la hauteur en fonction du type d'objet
    local previewCFrame = CFrame.new(hitPosition)

    -- Dans une implémentation réelle, on ajusterait aussi la rotation
    -- en fonction de la direction du personnage ou d'autres facteurs

    -- Définir la position du prévisualisation
    self.characterState.buildingPreview.CFrame = previewCFrame

    -- Vérifier si l'emplacement est valide et mettre à jour l'apparence
    local isValid = self:CheckBuildingPlacementValidity()
    self.characterState.buildingPreview.Color = isValid and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end

-- Vérifier si l'emplacement est valide pour placer un bâtiment
function PlayerController:CheckBuildingPlacementValidity()
    if not self.characterState.isBuilding or not self.characterState.buildingPreview then return false end

    local character = self.player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return false end

    local rootPart = character.HumanoidRootPart
    local previewPosition = self.characterState.buildingPreview.Position

    -- Vérifier la distance
    local distance = (rootPart.Position - previewPosition).Magnitude
    if distance > self.interactionDistance then
        return false
    end

    -- Vérifier les collisions
    -- Dans une implémentation réelle, on vérifierait aussi les collisions avec d'autres bâtiments,
    -- les restrictions de zone de construction, etc.

    return true
end

-- Faire pivoter le prévisualisation de construction
function PlayerController:RotateBuildingPreview()
    if not self.characterState.isBuilding or not self.characterState.buildingPreview then return end

    -- Faire pivoter de 90 degrés autour de l'axe Y
    local currentCFrame = self.characterState.buildingPreview.CFrame
    local newCFrame = currentCFrame * CFrame.Angles(0, math.rad(90), 0)

    self.characterState.buildingPreview.CFrame = newCFrame
end

-- Essayer de placer un bâtiment
function PlayerController:TryPlaceBuilding()
    if not self.characterState.isBuilding or not self.characterState.buildingPreview then return end

    -- Vérifier si l'emplacement est valide
    if not self:CheckBuildingPlacementValidity() then
        -- Afficher un message d'erreur
        if self.uiController then
            self.uiController:DisplayMessage("Emplacement invalide pour la construction", "error", 2)
        end
        return
    end

    -- Obtenir les données nécessaires
    local buildingPosition = self.characterState.buildingPreview.Position
    local buildingRotation = self.characterState.buildingPreview.CFrame - self.characterState.buildingPreview.Position

    -- Envoyer l'événement de placement au serveur
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            local itemId = self.characterState.buildingPreview:GetAttribute("BuildingType")

            playerActionEvent:FireServer("place_building", itemId, buildingPosition, buildingRotation)

            -- Terminer le mode construction
            self:EndBuilding()
        end
    end
end

-- Terminer le mode construction
function PlayerController:EndBuilding()
    if not self.characterState.isBuilding then return end

    -- Nettoyer le prévisualisation
    if self.characterState.buildingPreview then
        self.characterState.buildingPreview:Destroy()
        self.characterState.buildingPreview = nil
    end

    self.characterState.isBuilding = false

    print("PlayerController: Fin de la construction")
end

-- Annuler l'action en cours
function PlayerController:CancelCurrentAction()
    if self.characterState.isBuilding then
        self:EndBuilding()
    end

    if self.characterState.isSleeping then
        self:SetSleepingState(false)
    end

    if self.uiController then
        if self.uiController.interfaces.inventoryUI and self.uiController.interfaces.inventoryUI.isOpen then
            self.uiController:ToggleInventory(false)
        end

        if self.uiController.interfaces.craftingUI and self.uiController.interfaces.craftingUI.isOpen then
            self.uiController:ToggleCrafting(false)
        end
    end

    print("PlayerController: Annulation de l'action en cours")
end

-- Sélectionner un emplacement rapide (touches 1-5)
function PlayerController:SelectQuickSlot(slotNumber)
    -- Dans une implémentation réelle, on interagirait avec l'inventaire
    -- pour équiper l'objet dans l'emplacement spécifié
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            playerActionEvent:FireServer("equip_slot", slotNumber)
        end
    end

    print("PlayerController: Sélection de l'emplacement rapide " .. slotNumber)
end

-- Essayer d'attaquer ou de récolter avec l'outil équipé
function PlayerController:TryAttackOrHarvest()
    if self.characterState.isBuilding or self.characterState.isSleeping then return end

    local character = self.player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    -- Vérifier si un outil est équipé
    if not self.characterState.equippedTool then
        print("PlayerController: Aucun outil équipé")
        return
    end

    -- Lancer un rayon à partir de la caméra
    local mouse = self.player:GetMouse()
    local camera = workspace.CurrentCamera

    local rayOrigin = camera.CFrame.Position
    local rayDirection = (mouse.Hit.Position - rayOrigin).Unit * self.interactionDistance

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    local hitPart = raycastResult and raycastResult.Instance
    local hitPosition = raycastResult and raycastResult.Position

    if hitPart then
        local model = hitPart:FindFirstAncestorOfClass("Model")

        if model then
            -- Vérifier le type de modèle
            local resourceType = model:GetAttribute("ResourceType")
            local structureId = model:GetAttribute("StructureId")

            if resourceType then
                -- Récolter une ressource avec l'outil
                self:HarvestResourceWithTool(model, resourceType)
            elseif structureId then
                -- Attaquer une structure
                self:AttackStructure(structureId, hitPart)
            else
                -- Attaquer une cible
                self:AttackTarget(hitPart)
            end
        else
            -- Attaquer dans le vide
            self:PlayAttackAnimation()
        end
    else
        -- Attaquer dans le vide
        self:PlayAttackAnimation()
    end
end

-- Récolter une ressource avec l'outil équipé
function PlayerController:HarvestResourceWithTool(resourceModel, resourceType)
    if not self.characterState.equippedTool then return end

    -- Vérifier si l'outil est approprié pour ce type de ressource
    local toolType = self.characterState.equippedTool.type
    local isAppropriate = false

    if (resourceType == "wood" and toolType == "axe") or
       ((resourceType == "stone" or resourceType:find("_ore")) and toolType == "pickaxe") then
        isAppropriate = true
    end

    -- Jouer l'animation appropriée
    if isAppropriate then
        self:PlayHarvestAnimation(resourceType)
    else
        self:PlayAttackAnimation()
    end
end

-- Attaquer une cible
function PlayerController:AttackTarget(targetPart)
    -- Dans une implémentation réelle, envoyer un événement au serveur
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            playerActionEvent:FireServer("attack", targetPart)
        end
    end

    -- Jouer l'animation d'attaque
    self:PlayAttackAnimation()
end

-- Attaquer une structure
function PlayerController:AttackStructure(structureId, hitPart)
    -- Envoyer un événement au serveur pour attaquer la structure
    local events = ReplicatedStorage:FindFirstChild("Events")
    if events then
        local attackStructureEvent = events:FindFirstChild("AttackStructure")
        if attackStructureEvent then
            attackStructureEvent:FireServer(structureId, hitPart)
        else
            warn("PlayerController: AttackStructure event non trouvé")
        end
    end

    -- Jouer l'animation d'attaque
    self:PlayAttackAnimation()
end

-- Jouer l'animation d'attaque
function PlayerController:PlayAttackAnimation()
    local character = self.player.Character
    if not character or not character:FindFirstChild("Humanoid") then return end

    local humanoid = character.Humanoid
    local animator = humanoid:FindFirstChildOfClass("Animator")

    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end

    -- Animation d'attaque par défaut
    local animationId = "rbxassetid://12345678" -- Remplacer par l'ID de l'animation d'attaque

    local animation = Instance.new("Animation")
    animation.AnimationId = animationId

    local animTrack = animator:LoadAnimation(animation)
    animTrack:Play()

    -- Auto-destruction de l'objet Animation après lecture
    animTrack.Stopped:Connect(function()
        animation:Destroy()
    end)
end

return PlayerController</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="60">
            <Properties>
              <string name="Name">UIController</string>
              <string name="Source">-- src/client/controllers/UIController.lua
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local UIController = {}
UIController.__index = UIController

function UIController.new()
    local self = setmetatable({}, UIController)
    
    -- Interfaces
    self.interfaces = {}
    
    -- Données du joueur
    self.playerData = {
        stats = {
            hunger = 100,
            thirst = 100,
            energy = 100,
            temperature = 50,
            age = 16,
        },
        inventory = {
            items = {},
            equipped = {}
        },
        recipes = {}
    }
    
    -- Références aux autres contrôleurs
    self.cameraController = nil
    
    -- États des interfaces
    self.uiStates = {
        inventoryOpen = false,
        craftingOpen = false,
        anyMenuOpen = false
    }
    
    return self
end

function UIController:Initialize(uiModules, controllers)
    -- Stocker les références aux autres contrôleurs
    self.cameraController = nil
    if controllers then
        self.cameraController = controllers.CameraController
    end
    
    -- Initialiser les interfaces utilisateur
    self.interfaces.statsUI = uiModules.StatsUI.new()
    self.interfaces.statsUI:Initialize()
    
    self.interfaces.inventoryUI = uiModules.InventoryUI.new()
    self.interfaces.inventoryUI:Initialize()
    
    self.interfaces.craftingUI = uiModules.CraftingUI.new()
    self.interfaces.craftingUI:Initialize()
    
    self.interfaces.ageUI = uiModules.AgeUI.new()
    self.interfaces.ageUI:Initialize()
    
    self.interfaces.notificationUI = uiModules.NotificationUI.new()
    self.interfaces.notificationUI:Initialize()
    
    -- Mettre à jour les interfaces avec les données initiales
    self:UpdateAllInterfaces()
    
    -- Connecter aux événements d'interface
    self:ConnectInterfaceEvents()
    
    -- Configurer les événements de serveur
    self:SetupRemoteEvents()
    
    print("UIController: Interfaces initialisées")
    
    -- Afficher un message de bienvenue
    self:DisplayMessage("Bienvenue dans The Beginning", "system", 8)
end

-- Connecter aux événements spécifiques des interfaces
function UIController:ConnectInterfaceEvents()
    -- Événements d'inventaire
    if self.interfaces.inventoryUI then
        -- Exemple: surcharger la méthode ToggleInventory pour gérer la caméra
        local originalToggleInventory = self.interfaces.inventoryUI.ToggleInventory
        self.interfaces.inventoryUI.ToggleInventory = function(this, open)
            originalToggleInventory(this, open)
            
            -- Mettre à jour l'état
            self.uiStates.inventoryOpen = this.isOpen
            self.uiStates.anyMenuOpen = self.uiStates.inventoryOpen or self.uiStates.craftingOpen
            
            -- Gérer la caméra
            if self.cameraController then
                if this.isOpen then
                    self.cameraController:EnterOrbitMode()
                else
                    -- Ne quitter le mode orbite que si aucun autre menu n'est ouvert
                    if not self.uiStates.anyMenuOpen then
                        self.cameraController:ExitOrbitMode()
                    end
                end
            end
        end
    end
    
    -- Événements de crafting
    if self.interfaces.craftingUI then
        -- Exemple: surcharger la méthode ToggleCrafting pour gérer la caméra
        local originalToggleCrafting = self.interfaces.craftingUI.ToggleCrafting
        self.interfaces.craftingUI.ToggleCrafting = function(this, open)
            originalToggleCrafting(this, open)
            
            -- Mettre à jour l'état
            self.uiStates.craftingOpen = this.isOpen
            self.uiStates.anyMenuOpen = self.uiStates.inventoryOpen or self.uiStates.craftingOpen
            
            -- Gérer la caméra
            if self.cameraController then
                if this.isOpen then
                    self.cameraController:EnterOrbitMode()
                else
                    -- Ne quitter le mode orbite que si aucun autre menu n'est ouvert
                    if not self.uiStates.anyMenuOpen then
                        self.cameraController:ExitOrbitMode()
                    end
                end
            end
        end
    end
end

-- Mettre à jour les statistiques du joueur
function UIController:UpdatePlayerStats(statsData)
    -- Mettre à jour les données locales
    for key, value in pairs(statsData) do
        self.playerData.stats[key] = value
    end
    
    -- Mettre à jour l'interface des statistiques
    if self.interfaces.statsUI then
        self.interfaces.statsUI:HandleServerUpdate(statsData)
    end
    
    -- Vérifier les conditions critiques pour les alertes
    self:CheckCriticalStats(statsData)
end

-- Vérifier les statistiques critiques
function UIController:CheckCriticalStats(statsData)
    -- Vérifier la faim
    if statsData.hunger and statsData.hunger &lt;= 15 and statsData.hunger > 0 then
        self:DisplayMessage("Vous avez très faim, trouvez de la nourriture rapidement!", "warning", 5)
    end
    
    -- Vérifier la soif
    if statsData.thirst and statsData.thirst &lt;= 10 and statsData.thirst > 0 then
        self:DisplayMessage("Vous êtes déshydraté, trouvez de l'eau rapidement!", "warning", 5)
    end
    
    -- Vérifier l'énergie
    if statsData.energy and statsData.energy &lt;= 10 and statsData.energy > 0 then
        self:DisplayMessage("Vous êtes épuisé, trouvez un lit pour vous reposer!", "warning", 5)
    end
    
    -- Vérifier la température
    if statsData.temperature and statsData.temperature &lt;= 20 then
        self:DisplayMessage("Vous avez froid, approchez-vous d'un feu!", "warning", 5)
    elseif statsData.temperature and statsData.temperature >= 80 then
        self:DisplayMessage("Vous avez trop chaud, éloignez-vous des sources de chaleur!", "warning", 5)
    end
end

-- Mettre à jour l'inventaire du joueur
function UIController:UpdateInventory(inventoryData)
    -- Mettre à jour les données locales
    self.playerData.inventory = inventoryData
    
    -- Mettre à jour l'interface d'inventaire
    if self.interfaces.inventoryUI then
        self.interfaces.inventoryUI:UpdateInventory(inventoryData)
    end
    
    -- Mettre à jour l'interface de craft pour refléter les matériaux disponibles
    if self.interfaces.craftingUI then
        self.interfaces.craftingUI:UpdateInventory(inventoryData)
    end
end

-- Mettre à jour les recettes débloquées
function UIController:UpdateRecipes(recipesData)
    -- Mettre à jour les données locales
    self.playerData.recipes = recipesData
    
    -- Mettre à jour l'interface de craft
    if self.interfaces.craftingUI then
        self.interfaces.craftingUI:UpdateRecipes(recipesData)
    end
    
    -- Si c'est la première fois qu'on débloque une recette de niveau bronze/fer/or, afficher une notification
    if recipesData.techLevels then
        if recipesData.techLevels.bronze and (not self.playerData.recipes.techLevels or not self.playerData.recipes.techLevels.bronze) then
            self:DisplayMessage("Vous avez débloqué l'âge du bronze!", "success", 8)
        end
        if recipesData.techLevels.iron and (not self.playerData.recipes.techLevels or not self.playerData.recipes.techLevels.iron) then
            self:DisplayMessage("Vous avez débloqué l'âge du fer!", "success", 8)
        end
        if recipesData.techLevels.gold and (not self.playerData.recipes.techLevels or not self.playerData.recipes.techLevels.gold) then
            self:DisplayMessage("Vous avez débloqué l'âge de l'or!", "success", 8)
        end
    end
end

-- Mettre à jour l'âge du joueur
function UIController:UpdateAge(age)
    -- Mettre à jour les données locales
    self.playerData.stats.age = age
    
    -- Mettre à jour l'interface des statistiques et de l'âge
    if self.interfaces.statsUI then
        self.interfaces.statsUI:UpdateStat("age", age)
    end
    
    if self.interfaces.ageUI then
        self.interfaces.ageUI:UpdateAge(age)
        
        -- Afficher une notification d'anniversaire à chaque année entière
        if math.floor(age) > math.floor(self.playerData.stats.age or 0) then
            self.interfaces.ageUI:ShowAgeNotification(math.floor(age))
        end
    end
end

-- Mettre à jour l'heure du jeu
function UIController:UpdateGameTime(timeInfo)
    if self.interfaces.ageUI then
        self.interfaces.ageUI:UpdateTime(timeInfo)
    end
    
    -- Afficher des messages pour les événements spéciaux
    if timeInfo.isDawnOrDusk and not timeInfo.isDay and not self.lastTimeDawnOrDusk then
        -- L'aube commence
        self:DisplayMessage("Le soleil se lève", "info", 3)
    elseif timeInfo.isDay and not timeInfo.isDawnOrDusk and not self.lastTimeIsDay then
        -- Le jour est pleinement là
        self:DisplayMessage("C'est maintenant le jour", "info", 3)
    elseif timeInfo.isDawnOrDusk and not timeInfo.isDay and self.lastTimeIsDay then
        -- Le crépuscule commence
        self:DisplayMessage("Le soleil se couche", "info", 3)
    elseif not timeInfo.isDay and not timeInfo.isDawnOrDusk and self.lastTimeDawnOrDusk then
        -- La nuit est complètement tombée
        self:DisplayMessage("La nuit est tombée, faites attention aux dangers", "warning", 5)
    end
    
    -- Mémoriser l'état actuel pour le prochain cycle
    self.lastTimeIsDay = timeInfo.isDay
    self.lastTimeDawnOrDusk = timeInfo.isDawnOrDusk
end

-- Mettre à jour toutes les interfaces
function UIController:UpdateAllInterfaces()
    -- Mettre à jour les statistiques
    if self.interfaces.statsUI then
        self.interfaces.statsUI:HandleServerUpdate(self.playerData.stats)
    end
    
    -- Mettre à jour l'inventaire
    if self.interfaces.inventoryUI then
        self.interfaces.inventoryUI:UpdateInventory(self.playerData.inventory)
    end
    
    -- Mettre à jour les recettes
    if self.interfaces.craftingUI then
        self.interfaces.craftingUI:UpdateRecipes(self.playerData.recipes)
    end
    
    -- Mettre à jour l'âge
    if self.interfaces.ageUI then
        self.interfaces.ageUI:UpdateAge(self.playerData.stats.age)
    end
end

-- Afficher un message à l'écran
function UIController:DisplayMessage(message, messageType, duration)
    if self.interfaces.notificationUI then
        self.interfaces.notificationUI:AddNotification(message, messageType, duration)
    else
        -- Fallback si l'interface de notification n'est pas disponible
        print("Message " .. (messageType or "info") .. ": " .. message)
    end
end

-- Afficher une alerte de mort
function UIController:DisplayDeathMessage(causeOfDeath)
    local deathMessages = {
        ["age"] = "Vous êtes mort de vieillesse à l'âge de " .. math.floor(self.playerData.stats.age or 0) .. " ans.",
        ["hunger"] = "Vous êtes mort de faim.",
        ["thirst"] = "Vous êtes mort de soif.",
        ["cold"] = "Vous êtes mort de froid.",
        ["heat"] = "Vous êtes mort de chaleur.",
        ["killed"] = "Vous avez été tué."
    }
    
    local message = deathMessages[causeOfDeath] or "Vous êtes mort."
    
    -- Afficher un écran de mort avec le message
    self:DisplayMessage(message, "error", 10)
    
    -- Cacher les interfaces de jeu pendant que le joueur est mort
    self:ToggleGameUI(false)
    
    -- Afficher une interface de mort
    -- Dans une implémentation complète, on créerait une interface spécifique pour la mort
    -- Pour l'instant, nous utilisons une simple notification
end

-- Afficher un message de naissance
function UIController:DisplayBirthMessage(parentName)
    local message = "Vous êtes né en tant qu'enfant de " .. (parentName or "un autre joueur") .. "."
    
    -- Afficher un écran de naissance avec le message
    self:DisplayMessage(message, "success", 10)
    
    -- Réafficher les interfaces de jeu
    self:ToggleGameUI(true)
end

-- Activer/désactiver les interfaces de jeu
function UIController:ToggleGameUI(visible)
    -- Interfaces à cacher/montrer lors de la mort/naissance
    if self.interfaces.statsUI then
        self.interfaces.statsUI.gui.Enabled = visible
    end
    
    if self.interfaces.ageUI then
        self.interfaces.ageUI.gui.Enabled = visible
    end
    
    -- L'inventaire et le crafting sont toujours désactivés par défaut
    -- Ils sont activés/désactivés par les touches de raccourci
end

-- Ouvrir/fermer l'inventaire
function UIController:ToggleInventory(open)
    if open == nil then
        -- Si aucune valeur n'est fournie, basculer l'état actuel
        open = not (self.interfaces.inventoryUI and self.interfaces.inventoryUI.isOpen)
    end
    
    if self.interfaces.inventoryUI then
        self.interfaces.inventoryUI:ToggleInventory(open)
    end
    
    -- Si l'inventaire est ouvert, fermer l'interface de craft
    if open and self.interfaces.craftingUI and self.interfaces.craftingUI.isOpen then
        self.interfaces.craftingUI:ToggleCrafting(false)
    end
end

-- Ouvrir/fermer l'interface de craft
function UIController:ToggleCrafting(open)
    if open == nil then
        -- Si aucune valeur n'est fournie, basculer l'état actuel
        open = not (self.interfaces.craftingUI and self.interfaces.craftingUI.isOpen)
    end
    
    if self.interfaces.craftingUI then
        self.interfaces.craftingUI:ToggleCrafting(open)
    end
    
    -- Si l'interface de craft est ouverte, fermer l'inventaire
    if open and self.interfaces.inventoryUI and self.interfaces.inventoryUI.isOpen then
        self.interfaces.inventoryUI:ToggleInventory(false)
    end
end

-- Gérer les événements de récolte de ressources
function UIController:HandleResourceHarvest(resourceType, amount)
    -- Afficher une notification
    local resourceNames = {
        ["wood"] = "bois",
        ["stone"] = "pierre",
        ["fiber"] = "fibre",
        ["clay"] = "argile",
        ["berries"] = "baies",
        ["copper_ore"] = "minerai de cuivre",
        ["tin_ore"] = "minerai d'étain",
        ["iron_ore"] = "minerai de fer",
        ["gold_ore"] = "minerai d'or"
    }
    
    local resourceName = resourceNames[resourceType] or resourceType
    self:DisplayMessage("Vous avez récolté " .. amount .. " " .. resourceName, "success", 3)
end

-- Gérer les événements de craft
function UIController:HandleCraftComplete(recipeId, success, message)
    if success then
        local recipe = require(ReplicatedStorage.Shared.constants.CraftingRecipes)[recipeId]
        if recipe then
            self:DisplayMessage("Vous avez fabriqué " .. recipe.name, "success", 3)
        else
            self:DisplayMessage("Fabrication réussie!", "success", 3)
        end
    else
        self:DisplayMessage(message or "Échec de la fabrication", "error", 3)
    end
end

-- Gérer les événements de construction
function UIController:HandleBuildingPlacement(buildingType, success, message)
    if success then
        local itemTypes = require(ReplicatedStorage.Shared.constants.ItemTypes)
        local buildingName = itemTypes[buildingType] and itemTypes[buildingType].name or buildingType
        self:DisplayMessage("Vous avez construit un(e) " .. buildingName, "success", 3)
    else
        self:DisplayMessage(message or "Impossible de construire ici", "error", 3)
    end
end

-- Gérer les événements RemoteEvent du serveur
function UIController:SetupRemoteEvents()
    -- Dans une implémentation réelle, connecter aux RemoteEvents
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if events then
        -- Connecter pour les statistiques
        local updateStatsEvent = events:FindFirstChild("UpdateStats")
        if updateStatsEvent then
            updateStatsEvent.OnClientEvent:Connect(function(statsData)
                self:UpdatePlayerStats(statsData)
            end)
        end
        
        -- Connecter pour l'inventaire
        local updateInventoryEvent = events:FindFirstChild("UpdateInventory")
        if updateInventoryEvent then
            updateInventoryEvent.OnClientEvent:Connect(function(inventoryData)
                self:UpdateInventory(inventoryData)
            end)
        end
        
                -- Connecter pour les recettes
        local updateRecipesEvent = events:FindFirstChild("UpdateRecipes")
        if updateRecipesEvent then
            updateRecipesEvent.OnClientEvent:Connect(function(recipesData)
                self:UpdateRecipes(recipesData)
            end)
        end
        
        -- Connecter pour l'heure du jeu
        local timeUpdateEvent = events:FindFirstChild("TimeUpdate")
        if timeUpdateEvent then
            timeUpdateEvent.OnClientEvent:Connect(function(timeInfo)
                self:UpdateGameTime(timeInfo)
            end)
        end
        
        -- Connecter pour les événements de mort
        local deathEvent = events:FindFirstChild("Death")
        if deathEvent then
            deathEvent.OnClientEvent:Connect(function(causeOfDeath)
                self:DisplayDeathMessage(causeOfDeath)
            end)
        end
        
        -- Connecter pour les événements de naissance
        local birthEvent = events:FindFirstChild("Birth")
        if birthEvent then
            birthEvent.OnClientEvent:Connect(function(parentName)
                self:DisplayBirthMessage(parentName)
            end)
        end
        
        -- Connecter pour les événements de récolte
        local resourceHarvestEvent = events:FindFirstChild("ResourceHarvest")
        if resourceHarvestEvent then
            resourceHarvestEvent.OnClientEvent:Connect(function(resourceType, amount)
                self:HandleResourceHarvest(resourceType, amount)
            end)
        end
        
        -- Connecter pour les événements de craft
        local craftCompleteEvent = events:FindFirstChild("CraftComplete")
        if craftCompleteEvent then
            craftCompleteEvent.OnClientEvent:Connect(function(recipeId, success, message)
                self:HandleCraftComplete(recipeId, success, message)
            end)
        end
        
        -- Connecter pour les événements de construction
        local buildingPlacementEvent = events:FindFirstChild("BuildingPlacement")
        if buildingPlacementEvent then
            buildingPlacementEvent.OnClientEvent:Connect(function(buildingType, success, message)
                self:HandleBuildingPlacement(buildingType, success, message)
            end)
        end
    else
        warn("UIController: Attention - Dossier Events non trouvé dans ReplicatedStorage")
    end
end

return UIController</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="61">
          <Properties>
            <string name="Name">ui</string>
          </Properties>
          <Item class="ModuleScript" referent="62">
            <Properties>
              <string name="Name">AgeUI</string>
              <string name="Source">-- src/client/ui/AgeUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local AgeUI = {}
AgeUI.__index = AgeUI

function AgeUI.new()
    local self = setmetatable({}, AgeUI)

    -- Référence au joueur local
    self.player = Players.LocalPlayer

    -- Âge actuel
    self.age = 16

    -- Interface ScreenGui
    self.gui = nil

    return self
end

function AgeUI:Initialize()
    -- Créer l'interface ScreenGui
    self.gui = Instance.new("ScreenGui")
    self.gui.Name = "AgeUI"
    self.gui.ResetOnSpawn = false

    -- Cadre pour l'affichage de l'âge
    local ageFrame = Instance.new("Frame")
    ageFrame.Name = "AgeFrame"
    ageFrame.Size = UDim2.new(0, 160, 0, 35)
    ageFrame.Position = UDim2.new(1, -170, 0, 10)
    ageFrame.BackgroundTransparency = 0.5
    ageFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    ageFrame.BorderSizePixel = 0
    ageFrame.Parent = self.gui

    -- Arrondir les coins
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = ageFrame

    -- Icône pour représenter l'âge (une horloge ou un sablier)
    local ageIcon = Instance.new("ImageLabel")
    ageIcon.Name = "AgeIcon"
    ageIcon.Size = UDim2.new(0, 25, 0, 25)
    ageIcon.Position = UDim2.new(0, 5, 0.5, -12.5)
    ageIcon.BackgroundTransparency = 1
    ageIcon.Image = "rbxassetid://12345710" -- Remplacer par un ID réel
    ageIcon.Parent = ageFrame

    -- Étiquette "Âge:"
    local ageLabel = Instance.new("TextLabel")
    ageLabel.Name = "AgeLabel"
    ageLabel.Size = UDim2.new(0, 40, 0, 25)
    ageLabel.Position = UDim2.new(0, 35, 0.5, -12.5)
    ageLabel.BackgroundTransparency = 1
    ageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ageLabel.Text = "Âge:"
    ageLabel.TextSize = 16
    ageLabel.Font = Enum.Font.SourceSansBold
    ageLabel.TextXAlignment = Enum.TextXAlignment.Left
    ageLabel.Parent = ageFrame

    -- Valeur de l'âge
    local ageValue = Instance.new("TextLabel")
    ageValue.Name = "AgeValue"
    ageValue.Size = UDim2.new(0, 70, 0, 25)
    ageValue.Position = UDim2.new(0, 80, 0.5, -12.5)
    ageValue.BackgroundTransparency = 1
    ageValue.TextColor3 = Color3.fromRGB(255, 255, 255)
    ageValue.Text = "16 ans"
    ageValue.TextSize = 16
    ageValue.Font = Enum.Font.SourceSans
    ageValue.TextXAlignment = Enum.TextXAlignment.Left
    ageValue.Parent = ageFrame

    -- Date et heure en jeu
    local dateTimeFrame = Instance.new("Frame")
    dateTimeFrame.Name = "DateTimeFrame"
    dateTimeFrame.Size = UDim2.new(0, 160, 0, 35)
    dateTimeFrame.Position = UDim2.new(1, -170, 0, 50)
    dateTimeFrame.BackgroundTransparency = 0.5
    dateTimeFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    dateTimeFrame.BorderSizePixel = 0
    dateTimeFrame.Parent = self.gui

    -- Arrondir les coins
    local dateTimeCorner = Instance.new("UICorner")
    dateTimeCorner.CornerRadius = UDim.new(0, 8)
    dateTimeCorner.Parent = dateTimeFrame

    -- Icône pour l'horloge
    local clockIcon = Instance.new("ImageLabel")
    clockIcon.Name = "ClockIcon"
    clockIcon.Size = UDim2.new(0, 25, 0, 25)
    clockIcon.Position = UDim2.new(0, 5, 0.5, -12.5)
    clockIcon.BackgroundTransparency = 1
    clockIcon.Image = "rbxassetid://12345711" -- Remplacer par un ID réel
    clockIcon.Parent = dateTimeFrame

    -- Heure en jeu
    local timeLabel = Instance.new("TextLabel")
    timeLabel.Name = "TimeLabel"
    timeLabel.Size = UDim2.new(0, 70, 0, 25)
    timeLabel.Position = UDim2.new(0, 35, 0, 0)
    timeLabel.BackgroundTransparency = 1
    timeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    timeLabel.Text = "12:00"
    timeLabel.TextSize = 14
    timeLabel.Font = Enum.Font.SourceSans
    timeLabel.TextXAlignment = Enum.TextXAlignment.Left
    timeLabel.Parent = dateTimeFrame

    -- Date en jeu
    local dateLabel = Instance.new("TextLabel")
    dateLabel.Name = "DateLabel"
    dateLabel.Size = UDim2.new(0, 70, 0, 25)
    dateLabel.Position = UDim2.new(0, 35, 0, 15)
    dateLabel.BackgroundTransparency = 1
    dateLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    dateLabel.Text = "Jour 1, An 1"
    dateLabel.TextSize = 12
    dateLabel.Font = Enum.Font.SourceSans
    dateLabel.TextXAlignment = Enum.TextXAlignment.Left
    dateLabel.Parent = dateTimeFrame

    -- Stocker les références importantes
    self.ageValue = ageValue
    self.timeLabel = timeLabel
    self.dateLabel = dateLabel

    -- Ajouter l'interface au joueur
    self.gui.Parent = self.player:WaitForChild("PlayerGui")

    -- Mettre à jour l'interface avec les valeurs initiales
    self:UpdateAge(self.age)

    -- Se connecter aux événements de mise à jour du temps
    self:ConnectToTimeEvents()

    return self
end

-- Mettre à jour l'affichage de l'âge
function AgeUI:UpdateAge(age)
    self.age = age

    if self.ageValue then
        self.ageValue.Text = tostring(math.floor(age)) .. " ans"

        -- Changer la couleur selon l'âge
        if age >= 50 then
            -- Rouge pour les âges élevés (proche de la mort naturelle)
            self.ageValue.TextColor3 = Color3.fromRGB(255, 100, 100)
        elseif age >= 30 then
            -- Orange pour l'âge adulte avancé
            self.ageValue.TextColor3 = Color3.fromRGB(255, 180, 100)
        elseif age >= 18 then
            -- Blanc pour l'âge adulte
            self.ageValue.TextColor3 = Color3.fromRGB(255, 255, 255)
        else
            -- Vert pour l'enfance
            self.ageValue.TextColor3 = Color3.fromRGB(100, 255, 100)
        end
    end
end

-- Mettre à jour l'affichage de l'heure
function AgeUI:UpdateTime(timeInfo)
    if not timeInfo then return end

    if self.timeLabel then
        self.timeLabel.Text = timeInfo.timeString or "00:00"
    end

    if self.dateLabel then
        self.dateLabel.Text = "Jour " .. (timeInfo.gameDay or 1) .. ", An " .. (timeInfo.gameYear or 1)
    end

    -- Mettre à jour l'apparence en fonction du moment de la journée
    if timeInfo.isDay and not timeInfo.isDawnOrDusk then
        -- Jour
        self.timeLabel.TextColor3 = Color3.fromRGB(255, 255, 150)
    elseif timeInfo.isDawnOrDusk then
        -- Aube ou crépuscule
        self.timeLabel.TextColor3 = Color3.fromRGB(255, 180, 100)
    else
        -- Nuit
        self.timeLabel.TextColor3 = Color3.fromRGB(150, 150, 255)
    end
end

-- Se connecter aux événements de mise à jour du temps
function AgeUI:ConnectToTimeEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")

    if events then
        local timeUpdateEvent = events:FindFirstChild("TimeUpdate")
        if timeUpdateEvent then
            timeUpdateEvent.OnClientEvent:Connect(function(timeInfo)
                self:UpdateTime(timeInfo)
            end)
        else
            warn("TimeUpdate event not found in ReplicatedStorage")
        end
    else
        warn("Events folder not found in ReplicatedStorage")
    end
end

-- Afficher une notification de mise à jour d'âge (lors d'un anniversaire)
function AgeUI:ShowAgeNotification(newAge)
    -- Créer une notification qui disparaît automatiquement
    local notification = Instance.new("Frame")
    notification.Name = "AgeNotification"
    notification.Size = UDim2.new(0, 200, 0, 50)
    notification.Position = UDim2.new(0.5, -100, 0.3, 0)
    notification.BackgroundTransparency = 0.3
    notification.BackgroundColor3 = Color3.fromRGB(40, 40, 100)
    notification.BorderSizePixel = 0
    notification.Parent = self.gui

    -- Arrondir les coins
    local notifCorner = Instance.new("UICorner")
    notifCorner.CornerRadius = UDim.new(0, 10)
    notifCorner.Parent = notification

    -- Texte de la notification
    local notifText = Instance.new("TextLabel")
    notifText.Name = "NotifText"
    notifText.Size = UDim2.new(1, 0, 1, 0)
    notifText.BackgroundTransparency = 1
    notifText.TextColor3 = Color3.fromRGB(255, 255, 255)
    notifText.Text = "Joyeux anniversaire!\nVous avez maintenant " .. newAge .. " ans!"
    notifText.TextSize = 16
    notifText.Font = Enum.Font.SourceSansBold
    notifText.Parent = notification

    -- Animation d'apparition
    notification.Position = UDim2.new(0.5, -100, 0, -50)
    notification:TweenPosition(UDim2.new(0.5, -100, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, 0.5, true)

    -- Auto-destruction après 5 secondes
    delay(5, function()
        notification:TweenPosition(UDim2.new(0.5, -100, 0, -50), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.5, true, function()
            notification:Destroy()
        end)
    end)
end

return AgeUI</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="63">
            <Properties>
              <string name="Name">CombatUI</string>
              <string name="Source">-- src/client/ui/CombatUI.lua
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local CombatUI = {}
CombatUI.__index = CombatUI

function CombatUI.new()
    local self = setmetatable({}, CombatUI)
    
    -- Données de combat
    self.combatData = {
        currentHealth = 100,
        maxHealth = 100,
        armor = 0,
        isInCombat = false,
        attackCooldown = 0,
        isBlocking = false,
        comboCount = 0,
        statusEffects = {}
    }
    
    -- Références UI
    self.screenGui = nil
    self.healthBar = nil
    self.armorBar = nil
    self.cooldownIndicator = nil
    self.comboIndicator = nil
    self.statusEffectsContainer = nil
    
    -- RemoteEvents
    self.remoteEvents = {}
    
    return self
end

-- Créer l'interface utilisateur
function CombatUI:CreateUI()
    -- ScreenGui principal
    self.screenGui = Instance.new("ScreenGui")
    self.screenGui.Name = "CombatUI"
    self.screenGui.ResetOnSpawn = false
    self.screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Frame principale
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 300, 0, 150)
    mainFrame.Position = UDim2.new(0, 10, 1, -160)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BackgroundTransparency = 0.3
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = self.screenGui
    
    -- Coins arrondis
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = mainFrame
    
    -- Barre de santé
    self:CreateHealthBar(mainFrame)
    
    -- Barre d'armure
    self:CreateArmorBar(mainFrame)
    
    -- Indicateur de cooldown
    self:CreateCooldownIndicator(mainFrame)
    
    -- Indicateur de combo
    self:CreateComboIndicator(mainFrame)
    
    -- Container d'effets de statut
    self:CreateStatusEffectsContainer(mainFrame)
    
    -- Indicateur de blocage
    self:CreateBlockingIndicator(mainFrame)
    
    self.screenGui.Parent = playerGui
end

-- Créer la barre de santé
function CombatUI:CreateHealthBar(parent)
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Name = "HealthLabel"
    healthLabel.Size = UDim2.new(1, -20, 0, 20)
    healthLabel.Position = UDim2.new(0, 10, 0, 10)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "Santé"
    healthLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    healthLabel.TextSize = 14
    healthLabel.Font = Enum.Font.SourceSansBold
    healthLabel.TextXAlignment = Enum.TextXAlignment.Left
    healthLabel.Parent = parent
    
    local healthBarBg = Instance.new("Frame")
    healthBarBg.Name = "HealthBarBackground"
    healthBarBg.Size = UDim2.new(1, -20, 0, 20)
    healthBarBg.Position = UDim2.new(0, 10, 0, 35)
    healthBarBg.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    healthBarBg.BorderSizePixel = 0
    healthBarBg.Parent = parent
    
    local healthBarCorner = Instance.new("UICorner")
    healthBarCorner.CornerRadius = UDim.new(0, 4)
    healthBarCorner.Parent = healthBarBg
    
    self.healthBar = Instance.new("Frame")
    self.healthBar.Name = "HealthBar"
    self.healthBar.Size = UDim2.new(1, 0, 1, 0)
    self.healthBar.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    self.healthBar.BorderSizePixel = 0
    self.healthBar.Parent = healthBarBg
    
    local healthBarFillCorner = Instance.new("UICorner")
    healthBarFillCorner.CornerRadius = UDim.new(0, 4)
    healthBarFillCorner.Parent = self.healthBar
    
    local healthText = Instance.new("TextLabel")
    healthText.Name = "HealthText"
    healthText.Size = UDim2.new(1, 0, 1, 0)
    healthText.BackgroundTransparency = 1
    healthText.Text = "100 / 100"
    healthText.TextColor3 = Color3.fromRGB(255, 255, 255)
    healthText.TextSize = 14
    healthText.Font = Enum.Font.SourceSansBold
    healthText.Parent = healthBarBg
    
    self.healthText = healthText
end

-- Créer la barre d'armure
function CombatUI:CreateArmorBar(parent)
    local armorLabel = Instance.new("TextLabel")
    armorLabel.Name = "ArmorLabel"
    armorLabel.Size = UDim2.new(1, -20, 0, 20)
    armorLabel.Position = UDim2.new(0, 10, 0, 60)
    armorLabel.BackgroundTransparency = 1
    armorLabel.Text = "Armure"
    armorLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    armorLabel.TextSize = 14
    armorLabel.Font = Enum.Font.SourceSansBold
    armorLabel.TextXAlignment = Enum.TextXAlignment.Left
    armorLabel.Parent = parent
    
    local armorBarBg = Instance.new("Frame")
    armorBarBg.Name = "ArmorBarBackground"
    armorBarBg.Size = UDim2.new(1, -20, 0, 20)
    armorBarBg.Position = UDim2.new(0, 10, 0, 85)
    armorBarBg.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    armorBarBg.BorderSizePixel = 0
    armorBarBg.Parent = parent
    
    local armorBarCorner = Instance.new("UICorner")
    armorBarCorner.CornerRadius = UDim.new(0, 4)
    armorBarCorner.Parent = armorBarBg
    
    self.armorBar = Instance.new("Frame")
    self.armorBar.Name = "ArmorBar"
    self.armorBar.Size = UDim2.new(0, 0, 1, 0)
    self.armorBar.BackgroundColor3 = Color3.fromRGB(158, 158, 158)
    self.armorBar.BorderSizePixel = 0
    self.armorBar.Parent = armorBarBg
    
    local armorBarFillCorner = Instance.new("UICorner")
    armorBarFillCorner.CornerRadius = UDim.new(0, 4)
    armorBarFillCorner.Parent = self.armorBar
    
    local armorText = Instance.new("TextLabel")
    armorText.Name = "ArmorText"
    armorText.Size = UDim2.new(1, 0, 1, 0)
    armorText.BackgroundTransparency = 1
    armorText.Text = "0"
    armorText.TextColor3 = Color3.fromRGB(255, 255, 255)
    armorText.TextSize = 14
    armorText.Font = Enum.Font.SourceSansBold
    armorText.Parent = armorBarBg
    
    self.armorText = armorText
end

-- Créer l'indicateur de cooldown
function CombatUI:CreateCooldownIndicator(parent)
    self.cooldownIndicator = Instance.new("Frame")
    self.cooldownIndicator.Name = "CooldownIndicator"
    self.cooldownIndicator.Size = UDim2.new(0, 60, 0, 60)
    self.cooldownIndicator.Position = UDim2.new(1, -70, 0, 45)
    self.cooldownIndicator.BackgroundColor3 = Color3.fromRGB(255, 87, 34)
    self.cooldownIndicator.BackgroundTransparency = 0.5
    self.cooldownIndicator.BorderSizePixel = 0
    self.cooldownIndicator.Visible = false
    self.cooldownIndicator.Parent = parent
    
    local cooldownCorner = Instance.new("UICorner")
    cooldownCorner.CornerRadius = UDim.new(1, 0)
    cooldownCorner.Parent = self.cooldownIndicator
    
    local cooldownText = Instance.new("TextLabel")
    cooldownText.Name = "CooldownText"
    cooldownText.Size = UDim2.new(1, 0, 1, 0)
    cooldownText.BackgroundTransparency = 1
    cooldownText.Text = "0.0s"
    cooldownText.TextColor3 = Color3.fromRGB(255, 255, 255)
    cooldownText.TextSize = 18
    cooldownText.Font = Enum.Font.SourceSansBold
    cooldownText.Parent = self.cooldownIndicator
    
    self.cooldownText = cooldownText
end

-- Créer l'indicateur de combo
function CombatUI:CreateComboIndicator(parent)
    self.comboIndicator = Instance.new("TextLabel")
    self.comboIndicator.Name = "ComboIndicator"
    self.comboIndicator.Size = UDim2.new(0, 100, 0, 40)
    self.comboIndicator.Position = UDim2.new(0, 10, 0, 110)
    self.comboIndicator.BackgroundColor3 = Color3.fromRGB(255, 193, 7)
    self.comboIndicator.BackgroundTransparency = 0.3
    self.comboIndicator.BorderSizePixel = 0
    self.comboIndicator.Text = "COMBO x3"
    self.comboIndicator.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.comboIndicator.TextSize = 20
    self.comboIndicator.Font = Enum.Font.SourceSansBold
    self.comboIndicator.Visible = false
    self.comboIndicator.Parent = parent
    
    local comboCorner = Instance.new("UICorner")
    comboCorner.CornerRadius = UDim.new(0, 8)
    comboCorner.Parent = self.comboIndicator
end

-- Créer le container d'effets de statut
function CombatUI:CreateStatusEffectsContainer(parent)
    self.statusEffectsContainer = Instance.new("Frame")
    self.statusEffectsContainer.Name = "StatusEffects"
    self.statusEffectsContainer.Size = UDim2.new(0, 200, 0, 40)
    self.statusEffectsContainer.Position = UDim2.new(1, -210, 0, 5)
    self.statusEffectsContainer.BackgroundTransparency = 1
    self.statusEffectsContainer.Parent = parent
    
    local layout = Instance.new("UIListLayout")
    layout.FillDirection = Enum.FillDirection.Horizontal
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
    layout.Padding = UDim.new(0, 5)
    layout.Parent = self.statusEffectsContainer
end

-- Créer l'indicateur de blocage
function CombatUI:CreateBlockingIndicator(parent)
    self.blockingIndicator = Instance.new("Frame")
    self.blockingIndicator.Name = "BlockingIndicator"
    self.blockingIndicator.Size = UDim2.new(0, 100, 0, 30)
    self.blockingIndicator.Position = UDim2.new(0.5, -50, 0, -40)
    self.blockingIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
    self.blockingIndicator.BackgroundColor3 = Color3.fromRGB(33, 150, 243)
    self.blockingIndicator.BackgroundTransparency = 0.3
    self.blockingIndicator.BorderSizePixel = 0
    self.blockingIndicator.Visible = false
    self.blockingIndicator.Parent = parent
    
    local blockCorner = Instance.new("UICorner")
    blockCorner.CornerRadius = UDim.new(0, 6)
    blockCorner.Parent = self.blockingIndicator
    
    local blockText = Instance.new("TextLabel")
    blockText.Size = UDim2.new(1, 0, 1, 0)
    blockText.BackgroundTransparency = 1
    blockText.Text = "🛡️ BLOCAGE"
    blockText.TextColor3 = Color3.fromRGB(255, 255, 255)
    blockText.TextSize = 16
    blockText.Font = Enum.Font.SourceSansBold
    blockText.Parent = self.blockingIndicator
end

-- Mettre à jour les données de combat
function CombatUI:UpdateCombatData(data)
    if not data then return end
    
    -- Mettre à jour les données locales
    if data.currentHealth then self.combatData.currentHealth = data.currentHealth end
    if data.maxHealth then self.combatData.maxHealth = data.maxHealth end
    if data.armor then self.combatData.armor = data.armor end
    if data.isInCombat ~= nil then self.combatData.isInCombat = data.isInCombat end
    
    -- Mettre à jour la barre de santé
    self:UpdateHealthBar()
    
    -- Mettre à jour la barre d'armure
    self:UpdateArmorBar()
end

-- Mettre à jour la barre de santé
function CombatUI:UpdateHealthBar()
    if not self.healthBar then return end
    
    local healthPercent = self.combatData.currentHealth / self.combatData.maxHealth
    self.healthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
    
    -- Changer la couleur selon la santé
    if healthPercent > 0.6 then
        self.healthBar.BackgroundColor3 = Color3.fromRGB(76, 175, 80) -- Vert
    elseif healthPercent > 0.3 then
        self.healthBar.BackgroundColor3 = Color3.fromRGB(255, 193, 7) -- Jaune
    else
        self.healthBar.BackgroundColor3 = Color3.fromRGB(244, 67, 54) -- Rouge
    end
    
    if self.healthText then
        self.healthText.Text = math.floor(self.combatData.currentHealth) .. " / " .. self.combatData.maxHealth
    end
end

-- Mettre à jour la barre d'armure
function CombatUI:UpdateArmorBar()
    if not self.armorBar then return end
    
    local maxArmor = 100
    local armorPercent = math.min(1, self.combatData.armor / maxArmor)
    self.armorBar.Size = UDim2.new(armorPercent, 0, 1, 0)
    
    if self.armorText then
        self.armorText.Text = math.floor(self.combatData.armor)
    end
end

-- Démarrer le service
function CombatUI:Start()
    print("CombatUI: Démarrage...")
    
    -- Créer l'UI
    self:CreateUI()
    
    -- Récupérer les RemoteEvents
    local Events = ReplicatedStorage:WaitForChild("Events")
    self.remoteEvents = {
        UpdateHealth = Events:WaitForChild("UpdateHealth"),
        AttackPlayer = Events:WaitForChild("AttackPlayer")
    }
    
    -- Écouter les mises à jour de santé
    if self.remoteEvents.UpdateHealth then
        self.remoteEvents.UpdateHealth.OnClientEvent:Connect(function(data)
            self:UpdateCombatData(data)
        end)
    end
    
    -- Gérer les contrôles de combat
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        -- Touche F pour bloquer
        if input.KeyCode == Enum.KeyCode.F then
            if self.blockingIndicator then
                self.blockingIndicator.Visible = true
            end
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        -- Touche F relâchée
        if input.KeyCode == Enum.KeyCode.F then
            if self.blockingIndicator then
                self.blockingIndicator.Visible = false
            end
        end
    end)
    
    print("CombatUI: Démarré avec succès")
    return self
end

return CombatUI</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="64">
            <Properties>
              <string name="Name">CraftingStationUI</string>
              <string name="Source">-- src/client/ui/CraftingStationUI.lua
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local CraftingStationUI = {}
CraftingStationUI.__index = CraftingStationUI

function CraftingStationUI.new()
    local self = setmetatable({}, CraftingStationUI)
    
    -- Type de station (cooking, smelting, forging)
    self.stationType = nil
    self.structureId = nil
    
    -- Références UI
    self.screenGui = nil
    self.mainFrame = nil
    self.inputSlots = {}
    self.outputSlot = nil
    self.progressBar = nil
    
    -- Données de crafting
    self.currentRecipe = nil
    self.craftingProgress = 0
    
    -- RemoteEvents
    self.remoteEvents = {}
    
    return self
end

-- Créer l'interface utilisateur
function CraftingStationUI:CreateUI(stationType, structureId)
    self.stationType = stationType
    self.structureId = structureId
    
    -- ScreenGui principal
    self.screenGui = Instance.new("ScreenGui")
    self.screenGui.Name = "CraftingStationUI"
    self.screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Fond sombre
    local background = Instance.new("Frame")
    background.Name = "Background"
    background.Size = UDim2.new(1, 0, 1, 0)
    background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    background.BackgroundTransparency = 0.5
    background.BorderSizePixel = 0
    background.Parent = self.screenGui
    
    -- Frame principale
    self.mainFrame = Instance.new("Frame")
    self.mainFrame.Name = "MainFrame"
    self.mainFrame.Size = UDim2.new(0, 500, 0, 400)
    self.mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    self.mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    self.mainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    self.mainFrame.BorderSizePixel = 2
    self.mainFrame.BorderColor3 = Color3.fromRGB(100, 100, 100)
    self.mainFrame.Parent = self.screenGui
    
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, 10)
    mainCorner.Parent = self.mainFrame
    
    -- Titre
    self:CreateTitle()
    
    -- Bouton de fermeture
    self:CreateCloseButton()
    
    -- Slots d'entrée
    self:CreateInputSlots()
    
    -- Barre de progression
    self:CreateProgressBar()
    
    -- Slot de sortie
    self:CreateOutputSlot()
    
    -- Bouton de crafting
    self:CreateCraftButton()
    
    -- Liste de recettes (selon le type)
    self:CreateRecipeList()
    
    self.screenGui.Parent = playerGui
    
    -- Animation d'ouverture
    self:AnimateOpen()
end

-- Créer le titre
function CraftingStationUI:CreateTitle()
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -60, 0, 40)
    title.Position = UDim2.new(0, 10, 0, 5)
    title.BackgroundTransparency = 1
    
    -- Titre selon le type
    local titles = {
        cooking = "🔥 Feu de camp - Cuisson",
        smelting = "⚗️ Four - Fonte",
        forging = "🔨 Enclume - Forge"
    }
    
    title.Text = titles[self.stationType] or "Station de craft"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 24
    title.Font = Enum.Font.SourceSansBold
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = self.mainFrame
end

-- Créer le bouton de fermeture
function CraftingStationUI:CreateCloseButton()
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 40, 0, 40)
    closeButton.Position = UDim2.new(1, -45, 0, 5)
    closeButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
    closeButton.BorderSizePixel = 0
    closeButton.Text = "✕"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 24
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Parent = self.mainFrame
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 6)
    closeCorner.Parent = closeButton
    
    closeButton.MouseButton1Click:Connect(function()
        self:Close()
    end)
end

-- Créer les slots d'entrée
function CraftingStationUI:CreateInputSlots()
    local slotsFrame = Instance.new("Frame")
    slotsFrame.Name = "InputSlots"
    slotsFrame.Size = UDim2.new(1, -20, 0, 100)
    slotsFrame.Position = UDim2.new(0, 10, 0, 55)
    slotsFrame.BackgroundTransparency = 1
    slotsFrame.Parent = self.mainFrame
    
    local slotsLayout = Instance.new("UIListLayout")
    slotsLayout.FillDirection = Enum.FillDirection.Horizontal
    slotsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    slotsLayout.Padding = UDim.new(0, 20)
    slotsLayout.Parent = slotsFrame
    
    -- Créer 2-3 slots selon le type
    local numSlots = (self.stationType == "forging") and 3 or 2
    
    for i = 1, numSlots do
        local slot = self:CreateSlot("Input" .. i, "Ingrédient " .. i)
        slot.Parent = slotsFrame
        table.insert(self.inputSlots, slot)
    end
end

-- Créer un slot
function CraftingStationUI:CreateSlot(name, labelText)
    local slot = Instance.new("Frame")
    slot.Name = name
    slot.Size = UDim2.new(0, 80, 0, 80)
    slot.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    slot.BorderSizePixel = 2
    slot.BorderColor3 = Color3.fromRGB(100, 100, 100)
    
    local slotCorner = Instance.new("UICorner")
    slotCorner.CornerRadius = UDim.new(0, 8)
    slotCorner.Parent = slot
    
    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, 0, 0, 20)
    label.Position = UDim2.new(0, 0, 1, 5)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.TextSize = 12
    label.Font = Enum.Font.SourceSans
    label.Parent = slot
    
    local itemIcon = Instance.new("TextLabel")
    itemIcon.Name = "ItemIcon"
    itemIcon.Size = UDim2.new(1, 0, 1, 0)
    itemIcon.BackgroundTransparency = 1
    itemIcon.Text = ""
    itemIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
    itemIcon.TextSize = 36
    itemIcon.Font = Enum.Font.SourceSansBold
    itemIcon.Parent = slot
    
    return slot
end

-- Créer la barre de progression
function CraftingStationUI:CreateProgressBar()
    local progressFrame = Instance.new("Frame")
    progressFrame.Name = "ProgressFrame"
    progressFrame.Size = UDim2.new(1, -20, 0, 40)
    progressFrame.Position = UDim2.new(0, 10, 0, 170)
    progressFrame.BackgroundTransparency = 1
    progressFrame.Parent = self.mainFrame
    
    local progressLabel = Instance.new("TextLabel")
    progressLabel.Size = UDim2.new(1, 0, 0, 15)
    progressLabel.BackgroundTransparency = 1
    progressLabel.Text = "Progression"
    progressLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    progressLabel.TextSize = 12
    progressLabel.Font = Enum.Font.SourceSans
    progressLabel.Parent = progressFrame
    
    local progressBarBg = Instance.new("Frame")
    progressBarBg.Name = "ProgressBarBg"
    progressBarBg.Size = UDim2.new(1, 0, 0, 20)
    progressBarBg.Position = UDim2.new(0, 0, 0, 20)
    progressBarBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    progressBarBg.BorderSizePixel = 0
    progressBarBg.Parent = progressFrame
    
    local bgCorner = Instance.new("UICorner")
    bgCorner.CornerRadius = UDim.new(0, 4)
    bgCorner.Parent = progressBarBg
    
    self.progressBar = Instance.new("Frame")
    self.progressBar.Name = "ProgressBar"
    self.progressBar.Size = UDim2.new(0, 0, 1, 0)
    self.progressBar.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    self.progressBar.BorderSizePixel = 0
    self.progressBar.Parent = progressBarBg
    
    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 4)
    barCorner.Parent = self.progressBar
end

-- Créer le slot de sortie
function CraftingStationUI:CreateOutputSlot()
    local outputFrame = Instance.new("Frame")
    outputFrame.Name = "OutputFrame"
    outputFrame.Size = UDim2.new(0, 100, 0, 100)
    outputFrame.Position = UDim2.new(0.5, -50, 0, 230)
    outputFrame.BackgroundTransparency = 1
    outputFrame.Parent = self.mainFrame
    
    self.outputSlot = self:CreateSlot("Output", "Résultat")
    self.outputSlot.Size = UDim2.new(0, 100, 0, 100)
    self.outputSlot.Parent = outputFrame
end

-- Créer le bouton de crafting
function CraftingStationUI:CreateCraftButton()
    local craftButton = Instance.new("TextButton")
    craftButton.Name = "CraftButton"
    craftButton.Size = UDim2.new(0, 200, 0, 40)
    craftButton.Position = UDim2.new(0.5, -100, 1, -50)
    craftButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    craftButton.BorderSizePixel = 0
    craftButton.Text = "Démarrer"
    craftButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    craftButton.TextSize = 18
    craftButton.Font = Enum.Font.SourceSansBold
    craftButton.Parent = self.mainFrame
    
    local craftCorner = Instance.new("UICorner")
    craftCorner.CornerRadius = UDim.new(0, 8)
    craftCorner.Parent = craftButton
    
    craftButton.MouseButton1Click:Connect(function()
        self:StartCrafting()
    end)
    
    -- Hover effect
    craftButton.MouseEnter:Connect(function()
        craftButton.BackgroundColor3 = Color3.fromRGB(56, 142, 60)
    end)
    
    craftButton.MouseLeave:Connect(function()
        craftButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
    end)
end

-- Créer la liste de recettes
function CraftingStationUI:CreateRecipeList()
    -- TODO: Implémenter la liste des recettes disponibles selon le type de station
    -- Pour l'instant, c'est un placeholder
end

-- Animation d'ouverture
function CraftingStationUI:AnimateOpen()
    self.mainFrame.Size = UDim2.new(0, 0, 0, 0)
    
    local tween = TweenService:Create(
        self.mainFrame,
        TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        {Size = UDim2.new(0, 500, 0, 400)}
    )
    
    tween:Play()
end

-- Démarrer le crafting
function CraftingStationUI:StartCrafting()
    -- TODO: Envoyer une requête au serveur pour démarrer le crafting
    print("Démarrage du crafting...")
    
    -- Simuler la progression
    self:SimulateProgress()
end

-- Simuler la progression
function CraftingStationUI:SimulateProgress()
    local duration = 5 -- 5 secondes
    local startTime = tick()
    
    spawn(function()
        while tick() - startTime &lt; duration do
            local progress = (tick() - startTime) / duration
            self.progressBar.Size = UDim2.new(progress, 0, 1, 0)
            wait(0.1)
        end
        
        self.progressBar.Size = UDim2.new(1, 0, 1, 0)
        print("Crafting terminé!")
    end)
end

-- Fermer l'interface
function CraftingStationUI:Close()
    if self.screenGui then
        self.screenGui:Destroy()
        self.screenGui = nil
    end
end

-- Ouvrir l'interface
function CraftingStationUI:Open(stationType, structureId)
    -- Fermer l'interface existante si elle existe
    if self.screenGui then
        self:Close()
    end
    
    -- Créer une nouvelle interface
    self:CreateUI(stationType, structureId)
end

-- Démarrer le service
function CraftingStationUI:Start()
    print("CraftingStationUI: Démarrage...")
    
    -- Récupérer les RemoteEvents
    local Events = ReplicatedStorage:WaitForChild("Events")
    
    -- Créer le RemoteEvent pour ouvrir les stations si pas existant
    local openStationEvent = Events:FindFirstChild("OpenCraftingStation")
    if not openStationEvent then
        -- Le serveur devrait créer cet événement
        warn("CraftingStationUI: RemoteEvent OpenCraftingStation non trouvé")
    else
        self.remoteEvents.OpenCraftingStation = openStationEvent
        
        -- Écouter les demandes d'ouverture
        openStationEvent.OnClientEvent:Connect(function(stationType, structureId)
            self:Open(stationType, structureId)
        end)
    end
    
    print("CraftingStationUI: Démarré avec succès")
    return self
end

return CraftingStationUI</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="65">
            <Properties>
              <string name="Name">CraftingUI</string>
              <string name="Source"><![CDATA[-- src/client/ui/CraftingUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemTypes = require(Shared.constants.ItemTypes)
local CraftingRecipes = require(Shared.constants.CraftingRecipes)

local CraftingUI = {}
CraftingUI.__index = CraftingUI

function CraftingUI.new()
    local self = setmetatable({}, CraftingUI)
    
    -- Référence au joueur local
    self.player = Players.LocalPlayer
    
    -- Recettes débloquées
    self.unlockedRecipes = {}
    
    -- Recette sélectionnée
    self.selectedRecipe = nil
    
    -- Interface ScreenGui
    self.gui = nil
    self.recipeListFrames = {}
    self.isOpen = false
    
    -- Catégories de recettes
    self.categories = {
        "tools",      -- Outils
        "weapons",    -- Armes
        "clothing",   -- Vêtements
        "building",   -- Construction
        "furniture",  -- Mobilier
        "food",       -- Nourriture
        "stations"    -- Stations d'artisanat
    }
    
    -- Catégorie sélectionnée
    self.selectedCategory = "tools"
    
    -- Référence à l'inventaire (pour vérifier les ressources disponibles)
    self.inventoryData = {
        items = {}
    }
    
    return self
end

function CraftingUI:Initialize()
    -- Créer l'interface ScreenGui
    self.gui = Instance.new("ScreenGui")
    self.gui.Name = "CraftingUI"
    self.gui.ResetOnSpawn = false
    self.gui.Enabled = false
    
    -- Cadre principal pour le craft
    self.craftingFrame = Instance.new("Frame")
    self.craftingFrame.Name = "CraftingFrame"
    self.craftingFrame.Size = UDim2.new(0, 700, 0, 500)
    self.craftingFrame.Position = UDim2.new(0.5, -350, 0.5, -250)
    self.craftingFrame.BackgroundTransparency = 0.2
    self.craftingFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    self.craftingFrame.BorderSizePixel = 0
    self.craftingFrame.Parent = self.gui
    
    -- Arrondir les coins
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 10)
    uiCorner.Parent = self.craftingFrame
    
    -- Titre de l'interface
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 0, 40)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 0.5
    titleLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    titleLabel.BorderSizePixel = 0
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Text = "Artisanat"
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.Parent = self.craftingFrame
    
    -- Arrondir les coins du titre
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleLabel
    
    -- Bouton de fermeture
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundTransparency = 0.5
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Text = "X"
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Parent = titleLabel
    
    -- Arrondir les coins du bouton
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 8)
    buttonCorner.Parent = closeButton
    
    -- Onglets de catégories
    self:CreateCategoryTabs()
    
    -- Panneau de liste des recettes
    local recipeListFrame = Instance.new("ScrollingFrame")
    recipeListFrame.Name = "RecipeListFrame"
    recipeListFrame.Size = UDim2.new(0, 250, 0, 410)
    recipeListFrame.Position = UDim2.new(0, 10, 0, 80)
    recipeListFrame.BackgroundTransparency = 0.7
    recipeListFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    recipeListFrame.BorderSizePixel = 0
    recipeListFrame.ScrollBarThickness = 6
    recipeListFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Sera ajusté dynamiquement
    recipeListFrame.TopImage = "rbxassetid://7123458627"
    recipeListFrame.MidImage = "rbxassetid://7123458627"
    recipeListFrame.BottomImage = "rbxassetid://7123458627"
    recipeListFrame.Parent = self.craftingFrame
    
    -- Panneau de détail de recette
    local recipeDetailFrame = Instance.new("Frame")
    recipeDetailFrame.Name = "RecipeDetailFrame"
    recipeDetailFrame.Size = UDim2.new(0, 420, 0, 410)
    recipeDetailFrame.Position = UDim2.new(0, 270, 0, 80)
    recipeDetailFrame.BackgroundTransparency = 0.7
    recipeDetailFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    recipeDetailFrame.BorderSizePixel = 0
    recipeDetailFrame.Parent = self.craftingFrame
    
    -- Nom de la recette
    local recipeName = Instance.new("TextLabel")
    recipeName.Name = "RecipeName"
    recipeName.Size = UDim2.new(1, 0, 0, 40)
    recipeName.Position = UDim2.new(0, 0, 0, 0)
    recipeName.BackgroundTransparency = 0.7
    recipeName.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    recipeName.BorderSizePixel = 0
    recipeName.TextColor3 = Color3.fromRGB(255, 255, 255)
    recipeName.Text = "Sélectionnez une recette"
    recipeName.TextSize = 18
    recipeName.Font = Enum.Font.SourceSansBold
    recipeName.Parent = recipeDetailFrame
    
    -- Description de la recette
    local recipeDescription = Instance.new("TextLabel")
    recipeDescription.Name = "RecipeDescription"
    recipeDescription.Size = UDim2.new(1, 0, 0, 60)
    recipeDescription.Position = UDim2.new(0, 0, 0, 50)
    recipeDescription.BackgroundTransparency = 1
    recipeDescription.TextColor3 = Color3.fromRGB(220, 220, 220)
    recipeDescription.Text = ""
    recipeDescription.TextSize = 14
    recipeDescription.TextWrapped = true
    recipeDescription.TextXAlignment = Enum.TextXAlignment.Left
    recipeDescription.TextYAlignment = Enum.TextYAlignment.Top
    recipeDescription.Font = Enum.Font.SourceSans
    recipeDescription.Parent = recipeDetailFrame
    
    -- Image de l'objet résultat
    local resultImage = Instance.new("ImageLabel")
    resultImage.Name = "ResultImage"
    resultImage.Size = UDim2.new(0, 100, 0, 100)
    resultImage.Position = UDim2.new(0.5, -50, 0, 120)
    resultImage.BackgroundTransparency = 1
    resultImage.Image = ""
    resultImage.Parent = recipeDetailFrame
    
    -- Titre pour les ingrédients
    local ingredientsTitle = Instance.new("TextLabel")
    ingredientsTitle.Name = "IngredientsTitle"
    ingredientsTitle.Size = UDim2.new(1, 0, 0, 30)
    ingredientsTitle.Position = UDim2.new(0, 0, 0, 230)
    ingredientsTitle.BackgroundTransparency = 0.7
    ingredientsTitle.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    ingredientsTitle.BorderSizePixel = 0
    ingredientsTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    ingredientsTitle.Text = "Ingrédients requis:"
    ingredientsTitle.TextSize = 16
    ingredientsTitle.Font = Enum.Font.SourceSansBold
    ingredientsTitle.Parent = recipeDetailFrame
    
    -- Liste des ingrédients
    local ingredientsList = Instance.new("Frame")
    ingredientsList.Name = "IngredientsList"
    ingredientsList.Size = UDim2.new(1, 0, 0, 120)
    ingredientsList.Position = UDim2.new(0, 0, 0, 260)
    ingredientsList.BackgroundTransparency = 1
    ingredientsList.Parent = recipeDetailFrame
    
    -- Bouton de fabrication
    local craftButton = Instance.new("TextButton")
    craftButton.Name = "CraftButton"
    craftButton.Size = UDim2.new(0, 200, 0, 40)
    craftButton.Position = UDim2.new(0.5, -100, 1, -50)
    craftButton.BackgroundTransparency = 0.5
    craftButton.BackgroundColor3 = Color3.fromRGB(0, 120, 0)
    craftButton.BorderSizePixel = 0
    craftButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    craftButton.Text = "Fabriquer"
    craftButton.TextSize = 18
    craftButton.Font = Enum.Font.SourceSansBold
    craftButton.Parent = recipeDetailFrame
    
    -- Arrondir les coins du bouton
    local craftButtonCorner = Instance.new("UICorner")
    craftButtonCorner.CornerRadius = UDim.new(0, 8)
    craftButtonCorner.Parent = craftButton
    
    -- Stocker les références importantes
    self.recipeListFrame = recipeListFrame
    self.recipeDetailFrame = recipeDetailFrame
    self.recipeName = recipeName
    self.recipeDescription = recipeDescription
    self.resultImage = resultImage
    self.ingredientsList = ingredientsList
    self.craftButton = craftButton
    
    -- Ajouter l'interface au joueur
    self.gui.Parent = self.player.PlayerGui
    
    -- Connecter les événements
    closeButton.MouseButton1Click:Connect(function()
        self:ToggleCrafting(false)
    end)
    
    -- Connexion pour la touche d'ouverture de craft (C)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.C then
            self:ToggleCrafting(not self.isOpen)
        end
    end)
    
    -- Connexion pour le bouton de fabrication
    craftButton.MouseButton1Click:Connect(function()
        self:CraftSelectedRecipe()
    end)
    
    return self
end

-- Créer les onglets de catégories
function CraftingUI:CreateCategoryTabs()
    local tabsFrame = Instance.new("Frame")
    tabsFrame.Name = "TabsFrame"
    tabsFrame.Size = UDim2.new(1, 0, 0, 30)
    tabsFrame.Position = UDim2.new(0, 0, 0, 45)
    tabsFrame.BackgroundTransparency = 0.7
    tabsFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    tabsFrame.BorderSizePixel = 0
    tabsFrame.Parent = self.craftingFrame
    
    local tabWidth = 100
    local tabPadding = 2
    local startX = 10
    
    -- Créer un bouton pour chaque catégorie
    for i, category in ipairs(self.categories) do
        local tabButton = Instance.new("TextButton")
        tabButton.Name = category .. "Tab"
        tabButton.Size = UDim2.new(0, tabWidth, 0, 25)
        tabButton.Position = UDim2.new(0, startX + (i-1) * (tabWidth + tabPadding), 0, 2)
        tabButton.BackgroundTransparency = 0.5
        tabButton.BackgroundColor3 = category == self.selectedCategory and 
                                     Color3.fromRGB(60, 60, 120) or 
                                     Color3.fromRGB(60, 60, 60)
        tabButton.BorderSizePixel = 0
        tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        tabButton.Text = self:GetCategoryDisplayName(category)
        tabButton.TextSize = 14
        tabButton.Font = Enum.Font.SourceSansBold
        tabButton.Parent = tabsFrame
        
        -- Arrondir les coins du bouton
        local tabCorner = Instance.new("UICorner")
        tabCorner.CornerRadius = UDim.new(0, 5)
        tabCorner.Parent = tabButton
        
        -- Connecter l'événement de clic
        tabButton.MouseButton1Click:Connect(function()
            self:SelectCategory(category)
        end)
        
        -- Stocker la référence
        self["tab" .. category] = tabButton
    end
end

-- Obtenir le nom d'affichage d'une catégorie
function CraftingUI:GetCategoryDisplayName(category)
    local displayNames = {
        tools = "Outils",
        weapons = "Armes",
        clothing = "Vêtements",
        building = "Construction",
        furniture = "Mobilier",
        food = "Nourriture",
        stations = "Stations"
    }
    
    return displayNames[category] or category
end

-- Sélectionner une catégorie
function CraftingUI:SelectCategory(category)
    if category == self.selectedCategory then return end
    
    -- Mettre à jour l'apparence des onglets
    for _, cat in ipairs(self.categories) do
        local tabButton = self["tab" .. cat]
        if tabButton then
            tabButton.BackgroundColor3 = cat == category and 
                                        Color3.fromRGB(60, 60, 120) or 
                                        Color3.fromRGB(60, 60, 60)
        end
    end
    
    -- Mettre à jour la catégorie sélectionnée
    self.selectedCategory = category
    
    -- Mettre à jour la liste des recettes
    self:UpdateRecipeList()
end

-- Mettre à jour la liste des recettes
function CraftingUI:UpdateRecipeList()
    -- Effacer la liste existante
    self.recipeListFrame:ClearAllChildren()
    self.recipeListFrames = {}
    
    -- Récupérer les recettes dans la catégorie sélectionnée
    local categoryRecipes = self:GetRecipesByCategory(self.selectedCategory)
    
    -- Créer un élément pour chaque recette
    local yPosition = 5
    local itemHeight = 40
    local padding = 5
    
    for i, recipeData in ipairs(categoryRecipes) do
        local recipeId = recipeData.id
        local recipe = CraftingRecipes[recipeId]
        
        -- Créer un cadre pour la recette
        local recipeFrame = Instance.new("Frame")
        recipeFrame.Name = "Recipe_" .. recipeId
        recipeFrame.Size = UDim2.new(1, -10, 0, itemHeight)
        recipeFrame.Position = UDim2.new(0, 5, 0, yPosition)
        recipeFrame.BackgroundTransparency = 0.5
        recipeFrame.BackgroundColor3 = self:IsRecipeUnlocked(recipeId) and 
                                    Color3.fromRGB(50, 50, 50) or 
                                    Color3.fromRGB(80, 50, 50)
        recipeFrame.BorderSizePixel = 0
        recipeFrame.Parent = self.recipeListFrame
        
        -- Arrondir les coins
        local frameCorner = Instance.new("UICorner")
        frameCorner.CornerRadius = UDim.new(0, 5)
        frameCorner.Parent = recipeFrame
        
        -- Nom de la recette
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.Size = UDim2.new(1, -10, 1, 0)
        nameLabel.Position = UDim2.new(0, 10, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Text = recipe.name
        nameLabel.TextSize = 14
        nameLabel.Font = Enum.Font.SourceSansBold
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.Parent = recipeFrame
        
        -- Bouton pour sélectionner la recette
        local recipeButton = Instance.new("TextButton")
        recipeButton.Name = "RecipeButton"
        recipeButton.Size = UDim2.new(1, 0, 1, 0)
        recipeButton.BackgroundTransparency = 1
        recipeButton.Text = ""
        recipeButton.Parent = recipeFrame
        
        -- Connecter l'événement du bouton
        recipeButton.MouseButton1Click:Connect(function()
            self:SelectRecipe(recipeId)
        end)
        
        -- Stocker la référence
        self.recipeListFrames[recipeId] = recipeFrame
        
        -- Mettre à jour la position pour le prochain élément
        yPosition = yPosition + itemHeight + padding
    end
    
    -- Mettre à jour la taille du canvas
    self.recipeListFrame.CanvasSize = UDim2.new(0, 0, 0, yPosition)
    
    -- Sélectionner la première recette si disponible
    if #categoryRecipes > 0 then
        self:SelectRecipe(categoryRecipes[1].id)
    else
        self:ClearRecipeDetail()
    end
end

-- Obtenir les recettes par catégorie
function CraftingUI:GetRecipesByCategory(category)
    local result = {}
    
    -- Correspondance entre catégories d'interface et types d'objets
    local categoryMapping = {
        tools = {"tool"},
        weapons = {"weapon"},
        clothing = {"clothing"},
        building = {"building"},
        furniture = {"furniture"},
        food = {"food"},
        stations = {"station"}
    }
    
    local targetCategories = categoryMapping[category] or {}
    
    -- Parcourir toutes les recettes
    for recipeId, recipe in pairs(CraftingRecipes) do
        local resultItemId = recipe.result.id
        local itemType = ItemTypes[resultItemId]
        
        if itemType then
            local itemCategory = itemType.category
            
            -- Vérifier si l'objet correspond à la catégorie sélectionnée
            local matchesCategory = false
            
            for _, targetCategory in ipairs(targetCategories) do
                if itemCategory == targetCategory or 
                   (itemType.toolType and targetCategory == "tool") or
                   (itemType.equipSlot == "weapon" and targetCategory == "weapon") or
                   ((itemType.forgingStation or itemType.smeltingStation or itemType.cookingStation) and targetCategory == "station") then
                    matchesCategory = true
                    break
                end
            end
            
            if matchesCategory or category == "all" then
                table.insert(result, {
                    id = recipeId,
                    name = recipe.name,
                    techLevel = recipe.techLevel
                })
            end
        end
    end
    
    -- Trier par nom
    table.sort(result, function(a, b)
        return a.name < b.name
    end)
    
    return result
end

-- Vérifier si une recette est débloquée
function CraftingUI:IsRecipeUnlocked(recipeId)
    -- Dans l'interface, on affiche toutes les recettes, même celles non débloquées
    -- pour informer le joueur de ce qui est disponible
    if self.unlockedRecipes[recipeId] then
        return true
    end
    
    local recipe = CraftingRecipes[recipeId]
    if not recipe then return false end
    
    -- Les recettes de niveau Stone sont toujours disponibles au début
    return recipe.techLevel == "stone"
end

-- Sélectionner une recette
function CraftingUI:SelectRecipe(recipeId)
    local recipe = CraftingRecipes[recipeId]
    if not recipe then return end
    
    -- Mettre à jour la recette sélectionnée
    self.selectedRecipe = recipeId
    
    -- Mettre à jour l'apparence des éléments de la liste
    for id, frame in pairs(self.recipeListFrames) do
        frame.BackgroundColor3 = id == recipeId and 
                                Color3.fromRGB(60, 60, 120) or 
                                (self:IsRecipeUnlocked(id) and 
                                Color3.fromRGB(50, 50, 50) or 
                                Color3.fromRGB(80, 50, 50))
    end
    
    -- Mettre à jour les détails de la recette
    self:UpdateRecipeDetail(recipeId)
end

-- Mettre à jour les détails d'une recette
function CraftingUI:UpdateRecipeDetail(recipeId)
    local recipe = CraftingRecipes[recipeId]
    if not recipe then return end
    
    -- Mettre à jour le nom
    self.recipeName.Text = recipe.name
    
    -- Mettre à jour la description
    self.recipeDescription.Text = recipe.description or ""
    
    -- Mettre à jour l'image du résultat
    local resultItemId = recipe.result.id
    local itemType = ItemTypes[resultItemId]
    
    if itemType and itemType.model then
        self.resultImage.Image = itemType.model
    else
        self.resultImage.Image = ""
    end
    
    -- Effacer la liste d'ingrédients existante
    for _, child in pairs(self.ingredientsList:GetChildren()) do
        child:Destroy()
    end
    
    -- Créer la liste des ingrédients
    local yPosition = 5
    local itemHeight = 25
    local padding = 5
    
    for itemId, quantity in pairs(recipe.ingredients) do
        local ingredient = ItemTypes[itemId]
        if ingredient then
            -- Cadre pour l'ingrédient
            local ingredientFrame = Instance.new("Frame")
            ingredientFrame.Name = "Ingredient_" .. itemId
            ingredientFrame.Size = UDim2.new(1, -10, 0, itemHeight)
            ingredientFrame.Position = UDim2.new(0, 5, 0, yPosition)
            ingredientFrame.BackgroundTransparency = 0.7
            ingredientFrame.BackgroundColor3 = self:HasEnoughItems(itemId, quantity) and 
                                            Color3.fromRGB(40, 80, 40) or 
                                            Color3.fromRGB(80, 40, 40)
            ingredientFrame.BorderSizePixel = 0
            ingredientFrame.Parent = self.ingredientsList
            
            -- Arrondir les coins
            local frameCorner = Instance.new("UICorner")
            frameCorner.CornerRadius = UDim.new(0, 5)
            frameCorner.Parent = ingredientFrame
            
            -- Icône de l'ingrédient
            local icon = Instance.new("ImageLabel")
            icon.Name = "Icon"
            icon.Size = UDim2.new(0, 20, 0, 20)
            icon.Position = UDim2.new(0, 5, 0.5, -10)
            icon.BackgroundTransparency = 1
            icon.Image = ingredient.model or ""
            icon.Parent = ingredientFrame
            
            -- Nom de l'ingrédient
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Name = "NameLabel"
            nameLabel.Size = UDim2.new(0.7, -30, 1, 0)
            nameLabel.Position = UDim2.new(0, 30, 0, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            nameLabel.Text = ingredient.name
            nameLabel.TextSize = 14
            nameLabel.Font = Enum.Font.SourceSans
            nameLabel.TextXAlignment = Enum.TextXAlignment.Left
            nameLabel.Parent = ingredientFrame
            
            -- Quantité requise / disponible
            local available = self:CountItemsInInventory(itemId)
            local quantityLabel = Instance.new("TextLabel")
            quantityLabel.Name = "QuantityLabel"
            quantityLabel.Size = UDim2.new(0.3, 0, 1, 0)
            quantityLabel.Position = UDim2.new(0.7, 0, 0, 0)
            quantityLabel.BackgroundTransparency = 1
            quantityLabel.TextColor3 = available >= quantity and 
                                     Color3.fromRGB(150, 255, 150) or 
                                     Color3.fromRGB(255, 150, 150)
            quantityLabel.Text = available .. "/" .. quantity
            quantityLabel.TextSize = 14
            quantityLabel.Font = Enum.Font.SourceSans
            quantityLabel.Parent = ingredientFrame
            
            -- Mettre à jour la position pour le prochain élément
            yPosition = yPosition + itemHeight + padding
        end
    end
    
    -- Mettre à jour l'état du bouton de fabrication
    self:UpdateCraftButton()
end

-- Mettre à jour l'état du bouton de fabrication
function CraftingUI:UpdateCraftButton()
    local recipeId = self.selectedRecipe
    local recipe = CraftingRecipes[recipeId]
    
    if not recipe then
        self.craftButton.Active = false
        self.craftButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        self.craftButton.Text = "Fabriquer"
        return
    end
    
    -- Vérifier si la recette est débloquée
    local isUnlocked = self:IsRecipeUnlocked(recipeId)
    
    -- Vérifier si le joueur a tous les ingrédients nécessaires
    local hasAllIngredients = true
    
    for itemId, quantity in pairs(recipe.ingredients) do
        if not self:HasEnoughItems(itemId, quantity) then
            hasAllIngredients = false
            break
        end
    end
    
    -- Mettre à jour l'apparence et l'état du bouton
    if isUnlocked and hasAllIngredients then
        self.craftButton.BackgroundColor3 = Color3.fromRGB(0, 120, 0)
        self.craftButton.Active = true
        self.craftButton.Text = "Fabriquer"
    elseif not isUnlocked then
        self.craftButton.BackgroundColor3 = Color3.fromRGB(120, 60, 0)
        self.craftButton.Active = false
        self.craftButton.Text = "Recette verrouillée"
    else
        self.craftButton.BackgroundColor3 = Color3.fromRGB(120, 0, 0)
        self.craftButton.Active = false
        self.craftButton.Text = "Ingrédients insuffisants"
    end
end

-- Effacer les détails de la recette
function CraftingUI:ClearRecipeDetail()
    self.recipeName.Text = "Sélectionnez une recette"
    self.recipeDescription.Text = ""
    self.resultImage.Image = ""
    
    -- Effacer la liste d'ingrédients
    for _, child in pairs(self.ingredientsList:GetChildren()) do
        child:Destroy()
    end
    
    -- Désactiver le bouton de fabrication
    self.craftButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    self.craftButton.Active = false
    self.craftButton.Text = "Fabriquer"
end

-- Compter le nombre d'un item donné dans l'inventaire
function CraftingUI:CountItemsInInventory(itemId)
    local count = 0
    
    for _, item in pairs(self.inventoryData.items) do
        if item and item.id == itemId then
            count = count + (item.quantity or 1)
        end
    end
    
    return count
end

-- Vérifier si le joueur a assez d'un item donné
function CraftingUI:HasEnoughItems(itemId, quantity)
    return self:CountItemsInInventory(itemId) >= quantity
end

-- Fabriquer la recette sélectionnée
function CraftingUI:CraftSelectedRecipe()
    local recipeId = self.selectedRecipe
    
    if not recipeId or not self.craftButton.Active then return end
    
    -- Dans une implémentation réelle, envoyer une demande au serveur
    -- en utilisant un RemoteEvent
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if events then
        local playerActionEvent = events:FindFirstChild("PlayerAction")
        if playerActionEvent then
            playerActionEvent:FireServer("craft", recipeId)
            
            -- Jouer un son de fabrication
            local craftSound = Instance.new("Sound")
            craftSound.SoundId = "rbxassetid://12345"  -- À remplacer par un ID réel
            craftSound.Volume = 0.5
            craftSound.Parent = self.player.PlayerGui
            craftSound:Play()
            
            -- Auto-destruction après la lecture
            craftSound.Ended:Connect(function()
                craftSound:Destroy()
            end)
        end
    end
end

-- Mettre à jour les recettes débloquées
function CraftingUI:UpdateRecipes(recipesData)
    self.unlockedRecipes = recipesData or {}
    
    -- Si l'interface est ouverte, mettre à jour la liste des recettes
    if self.isOpen then
        self:UpdateRecipeList()
    end
end

-- Mettre à jour les données d'inventaire
function CraftingUI:UpdateInventory(inventoryData)
    self.inventoryData = inventoryData or { items = {} }
    
    -- Si l'interface est ouverte et qu'une recette est sélectionnée,
    -- mettre à jour les détails de la recette pour refléter les ressources disponibles
    if self.isOpen and self.selectedRecipe then
        self:UpdateRecipeDetail(self.selectedRecipe)
    end
end

-- Ouvrir/fermer l'interface de craft
function CraftingUI:ToggleCrafting(open)
    if open == nil then
        -- Si aucune valeur n'est fournie, basculer l'état actuel
        open = not self.isOpen
    end
    
    self.isOpen = open
    self.gui.Enabled = open
    
    -- Si on ouvre l'interface, mettre à jour la liste des recettes
    if open then
        self:UpdateRecipeList()
    end
end

return CraftingUI
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="66">
            <Properties>
              <string name="Name">InventoryUI</string>
              <string name="Source">-- src/client/ui/InventoryUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local ItemTypes = require(Shared.constants.ItemTypes)

local InventoryUI = {}
InventoryUI.__index = InventoryUI

function InventoryUI.new()
    local self = setmetatable({}, InventoryUI)
    
    -- Référence au joueur local
    self.player = Players.LocalPlayer
    
    -- Données d'inventaire
    self.inventory = {}
    self.equippedItems = {}
    self.maxSlots = 20
    
    -- Interface ScreenGui
    self.gui = nil
    self.inventoryFrame = nil
    self.slotFrames = {}
    self.isOpen = false
    
    -- Glisser-déposer
    self.draggedItem = nil
    self.draggedSlot = nil
    self.dragIcon = nil
    
    return self
end

function InventoryUI:Initialize()
    -- Créer l'interface ScreenGui
    self.gui = Instance.new("ScreenGui")
    self.gui.Name = "InventoryUI"
    self.gui.ResetOnSpawn = false
    self.gui.Enabled = false
    
    -- Cadre principal pour l'inventaire
    self.inventoryFrame = Instance.new("Frame")
    self.inventoryFrame.Name = "InventoryFrame"
    self.inventoryFrame.Size = UDim2.new(0, 500, 0, 350)
    self.inventoryFrame.Position = UDim2.new(0.5, -250, 0.5, -175)
    self.inventoryFrame.BackgroundTransparency = 0.2
    self.inventoryFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    self.inventoryFrame.BorderSizePixel = 0
    self.inventoryFrame.Parent = self.gui
    
    -- Arrondir les coins
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 10)
    uiCorner.Parent = self.inventoryFrame
    
    -- Titre de l'inventaire
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 0, 40)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 0.5
    titleLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    titleLabel.BorderSizePixel = 0
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Text = "Inventaire"
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.Parent = self.inventoryFrame
    
    -- Arrondir les coins du titre
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleLabel
    
    -- Bouton de fermeture
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundTransparency = 0.5
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Text = "X"
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Parent = titleLabel
    
    -- Arrondir les coins du bouton
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 8)
    buttonCorner.Parent = closeButton
    
    -- Grille d'emplacements d'inventaire
    local slotsFrame = Instance.new("Frame")
    slotsFrame.Name = "SlotsFrame"
    slotsFrame.Size = UDim2.new(0, 400, 0, 250)
    slotsFrame.Position = UDim2.new(0.5, -200, 0, 60)
    slotsFrame.BackgroundTransparency = 1
    slotsFrame.Parent = self.inventoryFrame
    
    -- Créer les emplacements d'inventaire
    local slotSize = 50
    local padding = 10
    local slotsPerRow = 8
    
    for i = 1, self.maxSlots do
        local row = math.floor((i - 1) / slotsPerRow)
        local col = (i - 1) % slotsPerRow
        
        local xPos = col * (slotSize + padding)
        local yPos = row * (slotSize + padding)
        
        self:CreateInventorySlot(i, slotsFrame, UDim2.new(0, xPos, 0, yPos), UDim2.new(0, slotSize, 0, slotSize))
    end
    
    -- Équipement
    local equipmentFrame = Instance.new("Frame")
    equipmentFrame.Name = "EquipmentFrame"
    equipmentFrame.Size = UDim2.new(0, 80, 0, 250)
    equipmentFrame.Position = UDim2.new(0, 10, 0, 60)
    equipmentFrame.BackgroundTransparency = 0.7
    equipmentFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    equipmentFrame.BorderSizePixel = 0
    equipmentFrame.Parent = self.inventoryFrame
    
    -- Emplacements d'équipement
    self:CreateEquipmentSlot("tool", equipmentFrame, UDim2.new(0, 15, 0, 20), "Outil")
    self:CreateEquipmentSlot("body", equipmentFrame, UDim2.new(0, 15, 0, 90), "Corps")
    self:CreateEquipmentSlot("head", equipmentFrame, UDim2.new(0, 15, 0, 160), "Tête")
    
    -- Ajouter l'interface au joueur
    self.gui.Parent = self.player.PlayerGui
    
    -- Connecter les événements
    closeButton.MouseButton1Click:Connect(function()
        self:ToggleInventory(false)
    end)
    
    -- Connexion pour le touche d'ouverture d'inventaire (E)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.E then
            self:ToggleInventory(not self.isOpen)
        end
    end)
    
    -- Connexion pour le glisser-déposer
    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if self.draggedItem and (input.UserInputType == Enum.UserInputType.MouseButton1 or
            input.UserInputType == Enum.UserInputType.Touch) then
            self:EndDrag()
        end
    end)
    
    -- Connexion pour le mouvement de la souris
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if self.draggedItem and input.UserInputType == Enum.UserInputType.MouseMovement then
            if self.dragIcon then
                self.dragIcon.Position = UDim2.new(0, input.Position.X, 0, input.Position.Y)
            end
        end
    end)
    
    return self
end

function InventoryUI:CreateInventorySlot(slotNumber, parent, position, size)
    -- Créer le cadre de l'emplacement
    local slotFrame = Instance.new("Frame")
    slotFrame.Name = "Slot" .. slotNumber
    slotFrame.Size = size
    slotFrame.Position = position
    slotFrame.BackgroundTransparency = 0.5
    slotFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    slotFrame.BorderSizePixel = 0
    slotFrame.Parent = parent
    
    -- Arrondir les coins
    local slotCorner = Instance.new("UICorner")
    slotCorner.CornerRadius = UDim.new(0, 5)
    slotCorner.Parent = slotFrame
    
    -- Image de l'objet
    local itemImage = Instance.new("ImageLabel")
    itemImage.Name = "ItemImage"
    itemImage.Size = UDim2.new(0.8, 0, 0.8, 0)
    itemImage.Position = UDim2.new(0.1, 0, 0.1, 0)
    itemImage.BackgroundTransparency = 1
    itemImage.Image = ""
    itemImage.Visible = false
    itemImage.Parent = slotFrame
    
    -- Quantité
    local quantityLabel = Instance.new("TextLabel")
    quantityLabel.Name = "QuantityLabel"
    quantityLabel.Size = UDim2.new(0, 20, 0, 20)
    quantityLabel.Position = UDim2.new(1, -20, 1, -20)
    quantityLabel.BackgroundTransparency = 0.5
    quantityLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    quantityLabel.BorderSizePixel = 0
    quantityLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    quantityLabel.Text = ""
    quantityLabel.TextSize = 14
    quantityLabel.Font = Enum.Font.SourceSansBold
    quantityLabel.Visible = false
    quantityLabel.Parent = slotFrame
    
    -- Arrondir les coins de l'étiquette
    local quantityCorner = Instance.new("UICorner")
    quantityCorner.CornerRadius = UDim.new(0, 5)
    quantityCorner.Parent = quantityLabel
    
    -- Bouton pour l'interaction
    local slotButton = Instance.new("TextButton")
    slotButton.Name = "SlotButton"
    slotButton.Size = UDim2.new(1, 0, 1, 0)
    slotButton.BackgroundTransparency = 1
    slotButton.Text = ""
    slotButton.Parent = slotFrame
    
    -- Connecter les événements du bouton
    slotButton.MouseButton1Down:Connect(function()
        self:StartDrag(slotNumber)
    end)
    
    slotButton.MouseButton1Up:Connect(function()
        if self.draggedItem then
            self:DropOnSlot(slotNumber)
        end
    end)
    
    slotButton.MouseButton2Click:Connect(function()
        self:UseItem(slotNumber)
    end)
    
    -- Info-bulle
    local tooltipFrame = Instance.new("Frame")
    tooltipFrame.Name = "TooltipFrame"
    tooltipFrame.Size = UDim2.new(0, 200, 0, 100)
    tooltipFrame.BackgroundTransparency = 0.2
    tooltipFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    tooltipFrame.BorderSizePixel = 0
    tooltipFrame.Visible = false
    tooltipFrame.ZIndex = 10
    tooltipFrame.Parent = slotFrame
    
    -- Arrondir les coins de l'info-bulle
    local tooltipCorner = Instance.new("UICorner")
    tooltipCorner.CornerRadius = UDim.new(0, 5)
    tooltipCorner.Parent = tooltipFrame
    
    -- Titre de l'info-bulle
    local tooltipTitle = Instance.new("TextLabel")
    tooltipTitle.Name = "Title"
    tooltipTitle.Size = UDim2.new(1, 0, 0, 25)
    tooltipTitle.BackgroundTransparency = 1
    tooltipTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    tooltipTitle.TextSize = 16
    tooltipTitle.Font = Enum.Font.SourceSansBold
    tooltipTitle.TextXAlignment = Enum.TextXAlignment.Left
    tooltipTitle.TextYAlignment = Enum.TextYAlignment.Center
    tooltipTitle.Text = ""
    tooltipTitle.ZIndex = 11
    tooltipTitle.Parent = tooltipFrame
    
    -- Description de l'info-bulle
    local tooltipDesc = Instance.new("TextLabel")
    tooltipDesc.Name = "Description"
    tooltipDesc.Size = UDim2.new(1, 0, 1, -25)
    tooltipDesc.Position = UDim2.new(0, 0, 0, 25)
    tooltipDesc.BackgroundTransparency = 1
    tooltipDesc.TextColor3 = Color3.fromRGB(200, 200, 200)
    tooltipDesc.TextSize = 14
    tooltipDesc.Font = Enum.Font.SourceSans
    tooltipDesc.TextXAlignment = Enum.TextXAlignment.Left
    tooltipDesc.TextYAlignment = Enum.TextYAlignment.Top
    tooltipDesc.TextWrapped = true
    tooltipDesc.Text = ""
    tooltipDesc.ZIndex = 11
    tooltipDesc.Parent = tooltipFrame
    
    -- Événements pour l'info-bulle
    slotButton.MouseEnter:Connect(function()
        self:ShowTooltip(slotNumber)
    end)
    
    slotButton.MouseLeave:Connect(function()
        self:HideTooltip(slotNumber)
    end)
    
    -- Stocker la référence
    self.slotFrames[slotNumber] = slotFrame
end

function InventoryUI:CreateEquipmentSlot(equipType, parent, position, label)
    -- Créer le cadre de l'emplacement
    local slotFrame = Instance.new("Frame")
    slotFrame.Name = equipType .. "Slot"
    slotFrame.Size = UDim2.new(0, 50, 0, 50)
    slotFrame.Position = position
    slotFrame.BackgroundTransparency = 0.5
    slotFrame.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    slotFrame.BorderSizePixel = 0
    slotFrame.Parent = parent
    
    -- Arrondir les coins
    local slotCorner = Instance.new("UICorner")
    slotCorner.CornerRadius = UDim.new(0, 5)
    slotCorner.Parent = slotFrame
    
    -- Étiquette du type d'équipement
    local typeLabel = Instance.new("TextLabel")
    typeLabel.Name = "TypeLabel"
    typeLabel.Size = UDim2.new(1, 0, 0, 20)
    typeLabel.Position = UDim2.new(0, 0, 1, 5)
    typeLabel.BackgroundTransparency = 1
    typeLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    typeLabel.Text = label
    typeLabel.TextSize = 14
    typeLabel.Font = Enum.Font.SourceSans
    typeLabel.Parent = slotFrame
    
    -- Image de l'objet
    local itemImage = Instance.new("ImageLabel")
    itemImage.Name = "ItemImage"
    itemImage.Size = UDim2.new(0.8, 0, 0.8, 0)
    itemImage.Position = UDim2.new(0.1, 0, 0.1, 0)
    itemImage.BackgroundTransparency = 1
    itemImage.Image = ""
    itemImage.Visible = false
    itemImage.Parent = slotFrame
    
    -- Bouton pour l'interaction
    local slotButton = Instance.new("TextButton")
    slotButton.Name = "SlotButton"
    slotButton.Size = UDim2.new(1, 0, 1, 0)
    slotButton.BackgroundTransparency = 1
    slotButton.Text = ""
    slotButton.Parent = slotFrame
    
    -- Connecter les événements
    slotButton.MouseButton1Up:Connect(function()
        if self.draggedItem then
            self:EquipItem(equipType)
        else
            self:UnequipItem(equipType)
        end
    end)
    
    -- Stocker la référence
    self.slotFrames["equip_" .. equipType] = slotFrame
end

function InventoryUI:UpdateSlot(slotNumber, item)
    local slotFrame = self.slotFrames[slotNumber]
    if not slotFrame then return end
    
    local itemImage = slotFrame:FindFirstChild("ItemImage")
    local quantityLabel = slotFrame:FindFirstChild("QuantityLabel")
    
    if not item then
        -- Slot vide
        if itemImage then itemImage.Visible = false end
        if quantityLabel then quantityLabel.Visible = false end
    else
        -- Mettre à jour l'image
        if itemImage then
            local itemType = ItemTypes[item.id]
            if itemType then
                itemImage.Image = itemType.model
                itemImage.Visible = true
            end
        end
        
        -- Mettre à jour la quantité
        if quantityLabel then
            if item.quantity and item.quantity > 1 then
                quantityLabel.Text = tostring(item.quantity)
                quantityLabel.Visible = true
            else
                quantityLabel.Visible = false
            end
        end
    end
end

function InventoryUI:UpdateEquipmentSlot(equipType, itemId)
    local slotFrame = self.slotFrames["equip_" .. equipType]
    if not slotFrame then return end
    
    local itemImage = slotFrame:FindFirstChild("ItemImage")
    
    if not itemId then
        -- Slot vide
        if itemImage then itemImage.Visible = false end
    else
        -- Mettre à jour l'image
        if itemImage then
            local itemType = ItemTypes[itemId]
            if itemType then
                itemImage.Image = itemType.model
                itemImage.Visible = true
            end
        end
    end
end

function InventoryUI:UpdateInventory(inventoryData)
    self.inventory = inventoryData.items or {}
    self.equippedItems = inventoryData.equipped or {}
    
    -- Mettre à jour les emplacements d'inventaire
    for i = 1, self.maxSlots do
        self:UpdateSlot(i, self.inventory[i])
    end
    
    -- Mettre à jour les emplacements d'équipement
    for equipType, itemId in pairs(self.equippedItems) do
        self:UpdateEquipmentSlot(equipType, itemId)
    end
end

function InventoryUI:ToggleInventory(open)
    self.isOpen = open
    self.gui.Enabled = open
    
    -- Informer le contrôleur du changement d'état
    -- Dans une implémentation réelle, ça serait un signal ou événement
    print("Inventaire " .. (open and "ouvert" or "fermé"))
end

function InventoryUI:ShowTooltip(slotNumber)
    local slotFrame = self.slotFrames[slotNumber]
    if not slotFrame then return end
    
    local item = self.inventory[slotNumber]
    if not item then return end
    
    local tooltipFrame = slotFrame:FindFirstChild("TooltipFrame")
    if not tooltipFrame then return end
    
    local itemType = ItemTypes[item.id]
    if not itemType then return end
    
    -- Mettre à jour le contenu
    local titleLabel = tooltipFrame:FindFirstChild("Title")
    local descLabel = tooltipFrame:FindFirstChild("Description")
    
    if titleLabel then titleLabel.Text = itemType.name end
    if descLabel then descLabel.Text = itemType.description end
    
    -- Positionner et afficher l'info-bulle
    tooltipFrame.Position = UDim2.new(1, 10, 0, 0)
    tooltipFrame.Visible = true
end

function InventoryUI:HideTooltip(slotNumber)
    local slotFrame = self.slotFrames[slotNumber]
    if not slotFrame then return end
    
    local tooltipFrame = slotFrame:FindFirstChild("TooltipFrame")
    if tooltipFrame then
        tooltipFrame.Visible = false
    end
end

function InventoryUI:StartDrag(slotNumber)
    local item = self.inventory[slotNumber]
    if not item then return end
    
    self.draggedItem = item
    self.draggedSlot = slotNumber
    
    -- Créer une icône pour le glisser-déposer
    local itemType = ItemTypes[item.id]
    if not itemType then return end
    
    -- Créer l'icône si elle n'existe pas
    if not self.dragIcon then
        self.dragIcon = Instance.new("ImageLabel")
        self.dragIcon.Size = UDim2.new(0, 40, 0, 40)
        self.dragIcon.BackgroundTransparency = 1
        self.dragIcon.Parent = self.gui
    end
    
    -- Mettre à jour l'icône
    self.dragIcon.Image = itemType.model
    self.dragIcon.Position = UDim2.new(0, UserInputService:GetMouseLocation().X, 0, UserInputService:GetMouseLocation().Y)
    self.dragIcon.Visible = true
end

function InventoryUI:EndDrag()
    -- Cacher l'icône de glisser-déposer
    if self.dragIcon then
        self.dragIcon.Visible = false
    end
    
    self.draggedItem = nil
    self.draggedSlot = nil
end

function InventoryUI:DropOnSlot(slotNumber)
    if not self.draggedItem or self.draggedSlot == slotNumber then
        self:EndDrag()
        return
    end
    
    -- Vérifier si l'emplacement cible est vide ou contient le même type d'objet
    local targetItem = self.inventory[slotNumber]
    
    if not targetItem then
        -- Emplacement vide, déplacer l'objet
        self.inventory[slotNumber] = self.draggedItem
        self.inventory[self.draggedSlot] = nil
    else
        -- Si c'est le même type d'objet et qu'il est empilable
        local itemType = ItemTypes[self.draggedItem.id]
        if targetItem.id == self.draggedItem.id and itemType and itemType.stackable then
            -- Ajouter à la pile
            targetItem.quantity = targetItem.quantity + self.draggedItem.quantity
            self.inventory[self.draggedSlot] = nil
        else
            -- Échanger les objets
            self.inventory[slotNumber] = self.draggedItem
            self.inventory[self.draggedSlot] = targetItem
        end
    end
    
    -- Mettre à jour l'affichage
    self:UpdateSlot(slotNumber, self.inventory[slotNumber])
    self:UpdateSlot(self.draggedSlot, self.inventory[self.draggedSlot])
    
    -- Dans une implémentation réelle, envoyer la modification au serveur
    -- SendInventoryUpdateToServer()
    
    self:EndDrag()
end

function InventoryUI:EquipItem(equipType)
    if not self.draggedItem then return end
    
    local itemType = ItemTypes[self.draggedItem.id]
    if not itemType or not itemType.equipable or itemType.equipSlot ~= equipType then
        -- L'objet ne peut pas être équipé dans cet emplacement
        self:EndDrag()
        return
    end
    
    -- Déséquiper l'objet actuel s'il y en a un
    if self.equippedItems[equipType] then
        self:UnequipItem(equipType)
    end
    
    -- Équiper le nouvel objet
    self.equippedItems[equipType] = self.draggedItem.id
    
    -- Retirer l'objet de l'inventaire
    self.inventory[self.draggedSlot] = nil
    
    -- Mettre à jour l'affichage
    self:UpdateEquipmentSlot(equipType, self.draggedItem.id)
    self:UpdateSlot(self.draggedSlot, nil)
    
    -- Dans une implémentation réelle, envoyer la modification au serveur
    -- SendEquipUpdateToServer()
    
    self:EndDrag()
end

function InventoryUI:UnequipItem(equipType)
    local equippedItemId = self.equippedItems[equipType]
    if not equippedItemId then return end
    
    -- Trouver un emplacement vide
    local emptySlot = nil
    for i = 1, self.maxSlots do
        if not self.inventory[i] then
            emptySlot = i
            break
        end
    end
    
    if not emptySlot then
        -- Inventaire plein, ne rien faire
        return
    end
    
    -- Créer un nouvel objet à partir de l'ID
    local newItem = {
        id = equippedItemId,
        quantity = 1,
        data = {}  -- Données supplémentaires (durabilité, etc.)
    }
    
    -- Ajouter l'objet à l'inventaire
    self.inventory[emptySlot] = newItem
    
    -- Retirer l'objet de l'équipement
    self.equippedItems[equipType] = nil
    
    -- Mettre à jour l'affichage
    self:UpdateEquipmentSlot(equipType, nil)
    self:UpdateSlot(emptySlot, newItem)
    
    -- Dans une implémentation réelle, envoyer la modification au serveur
    -- SendUnequipUpdateToServer()
end

function InventoryUI:UseItem(slotNumber)
    local item = self.inventory[slotNumber]
    if not item then return end
    
    local itemType = ItemTypes[item.id]
    if not itemType then return end
    
    -- Actions spécifiques selon le type d'objet
    if itemType.category == "food" then
        -- Consommer de la nourriture
        print("Consommation de nourriture: " .. itemType.name)
        -- Dans une implémentation réelle, envoyer au serveur
        -- SendUseItemToServer(slotNumber)
    elseif itemType.category == "drink" then
        -- Boire
        print("Consommation de boisson: " .. itemType.name)
        -- SendUseItemToServer(slotNumber)
    elseif itemType.equipable then
        -- Équiper directement l'objet
        if itemType.equipSlot then
            self:StartDrag(slotNumber)
            self:EquipItem(itemType.equipSlot)
        end
    elseif itemType.category == "building" or itemType.category == "furniture" then
        -- Entrer en mode construction
        print("Mode construction: " .. itemType.name)
        -- SendStartBuildingToServer(slotNumber)
    end
end

return InventoryUI</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="67">
            <Properties>
              <string name="Name">NotificationUI</string>
              <string name="Source">-- src/client/ui/NotificationUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local NotificationUI = {}
NotificationUI.__index = NotificationUI

function NotificationUI.new()
    local self = setmetatable({}, NotificationUI)
    
    -- Référence au joueur local
    self.player = Players.LocalPlayer
    
    -- Interface ScreenGui
    self.gui = nil
    
    -- File d'attente des notifications
    self.notificationQueue = {}
    
    -- Max notifications visibles simultanément
    self.maxVisibleNotifications = 5
    
    -- Compteur pour les IDs de notification
    self.nextNotificationId = 1
    
    -- Références aux notifications actives
    self.activeNotifications = {}
    
    -- Configuration des notifications
    self.config = {
        width = 300,
        height = 60,
        padding = 10,
        fadeTime = 0.3,
        defaultDuration = 5,
        startPosition = UDim2.new(1, 20, 0.15, 0),
        endPosition = UDim2.new(1, -330, 0.15, 0),
        defaultColor = {
            info = Color3.fromRGB(40, 80, 200),
            success = Color3.fromRGB(40, 180, 40),
            warning = Color3.fromRGB(220, 150, 40),
            error = Color3.fromRGB(220, 40, 40),
            system = Color3.fromRGB(100, 50, 150)
        }
    }
    
    return self
end

function NotificationUI:Initialize()
    -- Créer l'interface ScreenGui
    self.gui = Instance.new("ScreenGui")
    self.gui.Name = "NotificationUI"
    self.gui.ResetOnSpawn = false
    
    -- Rendre l'interface redimensionnable
    self.gui.IgnoreGuiInset = true
    
    -- Paramètre pour un bon rendu sur téléphone et autres appareils
    self.gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Conteneur pour les notifications
    self.notificationContainer = Instance.new("Frame")
    self.notificationContainer.Name = "NotificationContainer"
    self.notificationContainer.Size = UDim2.new(1, 0, 1, 0)
    self.notificationContainer.BackgroundTransparency = 1
    self.notificationContainer.Parent = self.gui
    
    -- Ajouter l'interface au joueur
    self.gui.Parent = self.player.PlayerGui
    
    -- Connecter aux événements du serveur
    self:ConnectToEvents()
    
    return self
end

function NotificationUI:ConnectToEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if events then
        local notificationEvent = events:FindFirstChild("Notification")
        if notificationEvent then
            notificationEvent.OnClientEvent:Connect(function(message, messageType, duration)
                self:AddNotification(message, messageType, duration)
            end)
        end
    end
end

function NotificationUI:AddNotification(message, messageType, duration)
    -- Valeurs par défaut
    messageType = messageType or "info"
    duration = duration or self.config.defaultDuration
    
    -- Créer l'ID pour cette notification
    local notificationId = self.nextNotificationId
    self.nextNotificationId = self.nextNotificationId + 1
    
    -- Ajouter à la file d'attente
    table.insert(self.notificationQueue, {
        id = notificationId,
        message = message,
        type = messageType,
        duration = duration
    })
    
    -- Traiter la file d'attente
    self:ProcessQueue()
end

function NotificationUI:ProcessQueue()
    -- Vérifier si on peut afficher plus de notifications
    if #self.activeNotifications >= self.maxVisibleNotifications then
        return
    end
    
    -- S'il y a des notifications en attente, les afficher
    if #self.notificationQueue > 0 then
        local notificationData = table.remove(self.notificationQueue, 1)
        self:ShowNotification(notificationData)
        
        -- Continuer à traiter la file si possible
        self:ProcessQueue()
    end
end

function NotificationUI:ShowNotification(data)
    -- Créer le cadre de notification
    local notificationFrame = Instance.new("Frame")
    notificationFrame.Name = "Notification_" .. data.id
    notificationFrame.Size = UDim2.new(0, self.config.width, 0, self.config.height)
    notificationFrame.Position = self.config.startPosition
    notificationFrame.BackgroundColor3 = self.config.defaultColor[data.type] or self.config.defaultColor.info
    notificationFrame.BackgroundTransparency = 0.2
    notificationFrame.BorderSizePixel = 0
    notificationFrame.Parent = self.notificationContainer
    
    -- Arrondir les coins
    local cornerRadius = Instance.new("UICorner")
    cornerRadius.CornerRadius = UDim.new(0, 8)
    cornerRadius.Parent = notificationFrame
    
    -- Icône pour le type de notification
    local iconImage = Instance.new("ImageLabel")
    iconImage.Name = "Icon"
    iconImage.Size = UDim2.new(0, 30, 0, 30)
    iconImage.Position = UDim2.new(0, 10, 0.5, -15)
    iconImage.BackgroundTransparency = 1
    
    -- Définir l'image en fonction du type
    if data.type == "info" then
        iconImage.Image = "rbxassetid://6031071053" -- Icône d'information
    elseif data.type == "success" then
        iconImage.Image = "rbxassetid://6031068420" -- Icône de succès
    elseif data.type == "warning" then
        iconImage.Image = "rbxassetid://6031071057" -- Icône d'avertissement
    elseif data.type == "error" then
        iconImage.Image = "rbxassetid://6031071054" -- Icône d'erreur
    elseif data.type == "system" then
        iconImage.Image = "rbxassetid://6026568240" -- Icône système
    end
    
    iconImage.Parent = notificationFrame
    
    -- Texte du message
    local messageText = Instance.new("TextLabel")
    messageText.Name = "Message"
    messageText.Size = UDim2.new(1, -60, 1, 0)
    messageText.Position = UDim2.new(0, 50, 0, 0)
    messageText.BackgroundTransparency = 1
    messageText.Font = Enum.Font.SourceSansSemibold
    messageText.TextSize = 14
    messageText.TextColor3 = Color3.fromRGB(255, 255, 255)
    messageText.TextXAlignment = Enum.TextXAlignment.Left
    messageText.TextYAlignment = Enum.TextYAlignment.Center
    messageText.TextWrapped = true
    messageText.Text = data.message
    messageText.Parent = notificationFrame
    
    -- Bouton de fermeture
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0, 5)
    closeButton.BackgroundTransparency = 1
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.TextSize = 14
    closeButton.TextColor3 = Color3.fromRGB(220, 220, 220)
    closeButton.Text = "×"
    closeButton.Parent = notificationFrame
    
    -- Connecter le bouton de fermeture
    closeButton.MouseButton1Click:Connect(function()
        self:CloseNotification(data.id)
    end)
    
    -- Indicateur de temps restant
    local timerBar = Instance.new("Frame")
    timerBar.Name = "TimerBar"
    timerBar.Size = UDim2.new(1, 0, 0, 3)
    timerBar.Position = UDim2.new(0, 0, 1, -3)
    timerBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    timerBar.BackgroundTransparency = 0.5
    timerBar.BorderSizePixel = 0
    timerBar.Parent = notificationFrame
    
    -- Animation d'entrée
    local tweenInfo = TweenInfo.new(
        self.config.fadeTime,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    
    local tweenGoal = {Position = self.config.endPosition}
    local tween = TweenService:Create(notificationFrame, tweenInfo, tweenGoal)
    tween:Play()
    
    -- Animer la barre de temps
    local timerTweenInfo = TweenInfo.new(
        data.duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out
    )
    
    local timerTweenGoal = {Size = UDim2.new(0, 0, 0, 3)}
    local timerTween = TweenService:Create(timerBar, timerTweenInfo, timerTweenGoal)
    timerTween:Play()
    
    -- Ajouter à la liste des notifications actives
    self.activeNotifications[data.id] = {
        frame = notificationFrame,
        data = data
    }
    
    -- Réorganiser les notifications
    self:RepositionNotifications()
    
    -- Programmer la fermeture automatique
    delay(data.duration, function()
        self:CloseNotification(data.id)
    end)
end

function NotificationUI:CloseNotification(id)
    local notification = self.activeNotifications[id]
    if not notification then return end
    
    -- Animation de sortie
    local tweenInfo = TweenInfo.new(
        self.config.fadeTime,
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.In
    )
    
    local tweenGoal = {Position = self.config.startPosition}
    local tween = TweenService:Create(notification.frame, tweenInfo, tweenGoal)
    
    tween.Completed:Connect(function(playbackState)
        if playbackState == Enum.PlaybackState.Completed then
            notification.frame:Destroy()
            self.activeNotifications[id] = nil
            
            -- Réorganiser les notifications restantes
            self:RepositionNotifications()
            
            -- Traiter la file d'attente si possible
            self:ProcessQueue()
        end
    end)
    
    tween:Play()
end

function NotificationUI:RepositionNotifications()
    local activeIds = {}
    
    -- Collecter les IDs actifs
    for id, _ in pairs(self.activeNotifications) do
        table.insert(activeIds, id)
    end
    
    -- Trier par ID (pour garder l'ordre chronologique)
    table.sort(activeIds)
    
    -- Repositionner chaque notification
    for index, id in ipairs(activeIds) do
        local notification = self.activeNotifications[id]
        if notification and notification.frame then
            local yOffset = (index - 1) * (self.config.height + self.config.padding)
            
            -- Animation de déplacement
            local tweenInfo = TweenInfo.new(
                0.2,
                Enum.EasingStyle.Quad,
                Enum.EasingDirection.Out
            )
            
            local newPosition = UDim2.new(
                self.config.endPosition.X.Scale,
                self.config.endPosition.X.Offset,
                self.config.endPosition.Y.Scale,
                self.config.endPosition.Y.Offset + yOffset
            )
            
            local tweenGoal = {Position = newPosition}
            local tween = TweenService:Create(notification.frame, tweenInfo, tweenGoal)
            tween:Play()
        end
    end
end

-- Afficher une notification d'information
function NotificationUI:Info(message, duration)
    self:AddNotification(message, "info", duration)
end

-- Afficher une notification de succès
function NotificationUI:Success(message, duration)
    self:AddNotification(message, "success", duration)
end

-- Afficher une notification d'avertissement
function NotificationUI:Warning(message, duration)
    self:AddNotification(message, "warning", duration)
end

-- Afficher une notification d'erreur
function NotificationUI:Error(message, duration)
    self:AddNotification(message, "error", duration)
end

-- Afficher une notification système
function NotificationUI:System(message, duration)
    self:AddNotification(message, "system", duration)
end

-- Effacer toutes les notifications
function NotificationUI:ClearAll()
    for id, _ in pairs(self.activeNotifications) do
        self:CloseNotification(id)
    end
    
    -- Vider également la file d'attente
    self.notificationQueue = {}
end

return NotificationUI</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="68">
            <Properties>
              <string name="Name">StatsUI</string>
              <string name="Source">-- src/client/ui/StatsUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local GameSettings = require(Shared.constants.GameSettings)

local StatsUI = {}
StatsUI.__index = StatsUI

function StatsUI.new()
    local self = setmetatable({}, StatsUI)
    
    -- Référence au joueur local
    self.player = Players.LocalPlayer
    
    -- Valeurs actuelles des stats
    self.stats = {
        hunger = 100,
        thirst = 100,
        energy = 100,
        temperature = 50,
        age = 16,
    }
    
    -- Interface ScreenGui
    self.gui = nil
    self.barFrames = {}
    self.barFills = {}
    self.labels = {}
    
    return self
end

function StatsUI:Initialize()
    -- Créer l'interface ScreenGui
    self.gui = Instance.new("ScreenGui")
    self.gui.Name = "StatsUI"
    self.gui.ResetOnSpawn = false
    
    -- Cadre principal pour les barres de statistiques
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "StatsFrame"
    mainFrame.Size = UDim2.new(0, 200, 0, 130)
    mainFrame.Position = UDim2.new(0, 10, 0, 10)
    mainFrame.BackgroundTransparency = 0.5
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = self.gui
    
    -- Arrondir les coins
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = mainFrame
    
    -- Créer les barres de statistiques
    self:CreateStatBar(mainFrame, "Faim", Color3.fromRGB(255, 180, 0), UDim2.new(0, 0, 0, 0), "hunger")
    self:CreateStatBar(mainFrame, "Soif", Color3.fromRGB(0, 150, 255), UDim2.new(0, 0, 0, 25), "thirst")
    self:CreateStatBar(mainFrame, "Énergie", Color3.fromRGB(100, 255, 100), UDim2.new(0, 0, 0, 50), "energy")
    self:CreateStatBar(mainFrame, "Temp.", Color3.fromRGB(255, 100, 100), UDim2.new(0, 0, 0, 75), "temperature")
    
    -- Affichage de l'âge
    local ageFrame = Instance.new("Frame")
    ageFrame.Name = "AgeFrame"
    ageFrame.Size = UDim2.new(1, -20, 0, 20)
    ageFrame.Position = UDim2.new(0, 10, 0, 100)
    ageFrame.BackgroundTransparency = 0.7
    ageFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    ageFrame.BorderSizePixel = 0
    ageFrame.Parent = mainFrame
    
    local ageLabel = Instance.new("TextLabel")
    ageLabel.Name = "AgeLabel"
    ageLabel.Size = UDim2.new(0.4, 0, 1, 0)
    ageLabel.Position = UDim2.new(0, 5, 0, 0)
    ageLabel.BackgroundTransparency = 1
    ageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ageLabel.TextXAlignment = Enum.TextXAlignment.Left
    ageLabel.Text = "Âge:"
    ageLabel.TextSize = 14
    ageLabel.Font = Enum.Font.SourceSansBold
    ageLabel.Parent = ageFrame
    
    local ageValue = Instance.new("TextLabel")
    ageValue.Name = "AgeValue"
    ageValue.Size = UDim2.new(0.6, -10, 1, 0)
    ageValue.Position = UDim2.new(0.4, 5, 0, 0)
    ageValue.BackgroundTransparency = 1
    ageValue.TextColor3 = Color3.fromRGB(255, 255, 255)
    ageValue.TextXAlignment = Enum.TextXAlignment.Left
    ageValue.Text = "16 ans"
    ageValue.TextSize = 14
    ageValue.Font = Enum.Font.SourceSans
    ageValue.Parent = ageFrame
    
    self.labels["age"] = ageValue
    
    -- Ajouter l'interface au joueur
    self.gui.Parent = self.player.PlayerGui
    
    -- Mettre à jour l'interface avec les valeurs initiales
    self:UpdateAllStats()
end

function StatsUI:CreateStatBar(parent, name, color, position, statKey)
    -- Cadre pour la barre
    local barFrame = Instance.new("Frame")
    barFrame.Name = name .. "Frame"
    barFrame.Size = UDim2.new(1, -20, 0, 20)
    barFrame.Position = position + UDim2.new(0, 10, 0, 0)
    barFrame.BackgroundTransparency = 0.7
    barFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    barFrame.BorderSizePixel = 0
    barFrame.Parent = parent
    
    -- Label pour le nom de la stat
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(0.4, 0, 1, 0)
    nameLabel.Position = UDim2.new(0, 5, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Text = name .. ":"
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = barFrame
    
    -- Remplissage de la barre (indicateur de niveau)
    local barFill = Instance.new("Frame")
    barFill.Name = "BarFill"
    barFill.Size = UDim2.new(0.6, -10, 1, -6)
    barFill.Position = UDim2.new(0.4, 5, 0, 3)
    barFill.BackgroundColor3 = color
    barFill.BorderSizePixel = 0
    barFill.Parent = barFrame
    
    -- Stocker les références pour mise à jour
    self.barFrames[statKey] = barFrame
    self.barFills[statKey] = barFill
end

function StatsUI:UpdateStat(statKey, value)
    self.stats[statKey] = value
    
    -- Mettre à jour la barre de statistique correspondante
    if self.barFills[statKey] then
        local fraction = value / (statKey == "temperature" and 100 or GameSettings.Survival["max" .. string.upper(string.sub(statKey, 1, 1)) .. string.sub(statKey, 2)])
        self.barFills[statKey].Size = UDim2.new(0.6 * fraction, -10, 1, -6)
        
        -- Changer la couleur en fonction du niveau (critique ou non)
        if statKey == "temperature" then
            -- Pour la température, la couleur change selon si trop chaud ou trop froid
            if value &lt; GameSettings.Survival.criticalColdThreshold then
                self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(100, 100, 255) -- Bleu pour froid
            elseif value > GameSettings.Survival.criticalHeatThreshold then
                self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(255, 50, 50) -- Rouge pour chaud
            else
                self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(255, 100, 100) -- Normal
            end
        else
            -- Pour les autres stats, rouge si critique
            local criticalThreshold = GameSettings.Survival["critical" .. string.upper(string.sub(statKey, 1, 1)) .. string.sub(statKey, 2) .. "Threshold"]
            
            if value &lt;= criticalThreshold then
                self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(255, 50, 50) -- Rouge pour critique
            else
                -- Couleurs normales
                if statKey == "hunger" then
                    self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(255, 180, 0)
                elseif statKey == "thirst" then
                    self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(0, 150, 255)
                elseif statKey == "energy" then
                    self.barFills[statKey].BackgroundColor3 = Color3.fromRGB(100, 255, 100)
                end
            end
        end
    end
    
    -- Mettre à jour le texte d'âge
    if statKey == "age" and self.labels["age"] then
        self.labels["age"].Text = tostring(value) .. " ans"
    end
end

function StatsUI:UpdateAllStats()
    for stat, value in pairs(self.stats) do
        self:UpdateStat(stat, value)
    end
end

-- Méthode pour recevoir les mises à jour du serveur
function StatsUI:HandleServerUpdate(statData)
    for stat, value in pairs(statData) do
        if self.stats[stat] ~= nil then
            self:UpdateStat(stat, value)
        end
    end
end

return StatsUI</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="69">
            <Properties>
              <string name="Name">TribeUI</string>
              <string name="Source">-- src/client/ui/TribeUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local TribeUI = {}
TribeUI.__index = TribeUI

-- Définir les rôles dans une tribu
local TRIBE_ROLES = {
    LEADER = "leader",      -- Fondateur, peut tout faire
    ELDER = "elder",        -- Peut ajouter/retirer des membres, construire
    MEMBER = "member",      -- Peut construire dans le territoire
    NOVICE = "novice"       -- Nouveau membre, accès limité
}

local ROLE_NAMES = {
    [TRIBE_ROLES.LEADER] = "Chef",
    [TRIBE_ROLES.ELDER] = "Ancien",
    [TRIBE_ROLES.MEMBER] = "Membre",
    [TRIBE_ROLES.NOVICE] = "Novice"
}

local ROLE_COLORS = {
    [TRIBE_ROLES.LEADER] = Color3.fromRGB(255, 215, 0),    -- Or
    [TRIBE_ROLES.ELDER] = Color3.fromRGB(180, 180, 180),   -- Argent
    [TRIBE_ROLES.MEMBER] = Color3.fromRGB(100, 200, 100),  -- Vert
    [TRIBE_ROLES.NOVICE] = Color3.fromRGB(150, 150, 255)   -- Bleu
}

function TribeUI.new()
    local self = setmetatable({}, TribeUI)
    
    -- Référence au joueur local
    self.player = Players.LocalPlayer
    
    -- Interface ScreenGui
    self.gui = nil
    
    -- État de l'interface
    self.isOpen = false
    
    -- Données de la tribu
    self.tribeInfo = nil
    self.tribeDetails = nil
    self.invitations = {}
    
    -- Onglet actif
    self.activeTab = "info"  -- "info", "members", "territory", "log"
    
    -- Callbacks externes
    self.callbacks = {
        onCreateTribe = nil,
        onJoinTribe = nil,
        onLeaveTribe = nil,
        onInvitePlayer = nil,
        onKickMember = nil,
        onPromoteMember = nil,
        onDemoteMember = nil,
        onSetDescription = nil,
        onSetTerritory = nil
    }
    
    return self
end

function TribeUI:Initialize()
    -- Créer l'interface ScreenGui
    self.gui = Instance.new("ScreenGui")
    self.gui.Name = "TribeUI"
    self.gui.ResetOnSpawn = false
    self.gui.Enabled = false
    
    -- Cadre principal
    self.mainFrame = Instance.new("Frame")
    self.mainFrame.Name = "MainFrame"
    self.mainFrame.Size = UDim2.new(0, 700, 0, 500)
    self.mainFrame.Position = UDim2.new(0.5, -350, 0.5, -250)
    self.mainFrame.BackgroundTransparency = 0.2
    self.mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    self.mainFrame.BorderSizePixel = 0
    self.mainFrame.Parent = self.gui
    
    -- Arrondir les coins
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, 10)
    mainCorner.Parent = self.mainFrame
    
    -- Titre de l'interface
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.BackgroundTransparency = 0.5
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = self.mainFrame
    
    -- Arrondir les coins du titre
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleBar
    
    -- Titre
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, -100, 1, 0)
    titleLabel.Position = UDim2.new(0, 10, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Text = "Gestion de Tribu"
    titleLabel.Parent = titleBar
    
    -- Bouton de fermeture
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -35, 0, 5)
    closeButton.BackgroundTransparency = 0.5
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 18
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Text = "X"
    closeButton.Parent = titleBar
    
    -- Arrondir les coins du bouton
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 8)
    closeCorner.Parent = closeButton
    
    -- Créer le contenu principal qui change selon que le joueur est dans une tribu ou non
    self.contentFrame = Instance.new("Frame")
    self.contentFrame.Name = "ContentFrame"
    self.contentFrame.Size = UDim2.new(1, -20, 1, -50)
    self.contentFrame.Position = UDim2.new(0, 10, 0, 45)
    self.contentFrame.BackgroundTransparency = 1
    self.contentFrame.Parent = self.mainFrame
    
    -- Créer les différentes vues
    self:CreateNoTribeView()
    self:CreateTribeView()
    self:CreateInvitationView()
    
    -- Ajouter à l'interface du joueur
    self.gui.Parent = self.player.PlayerGui
    
    -- Connecter les événements
    closeButton.MouseButton1Click:Connect(function()
        self:ToggleTribeUI(false)
    end)
    
    -- Connecter à la touche T pour ouvrir/fermer l'interface
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.T then
            self:ToggleTribeUI(not self.isOpen)
        end
    end)
    
    -- Connecter aux événements de tribu
    self:ConnectToTribeEvents()
    
    return self
end

-- Connecter aux événements de tribu venant du serveur
function TribeUI:ConnectToTribeEvents()
    local events = ReplicatedStorage:FindFirstChild("Events")
    
    if events then
        local tribeUpdateEvent = events:FindFirstChild("TribeUpdate")
        if tribeUpdateEvent then
            tribeUpdateEvent.OnClientEvent:Connect(function(updateType, updateData)
                self:HandleTribeUpdate(updateType, updateData)
            end)
        end
    end
end

-- Gérer les mises à jour de tribu venant du serveur
function TribeUI:HandleTribeUpdate(updateType, updateData)
    if updateType == "player_tribe_update" then
        -- Mise à jour des informations de base de la tribu
        self.tribeInfo = updateData
        self:UpdateView()
    elseif updateType == "tribe_details_update" then
        -- Mise à jour détaillée de la tribu
        self.tribeDetails = updateData
        self:UpdateTribeDetails()
    elseif updateType == "invitation" then
        -- Nouvelle invitation à une tribu
        table.insert(self.invitations, updateData)
        self:ShowInvitationNotification(updateData)
        self:UpdateView()
    elseif updateType == "action_response" then
        -- Réponse à une action de tribu
        self:HandleActionResponse(updateData)
    end
end

-- Gérer les réponses aux actions de tribu
function TribeUI:HandleActionResponse(response)
    -- Afficher un message selon le résultat
    if response.success then
        self:ShowNotification(response.message, "success")
    else
        self:ShowNotification(response.message, "error")
    end
    
    -- Actions spécifiques selon la réponse
    if response.action == "create_tribe" and response.success then
        -- Actualiser après création de tribu
        if response.data and response.data.tribeId then
            -- La mise à jour viendra du serveur
        end
    elseif response.action == "join_tribe" and response.success then
        -- Actualiser après avoir rejoint une tribu
        self:ToggleTribeUI(true)
    elseif response.action == "leave_tribe" and response.success then
        -- Actualiser après avoir quitté une tribu
        self.tribeInfo = nil
        self.tribeDetails = nil
        self:UpdateView()
    elseif response.action == "kicked_from_tribe" then
        -- Le joueur a été expulsé de sa tribu
        self.tribeInfo = nil
        self.tribeDetails = nil
        self:UpdateView()
    elseif response.action == "tribe_dissolved" then
        -- La tribu a été dissoute
        self.tribeInfo = nil
        self.tribeDetails = nil
        self:UpdateView()
    end
end

-- Mettre à jour la vue active selon l'état du joueur
function TribeUI:UpdateView()
    -- Nettoyer le contenu
    self.contentFrame:ClearAllChildren()
    
    if self.tribeInfo then
        -- Afficher la vue de tribu
        self.noTribeView.Visible = false
        self.tribeView.Visible = true
        self.invitationView.Visible = false
        self.tribeView.Parent = self.contentFrame
        
        -- Mettre à jour les informations de la tribu
        self:UpdateTribeInfo()
    elseif #self.invitations > 0 then
        -- Afficher la vue d'invitation
        self.noTribeView.Visible = false
        self.tribeView.Visible = false
        self.invitationView.Visible = true
        self.invitationView.Parent = self.contentFrame
        
        -- Mettre à jour les invitations
        self:UpdateInvitationList()
    else
        -- Afficher la vue "pas de tribu"
        self.noTribeView.Visible = true
        self.tribeView.Visible = false
        self.invitationView.Visible = false
        self.noTribeView.Parent = self.contentFrame
    end
end

-- Créer la vue quand le joueur n'a pas de tribu
function TribeUI:CreateNoTribeView()
    self.noTribeView = Instance.new("Frame")
    self.noTribeView.Name = "NoTribeView"
    self.noTribeView.Size = UDim2.new(1, 0, 1, 0)
    self.noTribeView.BackgroundTransparency = 1
    self.noTribeView.Visible = false
    
    -- Message informatif
    local infoLabel = Instance.new("TextLabel")
    infoLabel.Name = "InfoLabel"
    infoLabel.Size = UDim2.new(1, 0, 0, 50)
    infoLabel.Position = UDim2.new(0, 0, 0, 50)
    infoLabel.BackgroundTransparency = 1
    infoLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    infoLabel.TextSize = 18
    infoLabel.Font = Enum.Font.SourceSans
    infoLabel.Text = "Vous ne faites partie d'aucune tribu.\nCréez la vôtre ou rejoignez-en une existante !"
    infoLabel.Parent = self.noTribeView
    
    -- Cadre pour le formulaire de création
    local createFrame = Instance.new("Frame")
    createFrame.Name = "CreateFrame"
    createFrame.Size = UDim2.new(0, 400, 0, 200)
    createFrame.Position = UDim2.new(0.5, -200, 0, 120)
    createFrame.BackgroundTransparency = 0.7
    createFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    createFrame.BorderSizePixel = 0
    createFrame.Parent = self.noTribeView
    
    -- Titre du formulaire
    local createTitle = Instance.new("TextLabel")
    createTitle.Name = "CreateTitle"
    createTitle.Size = UDim2.new(1, 0, 0, 30)
    createTitle.BackgroundTransparency = 0.5
    createTitle.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    createTitle.BorderSizePixel = 0
    createTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    createTitle.TextSize = 16
    createTitle.Font = Enum.Font.SourceSansBold
    createTitle.Text = "Créer une tribu"
    createTitle.Parent = createFrame
    
    -- Champ pour le nom de la tribu
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(0, 100, 0, 30)
    nameLabel.Position = UDim2.new(0, 10, 0, 40)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.SourceSans
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Text = "Nom:"
    nameLabel.Parent = createFrame
    
    local nameInput = Instance.new("TextBox")
    nameInput.Name = "NameInput"
    nameInput.Size = UDim2.new(1, -120, 0, 30)
    nameInput.Position = UDim2.new(0, 110, 0, 40)
    nameInput.BackgroundTransparency = 0.5
    nameInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    nameInput.BorderSizePixel = 0
    nameInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameInput.TextSize = 16
    nameInput.Font = Enum.Font.SourceSans
    nameInput.PlaceholderText = "Entrez le nom de votre tribu"
    nameInput.Text = ""
    nameInput.ClearTextOnFocus = false
    nameInput.Parent = createFrame
    
    -- Champ pour la description de la tribu
    local descLabel = Instance.new("TextLabel")
    descLabel.Name = "DescLabel"
    descLabel.Size = UDim2.new(0, 100, 0, 30)
    descLabel.Position = UDim2.new(0, 10, 0, 80)
    descLabel.BackgroundTransparency = 1
    descLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    descLabel.TextSize = 16
    descLabel.Font = Enum.Font.SourceSans
    descLabel.TextXAlignment = Enum.TextXAlignment.Left
    descLabel.Text = "Description:"
    descLabel.Parent = createFrame
    
    local descInput = Instance.new("TextBox")
    descInput.Name = "DescInput"
    descInput.Size = UDim2.new(1, -120, 0, 60)
    descInput.Position = UDim2.new(0, 110, 0, 80)
    descInput.BackgroundTransparency = 0.5
    descInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    descInput.BorderSizePixel = 0
    descInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    descInput.TextSize = 16
    descInput.Font = Enum.Font.SourceSans
    descInput.TextXAlignment = Enum.TextXAlignment.Left
    descInput.TextYAlignment = Enum.TextYAlignment.Top
    descInput.PlaceholderText = "Décrivez votre tribu (optionnel)"
    descInput.Text = ""
    descInput.ClearTextOnFocus = false
    descInput.TextWrapped = true
    descInput.MultiLine = true
    descInput.Parent = createFrame
    
    -- Bouton pour créer la tribu
    local createButton = Instance.new("TextButton")
    createButton.Name = "CreateButton"
    createButton.Size = UDim2.new(0, 150, 0, 35)
    createButton.Position = UDim2.new(0.5, -75, 1, -45)
    createButton.BackgroundTransparency = 0.5
    createButton.BackgroundColor3 = Color3.fromRGB(0, 120, 0)
    createButton.BorderSizePixel = 0
    createButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    createButton.TextSize = 16
    createButton.Font = Enum.Font.SourceSansBold
    createButton.Text = "Créer la tribu"
    createButton.Parent = createFrame
    
    -- Arrondir les coins du bouton
    local createButtonCorner = Instance.new("UICorner")
    createButtonCorner.CornerRadius = UDim.new(0, 8)
    createButtonCorner.Parent = createButton
    
    -- Connecter le bouton
    createButton.MouseButton1Click:Connect(function()
        local tribeName = nameInput.Text
        local description = descInput.Text
        
        if tribeName and #tribeName >= 3 and #tribeName &lt;= 20 then
            self:CreateTribe(tribeName, description)
        else
            self:ShowNotification("Le nom de la tribu doit comporter entre 3 et 20 caractères", "error")
        end
    end)
end

-- Créer la vue quand le joueur a une tribu
function TribeUI:CreateTribeView()
    self.tribeView = Instance.new("Frame")
    self.tribeView.Name = "TribeView"
    self.tribeView.Size = UDim2.new(1, 0, 1, 0)
    self.tribeView.BackgroundTransparency = 1
    self.tribeView.Visible = false
    
    -- Créer les onglets
    local tabsFrame = Instance.new("Frame")
    tabsFrame.Name = "TabsFrame"
    tabsFrame.Size = UDim2.new(1, 0, 0, 40)
    tabsFrame.BackgroundTransparency = 0.7
    tabsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    tabsFrame.BorderSizePixel = 0
    tabsFrame.Parent = self.tribeView
    
    -- Créer les boutons d'onglets
    local tabWidth = 150
    local tabPadding = 10
    local tabButtons = {}
    
    local tabs = {
        {id = "info", text = "Informations"},
        {id = "members", text = "Membres"},
        {id = "territory", text = "Territoire"},
        {id = "log", text = "Journal"}
    }
    
    for i, tab in ipairs(tabs) do
        local tabButton = Instance.new("TextButton")
        tabButton.Name = tab.id .. "Tab"
        tabButton.Size = UDim2.new(0, tabWidth, 0, 35)
        tabButton.Position = UDim2.new(0, 10 + (i-1) * (tabWidth + tabPadding), 0, 2)
        tabButton.BackgroundTransparency = 0.5
        tabButton.BackgroundColor3 = tab.id == "info" and Color3.fromRGB(60, 60, 120) or Color3.fromRGB(60, 60, 60)
        tabButton.BorderSizePixel = 0
        tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        tabButton.TextSize = 16
        tabButton.Font = Enum.Font.SourceSansBold
        tabButton.Text = tab.text
        tabButton.Parent = tabsFrame
        
        -- Arrondir les coins
        local tabCorner = Instance.new("UICorner")
        tabCorner.CornerRadius = UDim.new(0, 8)
        tabCorner.Parent = tabButton
        
        -- Connecter l'événement
        tabButton.MouseButton1Click:Connect(function()
            self:SwitchTab(tab.id)
        end)
        
        tabButtons[tab.id] = tabButton
    end
    
    self.tabButtons = tabButtons
    
    -- Contenu des onglets
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = "TabContent"
    contentFrame.Size = UDim2.new(1, 0, 1, -50)
    contentFrame.Position = UDim2.new(0, 0, 0, 50)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Parent = self.tribeView
    
    -- Créer les contenus de chaque onglet
    self:CreateInfoTab(contentFrame)
    self:CreateMembersTab(contentFrame)
    self:CreateTerritoryTab(contentFrame)
    self:CreateLogTab(contentFrame)
    
    -- Activer l'onglet info par défaut
    self:SwitchTab("info")
}

-- Créer l'onglet d'informations
function TribeUI:CreateInfoTab(parent)
    local infoFrame = Instance.new("Frame")
    infoFrame.Name = "InfoTab"
    infoFrame.Size = UDim2.new(1, 0, 1, 0)
    infoFrame.BackgroundTransparency = 1
    infoFrame.Visible = false
    infoFrame.Parent = parent
    
    -- Nom de la tribu
    local nameFrame = Instance.new("Frame")
    nameFrame.Name = "NameFrame"
    nameFrame.Size = UDim2.new(0, 600, 0, 50)
    nameFrame.Position = UDim2.new(0, 30, 0, 20)
    nameFrame.BackgroundTransparency = 0.7
    nameFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    nameFrame.BorderSizePixel = 0
    nameFrame.Parent = infoFrame
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(0, 120, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Text = "Nom de la tribu:"
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Position = UDim2.new(0, 10, 0, 0)
    nameLabel.Parent = nameFrame
    
    local nameValue = Instance.new("TextLabel")
    nameValue.Name = "NameValue"
    nameValue.Size = UDim2.new(1, -140, 1, 0)
    nameValue.Position = UDim2.new(0, 130, 0, 0)
    nameValue.BackgroundTransparency = 1
    nameValue.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameValue.TextSize = 18
    nameValue.Font = Enum.Font.SourceSans
    nameValue.Text = ""
    nameValue.TextXAlignment = Enum.TextXAlignment.Left
    nameValue.Parent = nameFrame
    
    -- Description de la tribu
    local descFrame = Instance.new("Frame")
    descFrame.Name = "DescFrame"
    descFrame.Size = UDim2.new(0, 600, 0, 150)
    descFrame.Position = UDim2.new(0, 30, 0, 80)
    descFrame.BackgroundTransparency = 0.7
    descFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    descFrame.BorderSizePixel = 0
    descFrame.Parent = infoFrame
    
    local descLabel = Instance.new("TextLabel")
    descLabel.Name = "DescLabel"
    descLabel.Size = UDim2.new(1, -20, 0, 30)
    descLabel.Position = UDim2.new(0, 10, 0, 5)
    descLabel.BackgroundTransparency = 1
    descLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    descLabel.TextSize = 16
    descLabel.Font = Enum.Font.SourceSansBold
    descLabel.Text = "Description:"
    descLabel.TextXAlignment = Enum.TextXAlignment.Left
    descLabel.Parent = descFrame
    
    local descScrollFrame = Instance.new("ScrollingFrame")
    descScrollFrame.Name = "DescScrollFrame"
    descScrollFrame.Size = UDim2.new(1, -20, 1, -40)
    descScrollFrame.Position = UDim2.new(0, 10, 0, 35)
    descScrollFrame.BackgroundTransparency = 0.9
    descScrollFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    descScrollFrame.BorderSizePixel = 0
    descScrollFrame.ScrollBarThickness = 6
    descScrollFrame.Parent = descFrame
    
    local descText = Instance.new("TextLabel")
    descText.Name = "DescText"
    descText.Size = UDim2.new(1, -10, 1, 0)
    descText.BackgroundTransparency = 1
    descText.TextColor3 = Color3.fromRGB(255, 255, 255)
    descText.TextSize = 15
    descText.Font = Enum.Font.SourceSans
    descText.Text = ""
    descText.TextWrapped = true
    descText.TextXAlignment = Enum.TextXAlignment.Left
    descText.TextYAlignment = Enum.TextYAlignment.Top
    descText.Parent = descScrollFrame
    
    -- Section d'édition de description (visible uniquement pour leader/elder)
    local editDescFrame = Instance.new("Frame")
    editDescFrame.Name = "EditDescFrame"
    editDescFrame.Size = UDim2.new(0, 600, 0, 150)
    editDescFrame.Position = UDim2.new(0, 30, 0, 240)
    editDescFrame.BackgroundTransparency = 0.7
    editDescFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    editDescFrame.BorderSizePixel = 0
    editDescFrame.Visible = false
    editDescFrame.Parent = infoFrame
    
    local editDescLabel = Instance.new("TextLabel")
    editDescLabel.Name = "EditDescLabel"
    editDescLabel.Size = UDim2.new(1, -20, 0, 30)
    editDescLabel.Position = UDim2.new(0, 10, 0, 5)
    editDescLabel.BackgroundTransparency = 1
    editDescLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    editDescLabel.TextSize = 16
    editDescLabel.Font = Enum.Font.SourceSansBold
    editDescLabel.Text = "Modifier la description:"
    editDescLabel.TextXAlignment = Enum.TextXAlignment.Left
    editDescLabel.Parent = editDescFrame
    
    local editDescInput = Instance.new("TextBox")
    editDescInput.Name = "EditDescInput"
    editDescInput.Size = UDim2.new(1, -20, 1, -80)
    editDescInput.Position = UDim2.new(0, 10, 0, 35)
    editDescInput.BackgroundTransparency = 0.5
    editDescInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    editDescInput.BorderSizePixel = 0
    editDescInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    editDescInput.TextSize = 15
    editDescInput.Font = Enum.Font.SourceSans
    editDescInput.Text = ""
    editDescInput.PlaceholderText = "Entrez une nouvelle description pour votre tribu"
    editDescInput.TextWrapped = true
    editDescInput.TextXAlignment = Enum.TextXAlignment.Left
    editDescInput.TextYAlignment = Enum.TextYAlignment.Top
    editDescInput.ClearTextOnFocus = false
    editDescInput.MultiLine = true
    editDescInput.Parent = editDescFrame
    
    local saveDescButton = Instance.new("TextButton")
    saveDescButton.Name = "SaveDescButton"
    saveDescButton.Size = UDim2.new(0, 150, 0, 30)
    saveDescButton.Position = UDim2.new(0.5, -75, 1, -35)
    saveDescButton.BackgroundTransparency = 0.5
    saveDescButton.BackgroundColor3 = Color3</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="70">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
      <bool name="NeedsPivotMigration">false</bool>
      <bool name="StreamingEnabled">true</bool>
    </Properties>
    <Item class="Model" referent="71">
      <Properties>
        <string name="Name">Map</string>
        <bool name="NeedsPivotMigration">false</bool>
      </Properties>
      <Item class="Folder" referent="72">
        <Properties>
          <string name="Name">Resources</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="73">
        <Properties>
          <string name="Name">Structures</string>
        </Properties>
      </Item>
      <Item class="Terrain" referent="74">
        <Properties>
          <string name="Name">Terrain</string>
          <float name="WaterReflectance">0.1</float>
          <float name="WaterTransparency">0.5</float>
          <float name="WaterWaveSize">0.1</float>
          <float name="WaterWaveSpeed">10</float>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>